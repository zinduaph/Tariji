{"version":3,"file":"index.cjs.js","sources":["../src/api/observer.ts","../src/lite-api/aggregate_types.ts","../src/lite-api/snapshot.ts","../src/lite-api/query.ts","../src/lite-api/reference_impl.ts","../src/lite-api/aggregate.ts","../src/api/aggregate.ts","../src/api/cache_config.ts","../src/api/snapshot.ts","../src/platform/browser/snapshot_to_json.ts","../src/core/transaction_options.ts","../src/lite-api/write_batch.ts","../src/lite-api/transaction.ts","../src/api/transaction.ts","../src/api/reference_impl.ts","../src/api/write_batch.ts","../src/api/index_configuration.ts","../src/api/persistent_cache_index_manager.ts","../src/util/testing_hooks.ts","../src/register.ts","../src/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject } from '../model/object_value';\nimport { FirestoreError } from '../util/error';\n\n/**\n * Observer/Subscribe interfaces.\n */\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: FirestoreError) => void;\nexport type CompleteFn = () => void;\n\n// Allow for any of the Observer methods to be undefined.\nexport interface PartialObserver<T> {\n  next?: NextFn<T>;\n  error?: ErrorFn;\n  complete?: CompleteFn;\n}\n\nexport function isPartialObserver<T>(obj: unknown): obj is PartialObserver<T> {\n  return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj: unknown, methods: string[]): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const object = obj as JsonObject<unknown>;\n  for (const method of methods) {\n    if (method in object && typeof object[method] === 'function') {\n      return true;\n    }\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AggregateType } from '../core/aggregate';\nimport { ObjectValue } from '../model/object_value';\nimport { FieldPath as InternalFieldPath } from '../model/path';\nimport {\n  ApiClientObjectMap,\n  firestoreV1ApiClientInterfaces,\n  Value\n} from '../protos/firestore_proto_api';\n\nimport { average, count, sum } from './aggregate';\nimport { DocumentData, Query } from './reference';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\nexport { AggregateType };\n\n/**\n * Represents an aggregation that can be performed by Firestore.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport class AggregateField<T> {\n  /** A type string to uniquely identify instances of this class. */\n  readonly type = 'AggregateField';\n\n  /** Indicates the aggregation operation of this AggregateField. */\n  readonly aggregateType: AggregateType;\n\n  /**\n   * Create a new AggregateField<T>\n   * @param aggregateType - Specifies the type of aggregation operation to perform.\n   * @param _internalFieldPath - Optionally specifies the field that is aggregated.\n   * @internal\n   */\n  constructor(\n    aggregateType: AggregateType = 'count',\n    readonly _internalFieldPath?: InternalFieldPath\n  ) {\n    this.aggregateType = aggregateType;\n  }\n}\n\n/**\n * The union of all `AggregateField` types that are supported by Firestore.\n */\nexport type AggregateFieldType =\n  | ReturnType<typeof sum>\n  | ReturnType<typeof average>\n  | ReturnType<typeof count>;\n\n/**\n * Specifies a set of aggregations and their aliases.\n */\nexport interface AggregateSpec {\n  [field: string]: AggregateFieldType;\n}\n\n/**\n * A type whose keys are taken from an `AggregateSpec`, and whose values are the\n * result of the aggregation performed by the corresponding `AggregateField`\n * from the input `AggregateSpec`.\n */\nexport type AggregateSpecData<T extends AggregateSpec> = {\n  [P in keyof T]: T[P] extends AggregateField<infer U> ? U : never;\n};\n\n/**\n * The results of executing an aggregation query.\n */\nexport class AggregateQuerySnapshot<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> {\n  /** A type string to uniquely identify instances of this class. */\n  readonly type = 'AggregateQuerySnapshot';\n\n  /**\n   * The underlying query over which the aggregations recorded in this\n   * `AggregateQuerySnapshot` were performed.\n   */\n  readonly query: Query<AppModelType, DbModelType>;\n\n  /** @hideconstructor */\n  constructor(\n    query: Query<AppModelType, DbModelType>,\n    private readonly _userDataWriter: AbstractUserDataWriter,\n    private readonly _data: ApiClientObjectMap<Value>\n  ) {\n    this.query = query;\n  }\n\n  /**\n   * Returns the results of the aggregations performed over the underlying\n   * query.\n   *\n   * The keys of the returned object will be the same as those of the\n   * `AggregateSpec` object specified to the aggregation method, and the values\n   * will be the corresponding aggregation result.\n   *\n   * @returns The results of the aggregations performed over the underlying\n   * query.\n   */\n  data(): AggregateSpecData<AggregateSpecType> {\n    return this._userDataWriter.convertObjectMap(\n      this._data\n    ) as AggregateSpecData<AggregateSpecType>;\n  }\n\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the snapshot as a proto value.\n   *\n   * @returns An `Object` containing all fields in the snapshot.\n   */\n  _fieldsProto(): { [key: string]: firestoreV1ApiClientInterfaces.Value } {\n    // Wrap data in an ObjectValue to clone it.\n    const dataClone = new ObjectValue({\n      mapValue: { fields: this._data }\n    }).clone();\n\n    // Return the cloned value to prevent manipulation of the Snapshot's data\n    return dataClone.value.mapValue.fields!;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getModularInstance } from '@firebase/util';\n\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { firestoreV1ApiClientInterfaces } from '../protos/firestore_proto_api';\nimport { arrayEquals } from '../util/misc';\n\nimport { Firestore } from './database';\nimport { FieldPath } from './field_path';\nimport {\n  DocumentData,\n  DocumentReference,\n  PartialWithFieldValue,\n  Query,\n  queryEqual,\n  SetOptions,\n  WithFieldValue\n} from './reference';\nimport {\n  fieldPathFromArgument,\n  UntypedFirestoreDataConverter\n} from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * Converter used by `withConverter()` to transform user objects of type\n * `AppModelType` into Firestore data of type `DbModelType`.\n *\n * Using the converter allows you to specify generic type arguments when\n * storing and retrieving objects from Firestore.\n *\n * In this context, an \"AppModel\" is a class that is used in an application to\n * package together related information and functionality. Such a class could,\n * for example, have properties with complex, nested data types, properties used\n * for memoization, properties of types not supported by Firestore (such as\n * `symbol` and `bigint`), and helper functions that perform compound\n * operations. Such classes are not suitable and/or possible to store into a\n * Firestore database. Instead, instances of such classes need to be converted\n * to \"plain old JavaScript objects\" (POJOs) with exclusively primitive\n * properties, potentially nested inside other POJOs or arrays of POJOs. In this\n * context, this type is referred to as the \"DbModel\" and would be an object\n * suitable for persisting into Firestore. For convenience, applications can\n * implement `FirestoreDataConverter` and register the converter with Firestore\n * objects, such as `DocumentReference` or `Query`, to automatically convert\n * `AppModel` to `DbModel` when storing into Firestore, and convert `DbModel`\n * to `AppModel` when retrieving from Firestore.\n *\n * @example\n *\n * Simple Example\n *\n * ```typescript\n * const numberConverter = {\n *     toFirestore(value: WithFieldValue<number>) {\n *         return { value };\n *     },\n *     fromFirestore(snapshot: QueryDocumentSnapshot, options: SnapshotOptions) {\n *         return snapshot.data(options).value as number;\n *     }\n * };\n *\n * async function simpleDemo(db: Firestore): Promise<void> {\n *     const documentRef = doc(db, 'values/value123').withConverter(numberConverter);\n *\n *     // converters are used with `setDoc`, `addDoc`, and `getDoc`\n *     await setDoc(documentRef, 42);\n *     const snapshot1 = await getDoc(documentRef);\n *     assertEqual(snapshot1.data(), 42);\n *\n *     // converters are not used when writing data with `updateDoc`\n *     await updateDoc(documentRef, { value: 999 });\n *     const snapshot2 = await getDoc(documentRef);\n *     assertEqual(snapshot2.data(), 999);\n * }\n * ```\n *\n * Advanced Example\n *\n * ```typescript\n * // The Post class is a model that is used by our application.\n * // This class may have properties and methods that are specific\n * // to our application execution, which do not need to be persisted\n * // to Firestore.\n * class Post {\n *     constructor(\n *         readonly title: string,\n *         readonly author: string,\n *         readonly lastUpdatedMillis: number\n *     ) {}\n *     toString(): string {\n *         return `${this.title} by ${this.author}`;\n *     }\n * }\n *\n * // The PostDbModel represents how we want our posts to be stored\n * // in Firestore. This DbModel has different properties (`ttl`,\n * // `aut`, and `lut`) from the Post class we use in our application.\n * interface PostDbModel {\n *     ttl: string;\n *     aut: { firstName: string; lastName: string };\n *     lut: Timestamp;\n * }\n *\n * // The `PostConverter` implements `FirestoreDataConverter` and specifies\n * // how the Firestore SDK can convert `Post` objects to `PostDbModel`\n * // objects and vice versa.\n * class PostConverter implements FirestoreDataConverter<Post, PostDbModel> {\n *     toFirestore(post: WithFieldValue<Post>): WithFieldValue<PostDbModel> {\n *         return {\n *             ttl: post.title,\n *             aut: this._autFromAuthor(post.author),\n *             lut: this._lutFromLastUpdatedMillis(post.lastUpdatedMillis)\n *         };\n *     }\n *\n *     fromFirestore(snapshot: QueryDocumentSnapshot, options: SnapshotOptions): Post {\n *         const data = snapshot.data(options) as PostDbModel;\n *         const author = `${data.aut.firstName} ${data.aut.lastName}`;\n *         return new Post(data.ttl, author, data.lut.toMillis());\n *     }\n *\n *     _autFromAuthor(\n *         author: string | FieldValue\n *     ): { firstName: string; lastName: string } | FieldValue {\n *         if (typeof author !== 'string') {\n *             // `author` is a FieldValue, so just return it.\n *             return author;\n *         }\n *         const [firstName, lastName] = author.split(' ');\n *         return {firstName, lastName};\n *     }\n *\n *     _lutFromLastUpdatedMillis(\n *         lastUpdatedMillis: number | FieldValue\n *     ): Timestamp | FieldValue {\n *         if (typeof lastUpdatedMillis !== 'number') {\n *             // `lastUpdatedMillis` must be a FieldValue, so just return it.\n *             return lastUpdatedMillis;\n *         }\n *         return Timestamp.fromMillis(lastUpdatedMillis);\n *     }\n * }\n *\n * async function advancedDemo(db: Firestore): Promise<void> {\n *     // Create a `DocumentReference` with a `FirestoreDataConverter`.\n *     const documentRef = doc(db, 'posts/post123').withConverter(new PostConverter());\n *\n *     // The `data` argument specified to `setDoc()` is type checked by the\n *     // TypeScript compiler to be compatible with `Post`. Since the `data`\n *     // argument is typed as `WithFieldValue<Post>` rather than just `Post`,\n *     // this allows properties of the `data` argument to also be special\n *     // Firestore values that perform server-side mutations, such as\n *     // `arrayRemove()`, `deleteField()`, and `serverTimestamp()`.\n *     await setDoc(documentRef, {\n *         title: 'My Life',\n *         author: 'Foo Bar',\n *         lastUpdatedMillis: serverTimestamp()\n *     });\n *\n *     // The TypeScript compiler will fail to compile if the `data` argument to\n *     // `setDoc()` is _not_ compatible with `WithFieldValue<Post>`. This\n *     // type checking prevents the caller from specifying objects with incorrect\n *     // properties or property values.\n *     // @ts-expect-error \"Argument of type { ttl: string; } is not assignable\n *     // to parameter of type WithFieldValue<Post>\"\n *     await setDoc(documentRef, { ttl: 'The Title' });\n *\n *     // When retrieving a document with `getDoc()` the `DocumentSnapshot`\n *     // object's `data()` method returns a `Post`, rather than a generic object,\n *     // which would have been returned if the `DocumentReference` did _not_ have a\n *     // `FirestoreDataConverter` attached to it.\n *     const snapshot1: DocumentSnapshot<Post> = await getDoc(documentRef);\n *     const post1: Post = snapshot1.data()!;\n *     if (post1) {\n *         assertEqual(post1.title, 'My Life');\n *         assertEqual(post1.author, 'Foo Bar');\n *     }\n *\n *     // The `data` argument specified to `updateDoc()` is type checked by the\n *     // TypeScript compiler to be compatible with `PostDbModel`. Note that\n *     // unlike `setDoc()`, whose `data` argument must be compatible with `Post`,\n *     // the `data` argument to `updateDoc()` must be compatible with\n *     // `PostDbModel`. Similar to `setDoc()`, since the `data` argument is typed\n *     // as `WithFieldValue<PostDbModel>` rather than just `PostDbModel`, this\n *     // allows properties of the `data` argument to also be those special\n *     // Firestore values, like `arrayRemove()`, `deleteField()`, and\n *     // `serverTimestamp()`.\n *     await updateDoc(documentRef, {\n *         'aut.firstName': 'NewFirstName',\n *         lut: serverTimestamp()\n *     });\n *\n *     // The TypeScript compiler will fail to compile if the `data` argument to\n *     // `updateDoc()` is _not_ compatible with `WithFieldValue<PostDbModel>`.\n *     // This type checking prevents the caller from specifying objects with\n *     // incorrect properties or property values.\n *     // @ts-expect-error \"Argument of type { title: string; } is not assignable\n *     // to parameter of type WithFieldValue<PostDbModel>\"\n *     await updateDoc(documentRef, { title: 'New Title' });\n *     const snapshot2: DocumentSnapshot<Post> = await getDoc(documentRef);\n *     const post2: Post = snapshot2.data()!;\n *     if (post2) {\n *         assertEqual(post2.title, 'My Life');\n *         assertEqual(post2.author, 'NewFirstName Bar');\n *     }\n * }\n * ```\n */\nexport interface FirestoreDataConverter<\n  AppModelType,\n  DbModelType extends DocumentData = DocumentData\n> {\n  /**\n   * Called by the Firestore SDK to convert a custom model object of type\n   * `AppModelType` into a plain JavaScript object (suitable for writing\n   * directly to the Firestore database) of type `DbModelType`. Used with\n   * {@link @firebase/firestore/lite#(setDoc:1)},\n   * {@link @firebase/firestore/lite#(WriteBatch.set:1)} and\n   * {@link @firebase/firestore/lite#(Transaction.set:1)}.\n   *\n   * The `WithFieldValue<T>` type extends `T` to also allow FieldValues such as\n   * {@link (deleteField:1)} to be used as property values.\n   */\n  toFirestore(\n    modelObject: WithFieldValue<AppModelType>\n  ): WithFieldValue<DbModelType>;\n\n  /**\n   * Called by the Firestore SDK to convert a custom model object of type\n   * `AppModelType` into a plain JavaScript object (suitable for writing\n   * directly to the Firestore database) of type `DbModelType`. Used with\n   * {@link @firebase/firestore/lite#(setDoc:1)},\n   * {@link @firebase/firestore/lite#(WriteBatch.set:1)} and\n   * {@link @firebase/firestore/lite#(Transaction.set:1)} with `merge:true`\n   * or `mergeFields`.\n   *\n   * The `PartialWithFieldValue<T>` type extends `Partial<T>` to allow\n   * FieldValues such as {@link (arrayUnion:1)} to be used as property values.\n   * It also supports nested `Partial` by allowing nested fields to be\n   * omitted.\n   */\n  toFirestore(\n    modelObject: PartialWithFieldValue<AppModelType>,\n    options: SetOptions\n  ): PartialWithFieldValue<DbModelType>;\n\n  /**\n   * Called by the Firestore SDK to convert Firestore data into an object of\n   * type `AppModelType`. You can access your data by calling:\n   * `snapshot.data()`.\n   *\n   *\n   * Generally, the data returned from `snapshot.data()` can be cast to\n   * `DbModelType`; however, this is not guaranteed because Firestore does not\n   * enforce a schema on the database. For example, writes from a previous\n   * version of the application or writes from another client that did not use a\n   * type converter could have written data with different properties and/or\n   * property types. The implementation will need to choose whether to\n   * gracefully recover from non-conforming data or throw an error.\n   *\n   * @param snapshot - A `QueryDocumentSnapshot` containing your data and\n   * metadata.\n   */\n  fromFirestore(\n    snapshot: QueryDocumentSnapshot<DocumentData, DocumentData>\n  ): AppModelType;\n}\n\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nexport class DocumentSnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> {\n  // Note: This class is stripped down version of the DocumentSnapshot in\n  // the legacy SDK. The changes are:\n  // - No support for SnapshotMetadata.\n  // - No support for SnapshotOptions.\n\n  /** @hideconstructor protected */\n  constructor(\n    public _firestore: Firestore,\n    public _userDataWriter: AbstractUserDataWriter,\n    public _key: DocumentKey,\n    public _document: Document | null,\n    public _converter: UntypedFirestoreDataConverter<\n      AppModelType,\n      DbModelType\n    > | null\n  ) {}\n\n  /** Property of the `DocumentSnapshot` that provides the document's ID. */\n  get id(): string {\n    return this._key.path.lastSegment();\n  }\n\n  /**\n   * The `DocumentReference` for the document included in the `DocumentSnapshot`.\n   */\n  get ref(): DocumentReference<AppModelType, DbModelType> {\n    return new DocumentReference<AppModelType, DbModelType>(\n      this._firestore,\n      this._converter,\n      this._key\n    );\n  }\n\n  /**\n   * Signals whether or not the document at the snapshot's location exists.\n   *\n   * @returns true if the document exists.\n   */\n  exists(): this is QueryDocumentSnapshot<AppModelType, DbModelType> {\n    return this._document !== null;\n  }\n\n  /**\n   * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n   * the document doesn't exist.\n   *\n   * @returns An `Object` containing all fields in the document or `undefined`\n   * if the document doesn't exist.\n   */\n  data(): AppModelType | undefined {\n    if (!this._document) {\n      return undefined;\n    } else if (this._converter) {\n      // We only want to use the converter and create a new DocumentSnapshot\n      // if a converter has been provided.\n      const snapshot = new QueryDocumentSnapshot(\n        this._firestore,\n        this._userDataWriter,\n        this._key,\n        this._document,\n        /* converter= */ null\n      );\n      return this._converter.fromFirestore(snapshot);\n    } else {\n      return this._userDataWriter.convertValue(\n        this._document.data.value\n      ) as AppModelType;\n    }\n  }\n\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the document as a proto Value. Returns `undefined` if\n   * the document doesn't exist.\n   *\n   * @returns An `Object` containing all fields in the document or `undefined`\n   * if the document doesn't exist.\n   */\n  _fieldsProto():\n    | { [key: string]: firestoreV1ApiClientInterfaces.Value }\n    | undefined {\n    // Return a cloned value to prevent manipulation of the Snapshot's data\n    return this._document?.data.clone().value.mapValue.fields ?? undefined;\n  }\n\n  /**\n   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n   * document or field doesn't exist.\n   *\n   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n   * field.\n   * @returns The data at the specified field location or undefined if no such\n   * field exists in the document.\n   */\n  // We are using `any` here to avoid an explicit cast by our users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(fieldPath: string | FieldPath): any {\n    if (this._document) {\n      const value = this._document.data.field(\n        fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n      );\n      if (value !== null) {\n        return this._userDataWriter.convertValue(value);\n      }\n    }\n    return undefined;\n  }\n}\n\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nexport class QueryDocumentSnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> extends DocumentSnapshot<AppModelType, DbModelType> {\n  /**\n   * Retrieves all fields in the document as an `Object`.\n   *\n   * @override\n   * @returns An `Object` containing all fields in the document.\n   */\n  data(): AppModelType {\n    return super.data() as AppModelType;\n  }\n}\n\n/**\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\n * representing the results of a query. The documents can be accessed as an\n * array via the `docs` property or enumerated using the `forEach` method. The\n * number of documents can be determined via the `empty` and `size`\n * properties.\n */\nexport class QuerySnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> {\n  /**\n   * The query on which you called {@link getDocs} in order to get this\n   * `QuerySnapshot`.\n   */\n  readonly query: Query<AppModelType, DbModelType>;\n\n  /** @hideconstructor */\n  constructor(\n    _query: Query<AppModelType, DbModelType>,\n    readonly _docs: Array<QueryDocumentSnapshot<AppModelType, DbModelType>>\n  ) {\n    this.query = _query;\n  }\n\n  /** An array of all the documents in the `QuerySnapshot`. */\n  get docs(): Array<QueryDocumentSnapshot<AppModelType, DbModelType>> {\n    return [...this._docs];\n  }\n\n  /** The number of documents in the `QuerySnapshot`. */\n  get size(): number {\n    return this.docs.length;\n  }\n\n  /** True if there are no documents in the `QuerySnapshot`. */\n  get empty(): boolean {\n    return this.docs.length === 0;\n  }\n\n  /**\n   * Enumerates all of the documents in the `QuerySnapshot`.\n   *\n   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\n   * each document in the snapshot.\n   * @param thisArg - The `this` binding for the callback.\n   */\n  forEach(\n    callback: (\n      result: QueryDocumentSnapshot<AppModelType, DbModelType>\n    ) => void,\n    thisArg?: unknown\n  ): void {\n    this._docs.forEach(callback, thisArg);\n  }\n}\n\n/**\n * Returns true if the provided snapshots are equal.\n *\n * @param left - A snapshot to compare.\n * @param right - A snapshot to compare.\n * @returns true if the snapshots are equal.\n */\nexport function snapshotEqual<AppModelType, DbModelType extends DocumentData>(\n  left:\n    | DocumentSnapshot<AppModelType, DbModelType>\n    | QuerySnapshot<AppModelType, DbModelType>,\n  right:\n    | DocumentSnapshot<AppModelType, DbModelType>\n    | QuerySnapshot<AppModelType, DbModelType>\n): boolean {\n  left = getModularInstance(left);\n  right = getModularInstance(right);\n\n  if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\n    return (\n      left._firestore === right._firestore &&\n      left._key.isEqual(right._key) &&\n      (left._document === null\n        ? right._document === null\n        : left._document.isEqual(right._document)) &&\n      left._converter === right._converter\n    );\n  } else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\n    return (\n      queryEqual(left.query, right.query) &&\n      arrayEquals(left.docs, right.docs, snapshotEqual)\n    );\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getModularInstance } from '@firebase/util';\n\nimport { Bound } from '../core/bound';\nimport { DatabaseId } from '../core/database_info';\nimport {\n  CompositeFilter,\n  CompositeOperator,\n  FieldFilter,\n  Filter,\n  Operator\n} from '../core/filter';\nimport { Direction, OrderBy } from '../core/order_by';\nimport {\n  isCollectionGroupQuery,\n  LimitType,\n  Query as InternalQuery,\n  queryNormalizedOrderBy,\n  queryWithAddedFilter,\n  queryWithAddedOrderBy,\n  queryWithEndAt,\n  queryWithLimit,\n  queryWithStartAt\n} from '../core/query';\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { FieldPath as InternalFieldPath, ResourcePath } from '../model/path';\nimport { isServerTimestamp } from '../model/server_timestamps';\nimport { refValue } from '../model/values';\nimport { Value as ProtoValue } from '../protos/firestore_proto_api';\nimport { Code, FirestoreError } from '../util/error';\nimport {\n  validatePositiveNumber,\n  valueDescription\n} from '../util/input_validation';\n\nimport { FieldPath } from './field_path';\nimport { DocumentData, DocumentReference, Query } from './reference';\nimport { DocumentSnapshot } from './snapshot';\nimport {\n  fieldPathFromArgument,\n  newUserDataReader,\n  parseQueryValue,\n  UserDataReader\n} from './user_data_reader';\n\nexport function validateHasExplicitOrderByForLimitToLast(\n  query: InternalQuery\n): void {\n  if (\n    query.limitType === LimitType.Last &&\n    query.explicitOrderBy.length === 0\n  ) {\n    throw new FirestoreError(\n      Code.UNIMPLEMENTED,\n      'limitToLast() queries require specifying at least one orderBy() clause'\n    );\n  }\n}\n\n/** Describes the different query constraints available in this SDK. */\nexport type QueryConstraintType =\n  | 'where'\n  | 'orderBy'\n  | 'limit'\n  | 'limitToLast'\n  | 'startAt'\n  | 'startAfter'\n  | 'endAt'\n  | 'endBefore';\n\n/**\n * An `AppliableConstraint` is an abstraction of a constraint that can be applied\n * to a Firestore query.\n */\nexport abstract class AppliableConstraint {\n  /**\n   * Takes the provided {@link Query} and returns a copy of the {@link Query} with this\n   * {@link AppliableConstraint} applied.\n   */\n  abstract _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType>;\n}\n\n/**\n * A `QueryConstraint` is used to narrow the set of documents returned by a\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\n * (endBefore:1)}, {@link (endAt:1)}, {@link limit}, {@link limitToLast} and\n * can then be passed to {@link (query:1)} to create a new query instance that\n * also contains this `QueryConstraint`.\n */\nexport abstract class QueryConstraint extends AppliableConstraint {\n  /** The type of this query constraint */\n  abstract readonly type: QueryConstraintType;\n\n  /**\n   * Takes the provided {@link Query} and returns a copy of the {@link Query} with this\n   * {@link AppliableConstraint} applied.\n   */\n  abstract _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType>;\n}\n\n/**\n * Creates a new immutable instance of {@link Query} that is extended to also\n * include additional query constraints.\n *\n * @param query - The {@link Query} instance to use as a base for the new\n * constraints.\n * @param compositeFilter - The {@link QueryCompositeFilterConstraint} to\n * apply. Create {@link QueryCompositeFilterConstraint} using {@link and} or\n * {@link or}.\n * @param queryConstraints - Additional {@link QueryNonFilterConstraint}s to\n * apply (e.g. {@link orderBy}, {@link limit}).\n * @throws if any of the provided query constraints cannot be combined with the\n * existing or new constraints.\n */\nexport function query<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  compositeFilter: QueryCompositeFilterConstraint,\n  ...queryConstraints: QueryNonFilterConstraint[]\n): Query<AppModelType, DbModelType>;\n\n/**\n * Creates a new immutable instance of {@link Query} that is extended to also\n * include additional query constraints.\n *\n * @param query - The {@link Query} instance to use as a base for the new\n * constraints.\n * @param queryConstraints - The list of {@link QueryConstraint}s to apply.\n * @throws if any of the provided query constraints cannot be combined with the\n * existing or new constraints.\n */\nexport function query<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  ...queryConstraints: QueryConstraint[]\n): Query<AppModelType, DbModelType>;\n\nexport function query<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  queryConstraint: QueryCompositeFilterConstraint | QueryConstraint | undefined,\n  ...additionalQueryConstraints: Array<\n    QueryConstraint | QueryNonFilterConstraint\n  >\n): Query<AppModelType, DbModelType> {\n  let queryConstraints: AppliableConstraint[] = [];\n\n  if (queryConstraint instanceof AppliableConstraint) {\n    queryConstraints.push(queryConstraint);\n  }\n\n  queryConstraints = queryConstraints.concat(additionalQueryConstraints);\n\n  validateQueryConstraintArray(queryConstraints);\n\n  for (const constraint of queryConstraints) {\n    query = constraint._apply(query);\n  }\n  return query;\n}\n\n/**\n * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by\n * a Firestore query by filtering on one or more document fields.\n * `QueryFieldFilterConstraint`s are created by invoking {@link where} and can then\n * be passed to {@link (query:1)} to create a new query instance that also contains\n * this `QueryFieldFilterConstraint`.\n */\nexport class QueryFieldFilterConstraint extends QueryConstraint {\n  /** The type of this query constraint */\n  readonly type = 'where';\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    private readonly _field: InternalFieldPath,\n    private _op: Operator,\n    private _value: unknown\n  ) {\n    super();\n  }\n\n  static _create(\n    _field: InternalFieldPath,\n    _op: Operator,\n    _value: unknown\n  ): QueryFieldFilterConstraint {\n    return new QueryFieldFilterConstraint(_field, _op, _value);\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    const filter = this._parse(query);\n    validateNewFieldFilter(query._query, filter);\n    return new Query(\n      query.firestore,\n      query.converter,\n      queryWithAddedFilter(query._query, filter)\n    );\n  }\n\n  _parse<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): FieldFilter {\n    const reader = newUserDataReader(query.firestore);\n    const filter = newQueryFilter(\n      query._query,\n      'where',\n      reader,\n      query.firestore._databaseId,\n      this._field,\n      this._op,\n      this._value\n    );\n    return filter;\n  }\n}\n\n/**\n * Filter conditions in a {@link where} clause are specified using the\n * strings '&lt;', '&lt;=', '==', '!=', '&gt;=', '&gt;', 'array-contains', 'in',\n * 'array-contains-any', and 'not-in'.\n */\nexport type WhereFilterOp =\n  | '<'\n  | '<='\n  | '=='\n  | '!='\n  | '>='\n  | '>'\n  | 'array-contains'\n  | 'in'\n  | 'array-contains-any'\n  | 'not-in';\n\n/**\n * Creates a {@link QueryFieldFilterConstraint} that enforces that documents\n * must contain the specified field and that the value should satisfy the\n * relation constraint provided.\n *\n * @param fieldPath - The path to compare\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\n *   \"&lt;=\", \"!=\").\n * @param value - The value for comparison\n * @returns The created {@link QueryFieldFilterConstraint}.\n */\nexport function where(\n  fieldPath: string | FieldPath,\n  opStr: WhereFilterOp,\n  value: unknown\n): QueryFieldFilterConstraint {\n  const op = opStr as Operator;\n  const field = fieldPathFromArgument('where', fieldPath);\n  return QueryFieldFilterConstraint._create(field, op, value);\n}\n\n/**\n * A `QueryCompositeFilterConstraint` is used to narrow the set of documents\n * returned by a Firestore query by performing the logical OR or AND of multiple\n * {@link QueryFieldFilterConstraint}s or {@link QueryCompositeFilterConstraint}s.\n * `QueryCompositeFilterConstraint`s are created by invoking {@link or} or\n * {@link and} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains the `QueryCompositeFilterConstraint`.\n */\nexport class QueryCompositeFilterConstraint extends AppliableConstraint {\n  /**\n   * @internal\n   */\n  protected constructor(\n    /** The type of this query constraint */\n    readonly type: 'or' | 'and',\n    private readonly _queryConstraints: QueryFilterConstraint[]\n  ) {\n    super();\n  }\n\n  static _create(\n    type: 'or' | 'and',\n    _queryConstraints: QueryFilterConstraint[]\n  ): QueryCompositeFilterConstraint {\n    return new QueryCompositeFilterConstraint(type, _queryConstraints);\n  }\n\n  _parse<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Filter {\n    const parsedFilters = this._queryConstraints\n      .map(queryConstraint => {\n        return queryConstraint._parse(query);\n      })\n      .filter(parsedFilter => parsedFilter.getFilters().length > 0);\n\n    if (parsedFilters.length === 1) {\n      return parsedFilters[0];\n    }\n\n    return CompositeFilter.create(parsedFilters, this._getOperator());\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    const parsedFilter = this._parse(query);\n    if (parsedFilter.getFilters().length === 0) {\n      // Return the existing query if not adding any more filters (e.g. an empty\n      // composite filter).\n      return query;\n    }\n    validateNewFilter(query._query, parsedFilter);\n\n    return new Query(\n      query.firestore,\n      query.converter,\n      queryWithAddedFilter(query._query, parsedFilter)\n    );\n  }\n\n  _getQueryConstraints(): readonly AppliableConstraint[] {\n    return this._queryConstraints;\n  }\n\n  _getOperator(): CompositeOperator {\n    return this.type === 'and' ? CompositeOperator.AND : CompositeOperator.OR;\n  }\n}\n\n/**\n * `QueryNonFilterConstraint` is a helper union type that represents\n * QueryConstraints which are used to narrow or order the set of documents,\n * but that do not explicitly filter on a document field.\n * `QueryNonFilterConstraint`s are created by invoking {@link orderBy},\n * {@link (startAt:1)}, {@link (startAfter:1)}, {@link (endBefore:1)}, {@link (endAt:1)},\n * {@link limit} or {@link limitToLast} and can then be passed to {@link (query:1)}\n * to create a new query instance that also contains the `QueryConstraint`.\n */\nexport type QueryNonFilterConstraint =\n  | QueryOrderByConstraint\n  | QueryLimitConstraint\n  | QueryStartAtConstraint\n  | QueryEndAtConstraint;\n\n/**\n * `QueryFilterConstraint` is a helper union type that represents\n * {@link QueryFieldFilterConstraint} and {@link QueryCompositeFilterConstraint}.\n */\nexport type QueryFilterConstraint =\n  | QueryFieldFilterConstraint\n  | QueryCompositeFilterConstraint;\n\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a disjunction of\n * the given filter constraints. A disjunction filter includes a document if it\n * satisfies any of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a disjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nexport function or(\n  ...queryConstraints: QueryFilterConstraint[]\n): QueryCompositeFilterConstraint {\n  // Only support QueryFilterConstraints\n  queryConstraints.forEach(queryConstraint =>\n    validateQueryFilterConstraint('or', queryConstraint)\n  );\n\n  return QueryCompositeFilterConstraint._create(\n    CompositeOperator.OR,\n    queryConstraints as QueryFilterConstraint[]\n  );\n}\n\n/**\n * Creates a new {@link QueryCompositeFilterConstraint} that is a conjunction of\n * the given filter constraints. A conjunction filter includes a document if it\n * satisfies all of the given filters.\n *\n * @param queryConstraints - Optional. The list of\n * {@link QueryFilterConstraint}s to perform a conjunction for. These must be\n * created with calls to {@link where}, {@link or}, or {@link and}.\n * @returns The newly created {@link QueryCompositeFilterConstraint}.\n */\nexport function and(\n  ...queryConstraints: QueryFilterConstraint[]\n): QueryCompositeFilterConstraint {\n  // Only support QueryFilterConstraints\n  queryConstraints.forEach(queryConstraint =>\n    validateQueryFilterConstraint('and', queryConstraint)\n  );\n\n  return QueryCompositeFilterConstraint._create(\n    CompositeOperator.AND,\n    queryConstraints as QueryFilterConstraint[]\n  );\n}\n\n/**\n * A `QueryOrderByConstraint` is used to sort the set of documents returned by a\n * Firestore query. `QueryOrderByConstraint`s are created by invoking\n * {@link orderBy} and can then be passed to {@link (query:1)} to create a new query\n * instance that also contains this `QueryOrderByConstraint`.\n *\n * Note: Documents that do not contain the orderBy field will not be present in\n * the query result.\n */\nexport class QueryOrderByConstraint extends QueryConstraint {\n  /** The type of this query constraint */\n  readonly type = 'orderBy';\n\n  /**\n   * @internal\n   */\n  protected constructor(\n    private readonly _field: InternalFieldPath,\n    private _direction: Direction\n  ) {\n    super();\n  }\n\n  static _create(\n    _field: InternalFieldPath,\n    _direction: Direction\n  ): QueryOrderByConstraint {\n    return new QueryOrderByConstraint(_field, _direction);\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    const orderBy = newQueryOrderBy(query._query, this._field, this._direction);\n    return new Query(\n      query.firestore,\n      query.converter,\n      queryWithAddedOrderBy(query._query, orderBy)\n    );\n  }\n}\n\n/**\n * The direction of a {@link orderBy} clause is specified as 'desc' or 'asc'\n * (descending or ascending).\n */\nexport type OrderByDirection = 'desc' | 'asc';\n\n/**\n * Creates a {@link QueryOrderByConstraint} that sorts the query result by the\n * specified field, optionally in descending order instead of ascending.\n *\n * Note: Documents that do not contain the specified field will not be present\n * in the query result.\n *\n * @param fieldPath - The field to sort by.\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\n * not specified, order will be ascending.\n * @returns The created {@link QueryOrderByConstraint}.\n */\nexport function orderBy(\n  fieldPath: string | FieldPath,\n  directionStr: OrderByDirection = 'asc'\n): QueryOrderByConstraint {\n  const direction = directionStr as Direction;\n  const path = fieldPathFromArgument('orderBy', fieldPath);\n  return QueryOrderByConstraint._create(path, direction);\n}\n\n/**\n * A `QueryLimitConstraint` is used to limit the number of documents returned by\n * a Firestore query.\n * `QueryLimitConstraint`s are created by invoking {@link limit} or\n * {@link limitToLast} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryLimitConstraint`.\n */\nexport class QueryLimitConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  protected constructor(\n    /** The type of this query constraint */\n    readonly type: 'limit' | 'limitToLast',\n    private readonly _limit: number,\n    private readonly _limitType: LimitType\n  ) {\n    super();\n  }\n\n  static _create(\n    type: 'limit' | 'limitToLast',\n    _limit: number,\n    _limitType: LimitType\n  ): QueryLimitConstraint {\n    return new QueryLimitConstraint(type, _limit, _limitType);\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    return new Query(\n      query.firestore,\n      query.converter,\n      queryWithLimit(query._query, this._limit, this._limitType)\n    );\n  }\n}\n\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the first matching\n * documents.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nexport function limit(limit: number): QueryLimitConstraint {\n  validatePositiveNumber('limit', limit);\n  return QueryLimitConstraint._create('limit', limit, LimitType.First);\n}\n\n/**\n * Creates a {@link QueryLimitConstraint} that only returns the last matching\n * documents.\n *\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\n * otherwise an exception will be thrown during execution.\n *\n * @param limit - The maximum number of items to return.\n * @returns The created {@link QueryLimitConstraint}.\n */\nexport function limitToLast(limit: number): QueryLimitConstraint {\n  validatePositiveNumber('limitToLast', limit);\n  return QueryLimitConstraint._create('limitToLast', limit, LimitType.Last);\n}\n\n/**\n * A `QueryStartAtConstraint` is used to exclude documents from the start of a\n * result set returned by a Firestore query.\n * `QueryStartAtConstraint`s are created by invoking {@link (startAt:1)} or\n * {@link (startAfter:1)} and can then be passed to {@link (query:1)} to create a\n * new query instance that also contains this `QueryStartAtConstraint`.\n */\nexport class QueryStartAtConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  protected constructor(\n    /** The type of this query constraint */\n    readonly type: 'startAt' | 'startAfter',\n    private readonly _docOrFields: Array<unknown | DocumentSnapshot<unknown>>,\n    private readonly _inclusive: boolean\n  ) {\n    super();\n  }\n\n  static _create(\n    type: 'startAt' | 'startAfter',\n    _docOrFields: Array<unknown | DocumentSnapshot<unknown>>,\n    _inclusive: boolean\n  ): QueryStartAtConstraint {\n    return new QueryStartAtConstraint(type, _docOrFields, _inclusive);\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    const bound = newQueryBoundFromDocOrFields(\n      query,\n      this.type,\n      this._docOrFields,\n      this._inclusive\n    );\n    return new Query<AppModelType, DbModelType>(\n      query.firestore,\n      query.converter,\n      queryWithStartAt(query._query, bound)\n    );\n  }\n}\n\n/**\n * Creates a {@link QueryStartAtConstraint} that modifies the result set to\n * start at the provided document (inclusive). The starting position is relative\n * to the order of the query. The document must contain all of the fields\n * provided in the `orderBy` of this query.\n *\n * @param snapshot - The snapshot of the document to start at.\n * @returns A {@link QueryStartAtConstraint} to pass to `query()`.\n */\nexport function startAt<AppModelType, DbModelType extends DocumentData>(\n  snapshot: DocumentSnapshot<AppModelType, DbModelType>\n): QueryStartAtConstraint;\n/**\n * Creates a {@link QueryStartAtConstraint} that modifies the result set to\n * start at the provided fields relative to the order of the query. The order of\n * the field values must match the order of the order by clauses of the query.\n *\n * @param fieldValues - The field values to start this query at, in order\n * of the query's order by.\n * @returns A {@link QueryStartAtConstraint} to pass to `query()`.\n */\nexport function startAt(...fieldValues: unknown[]): QueryStartAtConstraint;\nexport function startAt<AppModelType, DbModelType extends DocumentData>(\n  ...docOrFields: Array<unknown | DocumentSnapshot<AppModelType, DbModelType>>\n): QueryStartAtConstraint {\n  return QueryStartAtConstraint._create(\n    'startAt',\n    docOrFields,\n    /*inclusive=*/ true\n  );\n}\n\n/**\n * Creates a {@link QueryStartAtConstraint} that modifies the result set to\n * start after the provided document (exclusive). The starting position is\n * relative to the order of the query. The document must contain all of the\n * fields provided in the orderBy of the query.\n *\n * @param snapshot - The snapshot of the document to start after.\n * @returns A {@link QueryStartAtConstraint} to pass to `query()`\n */\nexport function startAfter<AppModelType, DbModelType extends DocumentData>(\n  snapshot: DocumentSnapshot<AppModelType, DbModelType>\n): QueryStartAtConstraint;\n/**\n * Creates a {@link QueryStartAtConstraint} that modifies the result set to\n * start after the provided fields relative to the order of the query. The order\n * of the field values must match the order of the order by clauses of the query.\n *\n * @param fieldValues - The field values to start this query after, in order\n * of the query's order by.\n * @returns A {@link QueryStartAtConstraint} to pass to `query()`\n */\nexport function startAfter(...fieldValues: unknown[]): QueryStartAtConstraint;\nexport function startAfter<AppModelType, DbModelType extends DocumentData>(\n  ...docOrFields: Array<unknown | DocumentSnapshot<AppModelType, DbModelType>>\n): QueryStartAtConstraint {\n  return QueryStartAtConstraint._create(\n    'startAfter',\n    docOrFields,\n    /*inclusive=*/ false\n  );\n}\n\n/**\n * A `QueryEndAtConstraint` is used to exclude documents from the end of a\n * result set returned by a Firestore query.\n * `QueryEndAtConstraint`s are created by invoking {@link (endAt:1)} or\n * {@link (endBefore:1)} and can then be passed to {@link (query:1)} to create a new\n * query instance that also contains this `QueryEndAtConstraint`.\n */\nexport class QueryEndAtConstraint extends QueryConstraint {\n  /**\n   * @internal\n   */\n  protected constructor(\n    /** The type of this query constraint */\n    readonly type: 'endBefore' | 'endAt',\n    private readonly _docOrFields: Array<unknown | DocumentSnapshot<unknown>>,\n    private readonly _inclusive: boolean\n  ) {\n    super();\n  }\n\n  static _create(\n    type: 'endBefore' | 'endAt',\n    _docOrFields: Array<unknown | DocumentSnapshot<unknown>>,\n    _inclusive: boolean\n  ): QueryEndAtConstraint {\n    return new QueryEndAtConstraint(type, _docOrFields, _inclusive);\n  }\n\n  _apply<AppModelType, DbModelType extends DocumentData>(\n    query: Query<AppModelType, DbModelType>\n  ): Query<AppModelType, DbModelType> {\n    const bound = newQueryBoundFromDocOrFields(\n      query,\n      this.type,\n      this._docOrFields,\n      this._inclusive\n    );\n    return new Query(\n      query.firestore,\n      query.converter,\n      queryWithEndAt(query._query, bound)\n    );\n  }\n}\n\n/**\n * Creates a {@link QueryEndAtConstraint} that modifies the result set to end\n * before the provided document (exclusive). The end position is relative to the\n * order of the query. The document must contain all of the fields provided in\n * the orderBy of the query.\n *\n * @param snapshot - The snapshot of the document to end before.\n * @returns A {@link QueryEndAtConstraint} to pass to `query()`\n */\nexport function endBefore<AppModelType, DbModelType extends DocumentData>(\n  snapshot: DocumentSnapshot<AppModelType, DbModelType>\n): QueryEndAtConstraint;\n/**\n * Creates a {@link QueryEndAtConstraint} that modifies the result set to end\n * before the provided fields relative to the order of the query. The order of\n * the field values must match the order of the order by clauses of the query.\n *\n * @param fieldValues - The field values to end this query before, in order\n * of the query's order by.\n * @returns A {@link QueryEndAtConstraint} to pass to `query()`\n */\nexport function endBefore(...fieldValues: unknown[]): QueryEndAtConstraint;\nexport function endBefore<AppModelType, DbModelType extends DocumentData>(\n  ...docOrFields: Array<unknown | DocumentSnapshot<AppModelType, DbModelType>>\n): QueryEndAtConstraint {\n  return QueryEndAtConstraint._create(\n    'endBefore',\n    docOrFields,\n    /*inclusive=*/ false\n  );\n}\n\n/**\n * Creates a {@link QueryEndAtConstraint} that modifies the result set to end at\n * the provided document (inclusive). The end position is relative to the order\n * of the query. The document must contain all of the fields provided in the\n * orderBy of the query.\n *\n * @param snapshot - The snapshot of the document to end at.\n * @returns A {@link QueryEndAtConstraint} to pass to `query()`\n */\nexport function endAt<AppModelType, DbModelType extends DocumentData>(\n  snapshot: DocumentSnapshot<AppModelType, DbModelType>\n): QueryEndAtConstraint;\n/**\n * Creates a {@link QueryEndAtConstraint} that modifies the result set to end at\n * the provided fields relative to the order of the query. The order of the field\n * values must match the order of the order by clauses of the query.\n *\n * @param fieldValues - The field values to end this query at, in order\n * of the query's order by.\n * @returns A {@link QueryEndAtConstraint} to pass to `query()`\n */\nexport function endAt(...fieldValues: unknown[]): QueryEndAtConstraint;\nexport function endAt<AppModelType, DbModelType extends DocumentData>(\n  ...docOrFields: Array<unknown | DocumentSnapshot<AppModelType, DbModelType>>\n): QueryEndAtConstraint {\n  return QueryEndAtConstraint._create(\n    'endAt',\n    docOrFields,\n    /*inclusive=*/ true\n  );\n}\n\n/** Helper function to create a bound from a document or fields */\nfunction newQueryBoundFromDocOrFields<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>,\n  methodName: string,\n  docOrFields: Array<unknown | DocumentSnapshot<AppModelType, DbModelType>>,\n  inclusive: boolean\n): Bound {\n  docOrFields[0] = getModularInstance(docOrFields[0]);\n\n  if (docOrFields[0] instanceof DocumentSnapshot) {\n    return newQueryBoundFromDocument(\n      query._query,\n      query.firestore._databaseId,\n      methodName,\n      docOrFields[0]._document,\n      inclusive\n    );\n  } else {\n    const reader = newUserDataReader(query.firestore);\n    return newQueryBoundFromFields(\n      query._query,\n      query.firestore._databaseId,\n      reader,\n      methodName,\n      docOrFields,\n      inclusive\n    );\n  }\n}\n\nexport function newQueryFilter(\n  query: InternalQuery,\n  methodName: string,\n  dataReader: UserDataReader,\n  databaseId: DatabaseId,\n  fieldPath: InternalFieldPath,\n  op: Operator,\n  value: unknown\n): FieldFilter {\n  let fieldValue: ProtoValue;\n  if (fieldPath.isKeyField()) {\n    if (op === Operator.ARRAY_CONTAINS || op === Operator.ARRAY_CONTAINS_ANY) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid Query. You can't perform '${op}' queries on documentId().`\n      );\n    } else if (op === Operator.IN || op === Operator.NOT_IN) {\n      validateDisjunctiveFilterElements(value, op);\n      const referenceList: ProtoValue[] = [];\n      for (const arrayValue of value as ProtoValue[]) {\n        referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));\n      }\n      fieldValue = { arrayValue: { values: referenceList } };\n    } else {\n      fieldValue = parseDocumentIdValue(databaseId, query, value);\n    }\n  } else {\n    if (\n      op === Operator.IN ||\n      op === Operator.NOT_IN ||\n      op === Operator.ARRAY_CONTAINS_ANY\n    ) {\n      validateDisjunctiveFilterElements(value, op);\n    }\n    fieldValue = parseQueryValue(\n      dataReader,\n      methodName,\n      value,\n      /* allowArrays= */ op === Operator.IN || op === Operator.NOT_IN\n    );\n  }\n  const filter = FieldFilter.create(fieldPath, op, fieldValue);\n  return filter;\n}\n\nexport function newQueryOrderBy(\n  query: InternalQuery,\n  fieldPath: InternalFieldPath,\n  direction: Direction\n): OrderBy {\n  if (query.startAt !== null) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Invalid query. You must not call startAt() or startAfter() before ' +\n        'calling orderBy().'\n    );\n  }\n  if (query.endAt !== null) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Invalid query. You must not call endAt() or endBefore() before ' +\n        'calling orderBy().'\n    );\n  }\n  const orderBy = new OrderBy(fieldPath, direction);\n  return orderBy;\n}\n\n/**\n * Create a `Bound` from a query and a document.\n *\n * Note that the `Bound` will always include the key of the document\n * and so only the provided document will compare equal to the returned\n * position.\n *\n * Will throw if the document does not contain all fields of the order by\n * of the query or if any of the fields in the order by are an uncommitted\n * server timestamp.\n */\nexport function newQueryBoundFromDocument(\n  query: InternalQuery,\n  databaseId: DatabaseId,\n  methodName: string,\n  doc: Document | null,\n  inclusive: boolean\n): Bound {\n  if (!doc) {\n    throw new FirestoreError(\n      Code.NOT_FOUND,\n      `Can't use a DocumentSnapshot that doesn't exist for ` +\n        `${methodName}().`\n    );\n  }\n\n  const components: ProtoValue[] = [];\n\n  // Because people expect to continue/end a query at the exact document\n  // provided, we need to use the implicit sort order rather than the explicit\n  // sort order, because it's guaranteed to contain the document key. That way\n  // the position becomes unambiguous and the query continues/ends exactly at\n  // the provided document. Without the key (by using the explicit sort\n  // orders), multiple documents could match the position, yielding duplicate\n  // results.\n  for (const orderBy of queryNormalizedOrderBy(query)) {\n    if (orderBy.field.isKeyField()) {\n      components.push(refValue(databaseId, doc.key));\n    } else {\n      const value = doc.data.field(orderBy.field);\n      if (isServerTimestamp(value)) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Invalid query. You are trying to start or end a query using a ' +\n            'document for which the field \"' +\n            orderBy.field +\n            '\" is an uncommitted server timestamp. (Since the value of ' +\n            'this field is unknown, you cannot start/end a query with it.)'\n        );\n      } else if (value !== null) {\n        components.push(value);\n      } else {\n        const field = orderBy.field.canonicalString();\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid query. You are trying to start or end a query using a ` +\n            `document for which the field '${field}' (used as the ` +\n            `orderBy) does not exist.`\n        );\n      }\n    }\n  }\n  return new Bound(components, inclusive);\n}\n\n/**\n * Converts a list of field values to a `Bound` for the given query.\n */\nexport function newQueryBoundFromFields(\n  query: InternalQuery,\n  databaseId: DatabaseId,\n  dataReader: UserDataReader,\n  methodName: string,\n  values: unknown[],\n  inclusive: boolean\n): Bound {\n  // Use explicit order by's because it has to match the query the user made\n  const orderBy = query.explicitOrderBy;\n  if (values.length > orderBy.length) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Too many arguments provided to ${methodName}(). ` +\n        `The number of arguments must be less than or equal to the ` +\n        `number of orderBy() clauses`\n    );\n  }\n\n  const components: ProtoValue[] = [];\n  for (let i = 0; i < values.length; i++) {\n    const rawValue = values[i];\n    const orderByComponent = orderBy[i];\n    if (orderByComponent.field.isKeyField()) {\n      if (typeof rawValue !== 'string') {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid query. Expected a string for document ID in ` +\n            `${methodName}(), but got a ${typeof rawValue}`\n        );\n      }\n      if (!isCollectionGroupQuery(query) && rawValue.indexOf('/') !== -1) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid query. When querying a collection and ordering by documentId(), ` +\n            `the value passed to ${methodName}() must be a plain document ID, but ` +\n            `'${rawValue}' contains a slash.`\n        );\n      }\n      const path = query.path.child(ResourcePath.fromString(rawValue));\n      if (!DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid query. When querying a collection group and ordering by ` +\n            `documentId(), the value passed to ${methodName}() must result in a ` +\n            `valid document path, but '${path}' is not because it contains an odd number ` +\n            `of segments.`\n        );\n      }\n      const key = new DocumentKey(path);\n      components.push(refValue(databaseId, key));\n    } else {\n      const wrapped = parseQueryValue(dataReader, methodName, rawValue);\n      components.push(wrapped);\n    }\n  }\n\n  return new Bound(components, inclusive);\n}\n\n/**\n * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\n * appropriate errors if the value is anything other than a `DocumentReference`\n * or `string`, or if the string is malformed.\n */\nfunction parseDocumentIdValue(\n  databaseId: DatabaseId,\n  query: InternalQuery,\n  documentIdValue: unknown\n): ProtoValue {\n  documentIdValue = getModularInstance(documentIdValue);\n\n  if (typeof documentIdValue === 'string') {\n    if (documentIdValue === '') {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. When querying with documentId(), you ' +\n          'must provide a valid document ID, but it was an empty string.'\n      );\n    }\n    if (!isCollectionGroupQuery(query) && documentIdValue.indexOf('/') !== -1) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid query. When querying a collection by ` +\n          `documentId(), you must provide a plain document ID, but ` +\n          `'${documentIdValue}' contains a '/' character.`\n      );\n    }\n    const path = query.path.child(ResourcePath.fromString(documentIdValue));\n    if (!DocumentKey.isDocumentKey(path)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid query. When querying a collection group by ` +\n          `documentId(), the value provided must result in a valid document path, ` +\n          `but '${path}' is not because it has an odd number of segments (${path.length}).`\n      );\n    }\n    return refValue(databaseId, new DocumentKey(path));\n  } else if (documentIdValue instanceof DocumentReference) {\n    return refValue(databaseId, documentIdValue._key);\n  } else {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Invalid query. When querying with documentId(), you must provide a valid ` +\n        `string or a DocumentReference, but it was: ` +\n        `${valueDescription(documentIdValue)}.`\n    );\n  }\n}\n\n/**\n * Validates that the value passed into a disjunctive filter satisfies all\n * array requirements.\n */\nfunction validateDisjunctiveFilterElements(\n  value: unknown,\n  operator: Operator\n): void {\n  if (!Array.isArray(value) || value.length === 0) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Invalid Query. A non-empty array is required for ' +\n        `'${operator.toString()}' filters.`\n    );\n  }\n}\n\n/**\n * Given an operator, returns the set of operators that cannot be used with it.\n *\n * This is not a comprehensive check, and this function should be removed in the\n * long term. Validations should occur in the Firestore backend.\n *\n * Operators in a query must adhere to the following set of rules:\n * 1. Only one inequality per query.\n * 2. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\n */\nfunction conflictingOps(op: Operator): Operator[] {\n  switch (op) {\n    case Operator.NOT_EQUAL:\n      return [Operator.NOT_EQUAL, Operator.NOT_IN];\n    case Operator.ARRAY_CONTAINS_ANY:\n    case Operator.IN:\n      return [Operator.NOT_IN];\n    case Operator.NOT_IN:\n      return [\n        Operator.ARRAY_CONTAINS_ANY,\n        Operator.IN,\n        Operator.NOT_IN,\n        Operator.NOT_EQUAL\n      ];\n    default:\n      return [];\n  }\n}\n\nfunction validateNewFieldFilter(\n  query: InternalQuery,\n  fieldFilter: FieldFilter\n): void {\n  const conflictingOp = findOpInsideFilters(\n    query.filters,\n    conflictingOps(fieldFilter.op)\n  );\n  if (conflictingOp !== null) {\n    // Special case when it's a duplicate op to give a slightly clearer error message.\n    if (conflictingOp === fieldFilter.op) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You cannot use more than one ' +\n          `'${fieldFilter.op.toString()}' filter.`\n      );\n    } else {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid query. You cannot use '${fieldFilter.op.toString()}' filters ` +\n          `with '${conflictingOp.toString()}' filters.`\n      );\n    }\n  }\n}\n\nfunction validateNewFilter(query: InternalQuery, filter: Filter): void {\n  let testQuery = query;\n  const subFilters = filter.getFlattenedFilters();\n  for (const subFilter of subFilters) {\n    validateNewFieldFilter(testQuery, subFilter);\n    testQuery = queryWithAddedFilter(testQuery, subFilter);\n  }\n}\n\n// Checks if any of the provided filter operators are included in the given list of filters and\n// returns the first one that is, or null if none are.\nfunction findOpInsideFilters(\n  filters: Filter[],\n  operators: Operator[]\n): Operator | null {\n  for (const filter of filters) {\n    for (const fieldFilter of filter.getFlattenedFilters()) {\n      if (operators.indexOf(fieldFilter.op) >= 0) {\n        return fieldFilter.op;\n      }\n    }\n  }\n  return null;\n}\n\nexport function validateQueryFilterConstraint(\n  functionName: string,\n  queryConstraint: AppliableConstraint\n): void {\n  if (\n    !(queryConstraint instanceof QueryFieldFilterConstraint) &&\n    !(queryConstraint instanceof QueryCompositeFilterConstraint)\n  ) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`\n    );\n  }\n}\n\nfunction validateQueryConstraintArray(\n  queryConstraint: AppliableConstraint[]\n): void {\n  const compositeFilterCount = queryConstraint.filter(\n    filter => filter instanceof QueryCompositeFilterConstraint\n  ).length;\n  const fieldFilterCount = queryConstraint.filter(\n    filter => filter instanceof QueryFieldFilterConstraint\n  ).length;\n\n  if (\n    compositeFilterCount > 1 ||\n    (compositeFilterCount > 0 && fieldFilterCount > 0)\n  ) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'InvalidQuery. When using composite filters, you cannot use ' +\n        'more than one filter at the top level. Consider nesting the multiple ' +\n        'filters within an `and(...)` statement. For example: ' +\n        'change `query(query, where(...), or(...))` to ' +\n        '`query(query, and(where(...), or(...)))`.'\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DocumentData as PublicDocumentData,\n  SetOptions as PublicSetOptions\n} from '@firebase/firestore-types';\nimport { getModularInstance } from '@firebase/util';\n\nimport { LimitType } from '../core/query';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport {\n  invokeBatchGetDocumentsRpc,\n  invokeCommitRpc,\n  invokeRunQueryRpc\n} from '../remote/datastore';\nimport { hardAssert } from '../util/assert';\nimport { ByteString } from '../util/byte_string';\nimport { cast } from '../util/input_validation';\n\nimport { Bytes } from './bytes';\nimport { getDatastore } from './components';\nimport { Firestore } from './database';\nimport { FieldPath } from './field_path';\nimport { validateHasExplicitOrderByForLimitToLast } from './query';\nimport {\n  CollectionReference,\n  doc,\n  DocumentData,\n  DocumentReference,\n  PartialWithFieldValue,\n  Query,\n  SetOptions,\n  UpdateData,\n  WithFieldValue\n} from './reference';\nimport {\n  DocumentSnapshot,\n  QueryDocumentSnapshot,\n  QuerySnapshot\n} from './snapshot';\nimport {\n  newUserDataReader,\n  ParsedUpdateData,\n  parseSetData,\n  parseUpdateData,\n  parseUpdateVarargs,\n  UntypedFirestoreDataConverter\n} from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * Converts custom model object of type T into `DocumentData` by applying the\n * converter if it exists.\n *\n * This function is used when converting user objects to `DocumentData`\n * because we want to provide the user with a more specific error message if\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\n * call.\n */\nexport function applyFirestoreDataConverter<T>(\n  converter: UntypedFirestoreDataConverter<T> | null,\n  value: WithFieldValue<T> | PartialWithFieldValue<T>,\n  options?: PublicSetOptions\n): PublicDocumentData {\n  let convertedValue;\n  if (converter) {\n    if (options && (options.merge || options.mergeFields)) {\n      // Cast to `any` in order to satisfy the union type constraint on\n      // toFirestore().\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      convertedValue = (converter as any).toFirestore(value, options);\n    } else {\n      convertedValue = converter.toFirestore(value as WithFieldValue<T>);\n    }\n  } else {\n    convertedValue = value as PublicDocumentData;\n  }\n  return convertedValue;\n}\n\nexport class LiteUserDataWriter extends AbstractUserDataWriter {\n  constructor(protected firestore: Firestore) {\n    super();\n  }\n\n  protected convertBytes(bytes: ByteString): Bytes {\n    return new Bytes(bytes);\n  }\n\n  protected convertReference(name: string): DocumentReference {\n    const key = this.convertDocumentKey(name, this.firestore._databaseId);\n    return new DocumentReference(this.firestore, /* converter= */ null, key);\n  }\n}\n\n/**\n * Reads the document referred to by the specified document reference.\n *\n * All documents are directly fetched from the server, even if the document was\n * previously read or modified. Recent modifications are only reflected in the\n * retrieved `DocumentSnapshot` if they have already been applied by the\n * backend. If the client is offline, the read fails. If you like to use\n * caching or see local modifications, please use the full Firestore SDK.\n *\n * @param reference - The reference of the document to fetch.\n * @returns A Promise resolved with a `DocumentSnapshot` containing the current\n * document contents.\n */\nexport function getDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const datastore = getDatastore(reference.firestore);\n  const userDataWriter = new LiteUserDataWriter(reference.firestore);\n\n  return invokeBatchGetDocumentsRpc(datastore, [reference._key]).then(\n    result => {\n      hardAssert(\n        result.length === 1,\n        0x3d02,\n        'Expected a single document result'\n      );\n      const document = result[0];\n      return new DocumentSnapshot<AppModelType, DbModelType>(\n        reference.firestore,\n        userDataWriter,\n        reference._key,\n        document.isFoundDocument() ? document : null,\n        reference.converter\n      );\n    }\n  );\n}\n\n/**\n * Executes the query and returns the results as a {@link QuerySnapshot}.\n *\n * All queries are executed directly by the server, even if the query was\n * previously executed. Recent modifications are only reflected in the retrieved\n * results if they have already been applied by the backend. If the client is\n * offline, the operation fails. To see previously cached result and local\n * modifications, use the full Firestore SDK.\n *\n * @param query - The `Query` to execute.\n * @returns A Promise that will be resolved with the results of the query.\n */\nexport function getDocs<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>\n): Promise<QuerySnapshot<AppModelType, DbModelType>> {\n  query = cast<Query<AppModelType, DbModelType>>(query, Query);\n  validateHasExplicitOrderByForLimitToLast(query._query);\n\n  const datastore = getDatastore(query.firestore);\n  const userDataWriter = new LiteUserDataWriter(query.firestore);\n  return invokeRunQueryRpc(datastore, query._query).then(result => {\n    const docs = result.map(\n      doc =>\n        new QueryDocumentSnapshot<AppModelType, DbModelType>(\n          query.firestore,\n          userDataWriter,\n          doc.key,\n          doc,\n          query.converter\n        )\n    );\n\n    if (query._query.limitType === LimitType.Last) {\n      // Limit to last queries reverse the orderBy constraint that was\n      // specified by the user. As such, we need to reverse the order of the\n      // results to return the documents in the expected order.\n      docs.reverse();\n    }\n\n    return new QuerySnapshot<AppModelType, DbModelType>(query, docs);\n  });\n}\n\n/**\n * Writes to the document referred to by the specified `DocumentReference`. If\n * the document does not yet exist, it will be created.\n *\n * The result of this write will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * write fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to write.\n * @param data - A map of the fields and values for the document.\n * @throws Error - If the provided input is not a valid Firestore document.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend.\n */\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: WithFieldValue<AppModelType>\n): Promise<void>;\n/**\n * Writes to the document referred to by the specified `DocumentReference`. If\n * the document does not yet exist, it will be created. If you provide `merge`\n * or `mergeFields`, the provided data can be merged into an existing document.\n *\n * The result of this write will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * write fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to write.\n * @param data - A map of the fields and values for the document.\n * @param options - An object to configure the set behavior.\n * @throws Error - If the provided input is not a valid Firestore document.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend.\n */\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: PartialWithFieldValue<AppModelType>,\n  options: SetOptions\n): Promise<void>;\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: PartialWithFieldValue<AppModelType>,\n  options?: SetOptions\n): Promise<void> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const convertedValue = applyFirestoreDataConverter(\n    reference.converter,\n    data,\n    options\n  );\n  const dataReader = newUserDataReader(reference.firestore);\n  const parsed = parseSetData(\n    dataReader,\n    'setDoc',\n    reference._key,\n    convertedValue,\n    reference.converter !== null,\n    options\n  );\n\n  const datastore = getDatastore(reference.firestore);\n  return invokeCommitRpc(datastore, [\n    parsed.toMutation(reference._key, Precondition.none())\n  ]);\n}\n\n/**\n * Updates fields in the document referred to by the specified\n * `DocumentReference`. The update will fail if applied to a document that does\n * not exist.\n *\n * The result of this update will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * update fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to update.\n * @param data - An object containing the fields and values with which to\n * update the document. Fields can contain dots to reference nested fields\n * within the document.\n * @throws Error - If the provided input is not valid Firestore data.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend.\n */\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: UpdateData<DbModelType>\n): Promise<void>;\n/**\n * Updates fields in the document referred to by the specified\n * `DocumentReference` The update will fail if applied to a document that does\n * not exist.\n *\n * Nested fields can be updated by providing dot-separated field path\n * strings or by providing `FieldPath` objects.\n *\n * The result of this update will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * update fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to update.\n * @param field - The first field to update.\n * @param value - The first value.\n * @param moreFieldsAndValues - Additional key value pairs.\n * @throws Error - If the provided input is not valid Firestore data.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend.\n */\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  field: string | FieldPath,\n  value: unknown,\n  ...moreFieldsAndValues: unknown[]\n): Promise<void>;\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  fieldOrUpdateData: string | FieldPath | UpdateData<DbModelType>,\n  value?: unknown,\n  ...moreFieldsAndValues: unknown[]\n): Promise<void> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const dataReader = newUserDataReader(reference.firestore);\n\n  // For Compat types, we have to \"extract\" the underlying types before\n  // performing validation.\n  fieldOrUpdateData = getModularInstance(fieldOrUpdateData);\n\n  let parsed: ParsedUpdateData;\n  if (\n    typeof fieldOrUpdateData === 'string' ||\n    fieldOrUpdateData instanceof FieldPath\n  ) {\n    parsed = parseUpdateVarargs(\n      dataReader,\n      'updateDoc',\n      reference._key,\n      fieldOrUpdateData,\n      value,\n      moreFieldsAndValues\n    );\n  } else {\n    parsed = parseUpdateData(\n      dataReader,\n      'updateDoc',\n      reference._key,\n      fieldOrUpdateData\n    );\n  }\n\n  const datastore = getDatastore(reference.firestore);\n  return invokeCommitRpc(datastore, [\n    parsed.toMutation(reference._key, Precondition.exists(true))\n  ]);\n}\n\n/**\n * Deletes the document referred to by the specified `DocumentReference`.\n *\n * The deletion will only be reflected in document reads that occur after the\n * returned promise resolves. If the client is offline, the\n * delete fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the document to delete.\n * @returns A `Promise` resolved once the document has been successfully\n * deleted from the backend.\n */\nexport function deleteDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<void> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const datastore = getDatastore(reference.firestore);\n  return invokeCommitRpc(datastore, [\n    new DeleteMutation(reference._key, Precondition.none())\n  ]);\n}\n\n/**\n * Add a new document to specified `CollectionReference` with the given data,\n * assigning it a document ID automatically.\n *\n * The result of this write will only be reflected in document reads that occur\n * after the returned promise resolves. If the client is offline, the\n * write fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @param reference - A reference to the collection to add this document to.\n * @param data - An Object containing the data for the new document.\n * @throws Error - If the provided input is not a valid Firestore document.\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\n * newly created document after it has been written to the backend.\n */\nexport function addDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: CollectionReference<AppModelType, DbModelType>,\n  data: WithFieldValue<AppModelType>\n): Promise<DocumentReference<AppModelType, DbModelType>> {\n  reference = cast<CollectionReference<AppModelType, DbModelType>>(\n    reference,\n    CollectionReference\n  );\n  const docRef = doc(reference);\n\n  const convertedValue = applyFirestoreDataConverter(\n    reference.converter,\n    data as PartialWithFieldValue<AppModelType>\n  );\n\n  const dataReader = newUserDataReader(reference.firestore);\n  const parsed = parseSetData(\n    dataReader,\n    'addDoc',\n    docRef._key,\n    convertedValue,\n    docRef.converter !== null,\n    {}\n  );\n\n  const datastore = getDatastore(reference.firestore);\n  return invokeCommitRpc(datastore, [\n    parsed.toMutation(docRef._key, Precondition.exists(false))\n  ]).then(() => docRef);\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { deepEqual } from '@firebase/util';\n\nimport { AggregateImpl } from '../core/aggregate';\nimport { ApiClientObjectMap, Value } from '../protos/firestore_proto_api';\nimport { invokeRunAggregationQueryRpc } from '../remote/datastore';\nimport { cast } from '../util/input_validation';\nimport { mapToArray } from '../util/obj';\n\nimport {\n  AggregateField,\n  AggregateQuerySnapshot,\n  AggregateSpec\n} from './aggregate_types';\nimport { getDatastore } from './components';\nimport { Firestore } from './database';\nimport { FieldPath } from './field_path';\nimport { DocumentData, Query, queryEqual } from './reference';\nimport { LiteUserDataWriter } from './reference_impl';\nimport { fieldPathFromArgument } from './user_data_reader';\n\n/**\n * Calculates the number of documents in the result set of the given query\n * without actually downloading the documents.\n *\n * Using this function to count the documents is efficient because only the\n * final count, not the documents' data, is downloaded. This function can\n * count the documents in cases where the result set is prohibitively large to\n * download entirely (thousands of documents).\n *\n * @param query - The query whose result set size is calculated.\n * @returns A Promise that will be resolved with the count; the count can be\n * retrieved from `snapshot.data().count`, where `snapshot` is the\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\n */\nexport function getCount<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>\n): Promise<\n  AggregateQuerySnapshot<\n    { count: AggregateField<number> },\n    AppModelType,\n    DbModelType\n  >\n> {\n  const countQuerySpec: { count: AggregateField<number> } = {\n    count: count()\n  };\n\n  return getAggregate(query, countQuerySpec);\n}\n\n/**\n * Calculates the specified aggregations over the documents in the result\n * set of the given query without actually downloading the documents.\n *\n * Using this function to perform aggregations is efficient because only the\n * final aggregation values, not the documents' data, are downloaded. This\n * function can perform aggregations of the documents in cases where the result\n * set is prohibitively large to download entirely (thousands of documents).\n *\n * @param query - The query whose result set is aggregated over.\n * @param aggregateSpec - An `AggregateSpec` object that specifies the aggregates\n * to perform over the result set. The AggregateSpec specifies aliases for each\n * aggregate, which can be used to retrieve the aggregate result.\n * @example\n * ```typescript\n * const aggregateSnapshot = await getAggregate(query, {\n *   countOfDocs: count(),\n *   totalHours: sum('hours'),\n *   averageScore: average('score')\n * });\n *\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n * const totalHours: number = aggregateSnapshot.data().totalHours;\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n * ```\n */\nexport function getAggregate<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>,\n  aggregateSpec: AggregateSpecType\n): Promise<\n  AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>\n> {\n  const firestore = cast(query.firestore, Firestore);\n  const datastore = getDatastore(firestore);\n\n  const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n    return new AggregateImpl(\n      alias,\n      aggregate.aggregateType,\n      aggregate._internalFieldPath\n    );\n  });\n\n  // Run the aggregation and convert the results\n  return invokeRunAggregationQueryRpc(\n    datastore,\n    query._query,\n    internalAggregates\n  ).then(aggregateResult =>\n    convertToAggregateQuerySnapshot(firestore, query, aggregateResult)\n  );\n}\n\nfunction convertToAggregateQuerySnapshot<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  query: Query<AppModelType, DbModelType>,\n  aggregateResult: ApiClientObjectMap<Value>\n): AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType> {\n  const userDataWriter = new LiteUserDataWriter(firestore);\n  const querySnapshot = new AggregateQuerySnapshot<\n    AggregateSpecType,\n    AppModelType,\n    DbModelType\n  >(query, userDataWriter, aggregateResult);\n  return querySnapshot;\n}\n\n/**\n * Create an AggregateField object that can be used to compute the sum of\n * a specified field over a range of documents in the result set of a query.\n * @param field - Specifies the field to sum across the result set.\n */\nexport function sum(field: string | FieldPath): AggregateField<number> {\n  return new AggregateField('sum', fieldPathFromArgument('sum', field));\n}\n\n/**\n * Create an AggregateField object that can be used to compute the average of\n * a specified field over a range of documents in the result set of a query.\n * @param field - Specifies the field to average across the result set.\n */\nexport function average(\n  field: string | FieldPath\n): AggregateField<number | null> {\n  return new AggregateField('avg', fieldPathFromArgument('average', field));\n}\n\n/**\n * Create an AggregateField object that can be used to compute the count of\n * documents in the result set of a query.\n */\nexport function count(): AggregateField<number> {\n  return new AggregateField('count');\n}\n\n/**\n * Compares two 'AggregateField` instances for equality.\n *\n * @param left - Compare this AggregateField to the `right`.\n * @param right - Compare this AggregateField to the `left`.\n */\nexport function aggregateFieldEqual(\n  left: AggregateField<unknown>,\n  right: AggregateField<unknown>\n): boolean {\n  return (\n    left instanceof AggregateField &&\n    right instanceof AggregateField &&\n    left.aggregateType === right.aggregateType &&\n    left._internalFieldPath?.canonicalString() ===\n      right._internalFieldPath?.canonicalString()\n  );\n}\n\n/**\n * Compares two `AggregateQuerySnapshot` instances for equality.\n *\n * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they have\n * underlying queries that compare equal, and the same data.\n *\n * @param left - The first `AggregateQuerySnapshot` to compare.\n * @param right - The second `AggregateQuerySnapshot` to compare.\n *\n * @returns `true` if the objects are \"equal\", as defined above, or `false`\n * otherwise.\n */\nexport function aggregateQuerySnapshotEqual<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  left: AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>,\n  right: AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>\n): boolean {\n  return (\n    queryEqual(left.query, right.query) && deepEqual(left.data(), right.data())\n  );\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AggregateImpl } from '../core/aggregate';\nimport { firestoreClientRunAggregateQuery } from '../core/firestore_client';\nimport { count } from '../lite-api/aggregate';\nimport {\n  AggregateField,\n  AggregateQuerySnapshot,\n  AggregateSpec\n} from '../lite-api/aggregate_types';\nimport { DocumentData, Query } from '../lite-api/reference';\nimport { ApiClientObjectMap, Value } from '../protos/firestore_proto_api';\nimport { cast } from '../util/input_validation';\nimport { mapToArray } from '../util/obj';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport { ExpUserDataWriter } from './user_data_writer';\n\nexport {\n  aggregateQuerySnapshotEqual,\n  count,\n  sum,\n  average,\n  aggregateFieldEqual\n} from '../lite-api/aggregate';\n\n/**\n * Calculates the number of documents in the result set of the given query\n * without actually downloading the documents.\n *\n * Using this function to count the documents is efficient because only the\n * final count, not the documents' data, is downloaded. This function can\n * count the documents in cases where the result set is prohibitively large to\n * download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query - The query whose result set size is calculated.\n * @returns A Promise that will be resolved with the count; the count can be\n * retrieved from `snapshot.data().count`, where `snapshot` is the\n * `AggregateQuerySnapshot` to which the returned Promise resolves.\n */\nexport function getCountFromServer<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>\n): Promise<\n  AggregateQuerySnapshot<\n    { count: AggregateField<number> },\n    AppModelType,\n    DbModelType\n  >\n> {\n  const countQuerySpec: { count: AggregateField<number> } = {\n    count: count()\n  };\n\n  return getAggregateFromServer(query, countQuerySpec);\n}\n\n/**\n * Calculates the specified aggregations over the documents in the result\n * set of the given query without actually downloading the documents.\n *\n * Using this function to perform aggregations is efficient because only the\n * final aggregation values, not the documents' data, are downloaded. This\n * function can perform aggregations of the documents in cases where the result\n * set is prohibitively large to download entirely (thousands of documents).\n *\n * The result received from the server is presented, unaltered, without\n * considering any local state. That is, documents in the local cache are not\n * taken into consideration, neither are local modifications not yet\n * synchronized with the server. Previously-downloaded results, if any, are not\n * used. Every invocation of this function necessarily involves a round trip to\n * the server.\n *\n * @param query - The query whose result set is aggregated over.\n * @param aggregateSpec - An `AggregateSpec` object that specifies the aggregates\n * to perform over the result set. The AggregateSpec specifies aliases for each\n * aggregate, which can be used to retrieve the aggregate result.\n * @example\n * ```typescript\n * const aggregateSnapshot = await getAggregateFromServer(query, {\n *   countOfDocs: count(),\n *   totalHours: sum('hours'),\n *   averageScore: average('score')\n * });\n *\n * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n * const totalHours: number = aggregateSnapshot.data().totalHours;\n * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n * ```\n */\nexport function getAggregateFromServer<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>,\n  aggregateSpec: AggregateSpecType\n): Promise<\n  AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>\n> {\n  const firestore = cast(query.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n\n  const internalAggregates = mapToArray(aggregateSpec, (aggregate, alias) => {\n    return new AggregateImpl(\n      alias,\n      aggregate.aggregateType,\n      aggregate._internalFieldPath\n    );\n  });\n\n  // Run the aggregation and convert the results\n  return firestoreClientRunAggregateQuery(\n    client,\n    query._query,\n    internalAggregates\n  ).then(aggregateResult =>\n    convertToAggregateQuerySnapshot(firestore, query, aggregateResult)\n  );\n}\n\n/**\n * Converts the core aggregation result to an `AggregateQuerySnapshot`\n * that can be returned to the consumer.\n * @param query\n * @param aggregateResult - Core aggregation result\n * @internal\n */\nfunction convertToAggregateQuerySnapshot<\n  AggregateSpecType extends AggregateSpec,\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  query: Query<AppModelType, DbModelType>,\n  aggregateResult: ApiClientObjectMap<Value>\n): AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType> {\n  const userDataWriter = new ExpUserDataWriter(firestore);\n  const querySnapshot = new AggregateQuerySnapshot<\n    AggregateSpecType,\n    AppModelType,\n    DbModelType\n  >(query, userDataWriter, aggregateResult);\n  return querySnapshot;\n}\n","/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  IndexedDbOfflineComponentProvider,\n  LruGcMemoryOfflineComponentProvider,\n  MemoryOfflineComponentProvider,\n  MultiTabOfflineComponentProvider,\n  OfflineComponentProviderFactory,\n  OnlineComponentProviderFactory,\n  OnlineComponentProvider\n} from '../core/component_provider';\n\n/* eslint @typescript-eslint/consistent-type-definitions: [\"error\", \"type\"] */\n/**\n * Provides an in-memory cache to the SDK. This is the default cache unless explicitly\n * configured otherwise.\n *\n * To use, create an instance using the factory function {@link memoryLocalCache()}, then\n * set the instance to `FirestoreSettings.cache` and call `initializeFirestore` using\n * the settings object.\n */\nexport type MemoryLocalCache = {\n  kind: 'memory';\n  /**\n   * @internal\n   */\n  _onlineComponentProvider: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n};\n\nclass MemoryLocalCacheImpl implements MemoryLocalCache {\n  kind: 'memory' = 'memory';\n  /**\n   * @internal\n   */\n  _onlineComponentProvider: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n\n  constructor(settings?: MemoryCacheSettings) {\n    this._onlineComponentProvider = OnlineComponentProvider.provider;\n    if (settings?.garbageCollector) {\n      this._offlineComponentProvider =\n        settings.garbageCollector._offlineComponentProvider;\n    } else {\n      this._offlineComponentProvider = {\n        build: () => new LruGcMemoryOfflineComponentProvider(undefined)\n      };\n    }\n  }\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n}\n\n/**\n * Provides a persistent cache backed by IndexedDb to the SDK.\n *\n * To use, create an instance using the factory function {@link persistentLocalCache()}, then\n * set the instance to `FirestoreSettings.cache` and call `initializeFirestore` using\n * the settings object.\n */\nexport type PersistentLocalCache = {\n  kind: 'persistent';\n  /**\n   * @internal\n   */\n  _onlineComponentProvider: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n};\n\nclass PersistentLocalCacheImpl implements PersistentLocalCache {\n  kind: 'persistent' = 'persistent';\n  /**\n   * @internal\n   */\n  _onlineComponentProvider: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n\n  constructor(settings: PersistentCacheSettings | undefined) {\n    let tabManager: PersistentTabManager;\n    if (settings?.tabManager) {\n      settings.tabManager._initialize(settings);\n      tabManager = settings.tabManager;\n    } else {\n      tabManager = persistentSingleTabManager(undefined);\n      tabManager._initialize(settings);\n    }\n    this._onlineComponentProvider = tabManager._onlineComponentProvider!;\n    this._offlineComponentProvider = tabManager._offlineComponentProvider!;\n  }\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n}\n\n/**\n * Union type from all supported SDK cache layer.\n */\nexport type FirestoreLocalCache = MemoryLocalCache | PersistentLocalCache;\n\n/**\n * Union type from all support garbage collectors for memory local cache.\n */\nexport type MemoryGarbageCollector =\n  | MemoryEagerGarbageCollector\n  | MemoryLruGarbageCollector;\n\n/**\n * A garbage collector deletes documents whenever they are not part of any\n * active queries, and have no local mutations attached to them.\n *\n * This collector tries to ensure lowest memory footprints from the SDK,\n * at the risk of documents not being cached for offline queries or for\n * direct queries to the cache.\n *\n * Use factory function {@link memoryEagerGarbageCollector()} to create an\n * instance of this collector.\n */\nexport type MemoryEagerGarbageCollector = {\n  kind: 'memoryEager';\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n};\n\n/**\n * A garbage collector deletes Least-Recently-Used documents in multiple\n * batches.\n *\n * This collector is configured with a target size, and will only perform\n * collection when the cached documents exceed the target size. It avoids\n * querying backend repeated for the same query or document, at the risk\n * of having a larger memory footprint.\n *\n * Use factory function {@link memoryLruGarbageCollector()} to create a\n * instance of this collector.\n */\nexport type MemoryLruGarbageCollector = {\n  kind: 'memoryLru';\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n};\n\nclass MemoryEagerGarbageCollectorImpl implements MemoryEagerGarbageCollector {\n  kind: 'memoryEager' = 'memoryEager';\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n\n  constructor() {\n    this._offlineComponentProvider = MemoryOfflineComponentProvider.provider;\n  }\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n}\n\nclass MemoryLruGarbageCollectorImpl implements MemoryLruGarbageCollector {\n  kind: 'memoryLru' = 'memoryLru';\n  /**\n   * @internal\n   */\n  _offlineComponentProvider: OfflineComponentProviderFactory;\n\n  constructor(cacheSize?: number) {\n    this._offlineComponentProvider = {\n      build: () => new LruGcMemoryOfflineComponentProvider(cacheSize)\n    };\n  }\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n}\n\n/**\n * Creates an instance of `MemoryEagerGarbageCollector`. This is also the\n * default garbage collector unless it is explicitly specified otherwise.\n */\nexport function memoryEagerGarbageCollector(): MemoryEagerGarbageCollector {\n  return new MemoryEagerGarbageCollectorImpl();\n}\n\n/**\n * Creates an instance of `MemoryLruGarbageCollector`.\n *\n * A target size can be specified as part of the setting parameter. The\n * collector will start deleting documents once the cache size exceeds\n * the given size. The default cache size is 40MB (40 * 1024 * 1024 bytes).\n */\nexport function memoryLruGarbageCollector(settings?: {\n  cacheSizeBytes?: number;\n}): MemoryLruGarbageCollector {\n  return new MemoryLruGarbageCollectorImpl(settings?.cacheSizeBytes);\n}\n\n/**\n * An settings object to configure an `MemoryLocalCache` instance.\n */\nexport type MemoryCacheSettings = {\n  /**\n   * The garbage collector to use, for the memory cache layer.\n   * A `MemoryEagerGarbageCollector` is used when this is undefined.\n   */\n  garbageCollector?: MemoryGarbageCollector;\n};\n\n/**\n * Creates an instance of `MemoryLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n */\nexport function memoryLocalCache(\n  settings?: MemoryCacheSettings\n): MemoryLocalCache {\n  return new MemoryLocalCacheImpl(settings);\n}\n\n/**\n * An settings object to configure an `PersistentLocalCache` instance.\n *\n * Persistent cache cannot be used in a Node.js environment.\n */\nexport type PersistentCacheSettings = {\n  /**\n   * An approximate cache size threshold for the on-disk data. If the cache\n   * grows beyond this size, Firestore will start removing data that hasn't been\n   * recently used. The SDK does not guarantee that the cache will stay below\n   * that size, only that if the cache exceeds the given size, cleanup will be\n   * attempted.\n   *\n   * The default value is 40 MB. The threshold must be set to at least 1 MB, and\n   * can be set to `CACHE_SIZE_UNLIMITED` to disable garbage collection.\n   */\n  cacheSizeBytes?: number;\n\n  /**\n   * Specifies how multiple tabs/windows will be managed by the SDK.\n   */\n  tabManager?: PersistentTabManager;\n};\n\n/**\n * Creates an instance of `PersistentLocalCache`. The instance can be set to\n * `FirestoreSettings.cache` to tell the SDK which cache layer to use.\n *\n * Persistent cache cannot be used in a Node.js environment.\n */\nexport function persistentLocalCache(\n  settings?: PersistentCacheSettings\n): PersistentLocalCache {\n  return new PersistentLocalCacheImpl(settings);\n}\n\n/**\n * A tab manager supporting only one tab, no synchronization will be\n * performed across tabs.\n */\nexport type PersistentSingleTabManager = {\n  kind: 'persistentSingleTab';\n  /**\n   * @internal\n   */\n  _initialize: (\n    settings: Omit<PersistentCacheSettings, 'tabManager'> | undefined\n  ) => void;\n  /**\n   * @internal\n   */\n  _onlineComponentProvider?: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider?: OfflineComponentProviderFactory;\n};\n\nclass SingleTabManagerImpl implements PersistentSingleTabManager {\n  kind: 'persistentSingleTab' = 'persistentSingleTab';\n\n  /**\n   * @internal\n   */\n  _onlineComponentProvider?: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider?: OfflineComponentProviderFactory;\n\n  constructor(private forceOwnership?: boolean) {}\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n\n  /**\n   * @internal\n   */\n  _initialize(\n    settings: Omit<PersistentCacheSettings, 'tabManager'> | undefined\n  ): void {\n    this._onlineComponentProvider = OnlineComponentProvider.provider;\n    this._offlineComponentProvider = {\n      build: (onlineComponents: OnlineComponentProvider) =>\n        new IndexedDbOfflineComponentProvider(\n          onlineComponents,\n          settings?.cacheSizeBytes,\n          this.forceOwnership\n        )\n    };\n  }\n}\n\n/**\n * A tab manager supporting multiple tabs. SDK will synchronize queries and\n * mutations done across all tabs using the SDK.\n */\nexport type PersistentMultipleTabManager = {\n  kind: 'PersistentMultipleTab';\n  /**\n   * @internal\n   */\n  _initialize: (settings: Omit<PersistentCacheSettings, 'tabManager'>) => void;\n  /**\n   * @internal\n   */\n  _onlineComponentProvider?: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n\n  _offlineComponentProvider?: OfflineComponentProviderFactory;\n};\n\nclass MultiTabManagerImpl implements PersistentMultipleTabManager {\n  kind: 'PersistentMultipleTab' = 'PersistentMultipleTab';\n\n  /**\n   * @internal\n   */\n  _onlineComponentProvider?: OnlineComponentProviderFactory;\n  /**\n   * @internal\n   */\n  _offlineComponentProvider?: OfflineComponentProviderFactory;\n\n  toJSON(): {} {\n    return { kind: this.kind };\n  }\n\n  /**\n   * @internal\n   */\n  _initialize(\n    settings: Omit<PersistentCacheSettings, 'tabManager'> | undefined\n  ): void {\n    this._onlineComponentProvider = OnlineComponentProvider.provider;\n    this._offlineComponentProvider = {\n      build: (onlineComponents: OnlineComponentProvider) =>\n        new MultiTabOfflineComponentProvider(\n          onlineComponents,\n          settings?.cacheSizeBytes\n        )\n    };\n  }\n}\n\n/**\n * A union of all available tab managers.\n */\nexport type PersistentTabManager =\n  | PersistentSingleTabManager\n  | PersistentMultipleTabManager;\n\n/**\n * Type to configure an `PersistentSingleTabManager` instance.\n */\nexport type PersistentSingleTabManagerSettings = {\n  /**\n   * Whether to force-enable persistent (IndexedDB) cache for the client. This\n   * cannot be used with multi-tab synchronization and is primarily intended for\n   * use with Web Workers. Setting this to `true` will enable IndexedDB, but cause\n   * other tabs using IndexedDB cache to fail.\n   */\n  forceOwnership?: boolean;\n};\n/**\n * Creates an instance of `PersistentSingleTabManager`.\n *\n * @param settings - Configures the created tab manager.\n */\nexport function persistentSingleTabManager(\n  settings: PersistentSingleTabManagerSettings | undefined\n): PersistentSingleTabManager {\n  return new SingleTabManagerImpl(settings?.forceOwnership);\n}\n\n/**\n * Creates an instance of `PersistentMultipleTabManager`.\n */\nexport function persistentMultipleTabManager(): PersistentMultipleTabManager {\n  return new MultiTabManagerImpl();\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BundleLoader } from '../core/bundle_impl';\nimport { createBundleReaderSync } from '../core/firestore_client';\nimport { newQueryComparator } from '../core/query';\nimport { ChangeType, ViewSnapshot } from '../core/view_snapshot';\nimport { FieldPath } from '../lite-api/field_path';\nimport {\n  DocumentData,\n  PartialWithFieldValue,\n  Query,\n  queryEqual,\n  SetOptions,\n  WithFieldValue\n} from '../lite-api/reference';\nimport { LiteUserDataWriter } from '../lite-api/reference_impl';\nimport {\n  DocumentSnapshot as LiteDocumentSnapshot,\n  FirestoreDataConverter as LiteFirestoreDataConverter\n} from '../lite-api/snapshot';\nimport {\n  fieldPathFromArgument,\n  UntypedFirestoreDataConverter\n} from '../lite-api/user_data_reader';\nimport { AbstractUserDataWriter } from '../lite-api/user_data_writer';\nimport { fromBundledQuery } from '../local/local_serializer';\nimport { documentKeySet } from '../model/collections';\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DocumentSet } from '../model/document_set';\nimport { ResourcePath } from '../model/path';\nimport { newSerializer } from '../platform/serializer';\nimport {\n  buildQuerySnapshotJsonBundle,\n  buildDocumentSnapshotJsonBundle\n} from '../platform/snapshot_to_json';\nimport { fromDocument } from '../remote/serializer';\nimport { debugAssert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\n// API extractor fails importing 'property' unless we also explicitly import 'Property'.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, unused-imports/no-unused-imports-ts\nimport { Property, property, validateJSON } from '../util/json_validation';\nimport { AutoId } from '../util/misc';\n\nimport { Firestore } from './database';\nimport { SnapshotListenOptions } from './reference_impl';\n\nconst NOT_SUPPORTED = 'NOT SUPPORTED';\n\n/**\n * Converter used by `withConverter()` to transform user objects of type\n * `AppModelType` into Firestore data of type `DbModelType`.\n *\n * Using the converter allows you to specify generic type arguments when\n * storing and retrieving objects from Firestore.\n *\n * In this context, an \"AppModel\" is a class that is used in an application to\n * package together related information and functionality. Such a class could,\n * for example, have properties with complex, nested data types, properties used\n * for memoization, properties of types not supported by Firestore (such as\n * `symbol` and `bigint`), and helper functions that perform compound\n * operations. Such classes are not suitable and/or possible to store into a\n * Firestore database. Instead, instances of such classes need to be converted\n * to \"plain old JavaScript objects\" (POJOs) with exclusively primitive\n * properties, potentially nested inside other POJOs or arrays of POJOs. In this\n * context, this type is referred to as the \"DbModel\" and would be an object\n * suitable for persisting into Firestore. For convenience, applications can\n * implement `FirestoreDataConverter` and register the converter with Firestore\n * objects, such as `DocumentReference` or `Query`, to automatically convert\n * `AppModel` to `DbModel` when storing into Firestore, and convert `DbModel`\n * to `AppModel` when retrieving from Firestore.\n *\n * @example\n *\n * Simple Example\n *\n * ```typescript\n * const numberConverter = {\n *     toFirestore(value: WithFieldValue<number>) {\n *         return { value };\n *     },\n *     fromFirestore(snapshot: QueryDocumentSnapshot, options: SnapshotOptions) {\n *         return snapshot.data(options).value as number;\n *     }\n * };\n *\n * async function simpleDemo(db: Firestore): Promise<void> {\n *     const documentRef = doc(db, 'values/value123').withConverter(numberConverter);\n *\n *     // converters are used with `setDoc`, `addDoc`, and `getDoc`\n *     await setDoc(documentRef, 42);\n *     const snapshot1 = await getDoc(documentRef);\n *     assertEqual(snapshot1.data(), 42);\n *\n *     // converters are not used when writing data with `updateDoc`\n *     await updateDoc(documentRef, { value: 999 });\n *     const snapshot2 = await getDoc(documentRef);\n *     assertEqual(snapshot2.data(), 999);\n * }\n * ```\n *\n * Advanced Example\n *\n * ```typescript\n * // The Post class is a model that is used by our application.\n * // This class may have properties and methods that are specific\n * // to our application execution, which do not need to be persisted\n * // to Firestore.\n * class Post {\n *     constructor(\n *         readonly title: string,\n *         readonly author: string,\n *         readonly lastUpdatedMillis: number\n *     ) {}\n *     toString(): string {\n *         return `${this.title} by ${this.author}`;\n *     }\n * }\n *\n * // The PostDbModel represents how we want our posts to be stored\n * // in Firestore. This DbModel has different properties (`ttl`,\n * // `aut`, and `lut`) from the Post class we use in our application.\n * interface PostDbModel {\n *     ttl: string;\n *     aut: { firstName: string; lastName: string };\n *     lut: Timestamp;\n * }\n *\n * // The `PostConverter` implements `FirestoreDataConverter` and specifies\n * // how the Firestore SDK can convert `Post` objects to `PostDbModel`\n * // objects and vice versa.\n * class PostConverter implements FirestoreDataConverter<Post, PostDbModel> {\n *     toFirestore(post: WithFieldValue<Post>): WithFieldValue<PostDbModel> {\n *         return {\n *             ttl: post.title,\n *             aut: this._autFromAuthor(post.author),\n *             lut: this._lutFromLastUpdatedMillis(post.lastUpdatedMillis)\n *         };\n *     }\n *\n *     fromFirestore(snapshot: QueryDocumentSnapshot, options: SnapshotOptions): Post {\n *         const data = snapshot.data(options) as PostDbModel;\n *         const author = `${data.aut.firstName} ${data.aut.lastName}`;\n *         return new Post(data.ttl, author, data.lut.toMillis());\n *     }\n *\n *     _autFromAuthor(\n *         author: string | FieldValue\n *     ): { firstName: string; lastName: string } | FieldValue {\n *         if (typeof author !== 'string') {\n *             // `author` is a FieldValue, so just return it.\n *             return author;\n *         }\n *         const [firstName, lastName] = author.split(' ');\n *         return {firstName, lastName};\n *     }\n *\n *     _lutFromLastUpdatedMillis(\n *         lastUpdatedMillis: number | FieldValue\n *     ): Timestamp | FieldValue {\n *         if (typeof lastUpdatedMillis !== 'number') {\n *             // `lastUpdatedMillis` must be a FieldValue, so just return it.\n *             return lastUpdatedMillis;\n *         }\n *         return Timestamp.fromMillis(lastUpdatedMillis);\n *     }\n * }\n *\n * async function advancedDemo(db: Firestore): Promise<void> {\n *     // Create a `DocumentReference` with a `FirestoreDataConverter`.\n *     const documentRef = doc(db, 'posts/post123').withConverter(new PostConverter());\n *\n *     // The `data` argument specified to `setDoc()` is type checked by the\n *     // TypeScript compiler to be compatible with `Post`. Since the `data`\n *     // argument is typed as `WithFieldValue<Post>` rather than just `Post`,\n *     // this allows properties of the `data` argument to also be special\n *     // Firestore values that perform server-side mutations, such as\n *     // `arrayRemove()`, `deleteField()`, and `serverTimestamp()`.\n *     await setDoc(documentRef, {\n *         title: 'My Life',\n *         author: 'Foo Bar',\n *         lastUpdatedMillis: serverTimestamp()\n *     });\n *\n *     // The TypeScript compiler will fail to compile if the `data` argument to\n *     // `setDoc()` is _not_ compatible with `WithFieldValue<Post>`. This\n *     // type checking prevents the caller from specifying objects with incorrect\n *     // properties or property values.\n *     // @ts-expect-error \"Argument of type { ttl: string; } is not assignable\n *     // to parameter of type WithFieldValue<Post>\"\n *     await setDoc(documentRef, { ttl: 'The Title' });\n *\n *     // When retrieving a document with `getDoc()` the `DocumentSnapshot`\n *     // object's `data()` method returns a `Post`, rather than a generic object,\n *     // which would have been returned if the `DocumentReference` did _not_ have a\n *     // `FirestoreDataConverter` attached to it.\n *     const snapshot1: DocumentSnapshot<Post> = await getDoc(documentRef);\n *     const post1: Post = snapshot1.data()!;\n *     if (post1) {\n *         assertEqual(post1.title, 'My Life');\n *         assertEqual(post1.author, 'Foo Bar');\n *     }\n *\n *     // The `data` argument specified to `updateDoc()` is type checked by the\n *     // TypeScript compiler to be compatible with `PostDbModel`. Note that\n *     // unlike `setDoc()`, whose `data` argument must be compatible with `Post`,\n *     // the `data` argument to `updateDoc()` must be compatible with\n *     // `PostDbModel`. Similar to `setDoc()`, since the `data` argument is typed\n *     // as `WithFieldValue<PostDbModel>` rather than just `PostDbModel`, this\n *     // allows properties of the `data` argument to also be those special\n *     // Firestore values, like `arrayRemove()`, `deleteField()`, and\n *     // `serverTimestamp()`.\n *     await updateDoc(documentRef, {\n *         'aut.firstName': 'NewFirstName',\n *         lut: serverTimestamp()\n *     });\n *\n *     // The TypeScript compiler will fail to compile if the `data` argument to\n *     // `updateDoc()` is _not_ compatible with `WithFieldValue<PostDbModel>`.\n *     // This type checking prevents the caller from specifying objects with\n *     // incorrect properties or property values.\n *     // @ts-expect-error \"Argument of type { title: string; } is not assignable\n *     // to parameter of type WithFieldValue<PostDbModel>\"\n *     await updateDoc(documentRef, { title: 'New Title' });\n *     const snapshot2: DocumentSnapshot<Post> = await getDoc(documentRef);\n *     const post2: Post = snapshot2.data()!;\n *     if (post2) {\n *         assertEqual(post2.title, 'My Life');\n *         assertEqual(post2.author, 'NewFirstName Bar');\n *     }\n * }\n * ```\n */\nexport interface FirestoreDataConverter<\n  AppModelType,\n  DbModelType extends DocumentData = DocumentData\n> extends LiteFirestoreDataConverter<AppModelType, DbModelType> {\n  /**\n   * Called by the Firestore SDK to convert a custom model object of type\n   * `AppModelType` into a plain JavaScript object (suitable for writing\n   * directly to the Firestore database) of type `DbModelType`. To use `set()`\n   * with `merge` and `mergeFields`, `toFirestore()` must be defined with\n   * `PartialWithFieldValue<AppModelType>`.\n   *\n   * The `WithFieldValue<T>` type extends `T` to also allow FieldValues such as\n   * {@link (deleteField:1)} to be used as property values.\n   */\n  toFirestore(\n    modelObject: WithFieldValue<AppModelType>\n  ): WithFieldValue<DbModelType>;\n\n  /**\n   * Called by the Firestore SDK to convert a custom model object of type\n   * `AppModelType` into a plain JavaScript object (suitable for writing\n   * directly to the Firestore database) of type `DbModelType`. Used with\n   * {@link (setDoc:1)}, {@link (WriteBatch.set:1)} and\n   * {@link (Transaction.set:1)} with `merge:true` or `mergeFields`.\n   *\n   * The `PartialWithFieldValue<T>` type extends `Partial<T>` to allow\n   * FieldValues such as {@link (arrayUnion:1)} to be used as property values.\n   * It also supports nested `Partial` by allowing nested fields to be\n   * omitted.\n   */\n  toFirestore(\n    modelObject: PartialWithFieldValue<AppModelType>,\n    options: SetOptions\n  ): PartialWithFieldValue<DbModelType>;\n\n  /**\n   * Called by the Firestore SDK to convert Firestore data into an object of\n   * type `AppModelType`. You can access your data by calling:\n   * `snapshot.data(options)`.\n   *\n   * Generally, the data returned from `snapshot.data()` can be cast to\n   * `DbModelType`; however, this is not guaranteed because Firestore does not\n   * enforce a schema on the database. For example, writes from a previous\n   * version of the application or writes from another client that did not use a\n   * type converter could have written data with different properties and/or\n   * property types. The implementation will need to choose whether to\n   * gracefully recover from non-conforming data or throw an error.\n   *\n   * To override this method, see {@link (FirestoreDataConverter.fromFirestore:1)}.\n   *\n   * @param snapshot - A `QueryDocumentSnapshot` containing your data and metadata.\n   * @param options - The `SnapshotOptions` from the initial call to `data()`.\n   */\n  fromFirestore(\n    snapshot: QueryDocumentSnapshot<DocumentData, DocumentData>,\n    options?: SnapshotOptions\n  ): AppModelType;\n}\n\n/**\n * Options that configure how data is retrieved from a `DocumentSnapshot` (for\n * example the desired behavior for server timestamps that have not yet been set\n * to their final value).\n */\nexport interface SnapshotOptions {\n  /**\n   * If set, controls the return value for server timestamps that have not yet\n   * been set to their final value.\n   *\n   * By specifying 'estimate', pending server timestamps return an estimate\n   * based on the local clock. This estimate will differ from the final value\n   * and cause these values to change once the server result becomes available.\n   *\n   * By specifying 'previous', pending timestamps will be ignored and return\n   * their previous value instead.\n   *\n   * If omitted or set to 'none', `null` will be returned by default until the\n   * server value becomes available.\n   */\n  readonly serverTimestamps?: 'estimate' | 'previous' | 'none';\n}\n\n/**\n * Metadata about a snapshot, describing the state of the snapshot.\n */\nexport class SnapshotMetadata {\n  /**\n   * True if the snapshot contains the result of local writes (for example\n   * `set()` or `update()` calls) that have not yet been committed to the\n   * backend. If your listener has opted into metadata updates (via\n   * `SnapshotListenOptions`) you will receive another snapshot with\n   * `hasPendingWrites` equal to false once the writes have been committed to\n   * the backend.\n   */\n  readonly hasPendingWrites: boolean;\n\n  /**\n   * True if the snapshot was created from cached data rather than guaranteed\n   * up-to-date server data. If your listener has opted into metadata updates\n   * (via `SnapshotListenOptions`) you will receive another snapshot with\n   * `fromCache` set to false once the client has received up-to-date data from\n   * the backend.\n   */\n  readonly fromCache: boolean;\n\n  /** @hideconstructor */\n  constructor(hasPendingWrites: boolean, fromCache: boolean) {\n    this.hasPendingWrites = hasPendingWrites;\n    this.fromCache = fromCache;\n  }\n\n  /**\n   * Returns true if this `SnapshotMetadata` is equal to the provided one.\n   *\n   * @param other - The `SnapshotMetadata` to compare against.\n   * @returns true if this `SnapshotMetadata` is equal to the provided one.\n   */\n  isEqual(other: SnapshotMetadata): boolean {\n    return (\n      this.hasPendingWrites === other.hasPendingWrites &&\n      this.fromCache === other.fromCache\n    );\n  }\n}\n\n/**\n * The type of a `DocumentChange` may be 'added', 'removed', or 'modified'.\n */\nexport type DocumentChangeType = 'added' | 'removed' | 'modified';\n\n/**\n * A `DocumentChange` represents a change to the documents matching a query.\n * It contains the document affected and the type of change that occurred.\n */\nexport interface DocumentChange<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> {\n  /** The type of change ('added', 'modified', or 'removed'). */\n  readonly type: DocumentChangeType;\n\n  /** The document affected by this change. */\n  readonly doc: QueryDocumentSnapshot<AppModelType, DbModelType>;\n\n  /**\n   * The index of the changed document in the result set immediately prior to\n   * this `DocumentChange` (i.e. supposing that all prior `DocumentChange` objects\n   * have been applied). Is `-1` for 'added' events.\n   */\n  readonly oldIndex: number;\n\n  /**\n   * The index of the changed document in the result set immediately after\n   * this `DocumentChange` (i.e. supposing that all prior `DocumentChange`\n   * objects and the current `DocumentChange` object have been applied).\n   * Is -1 for 'removed' events.\n   */\n  readonly newIndex: number;\n}\n\n/**\n * A `DocumentSnapshot` contains data read from a document in your Firestore\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\n * get a specific field.\n *\n * For a `DocumentSnapshot` that points to a non-existing document, any data\n * access will return 'undefined'. You can use the `exists()` method to\n * explicitly verify a document's existence.\n */\nexport class DocumentSnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> extends LiteDocumentSnapshot<AppModelType, DbModelType> {\n  private readonly _firestoreImpl: Firestore;\n\n  /**\n   *  Metadata about the `DocumentSnapshot`, including information about its\n   *  source and local modifications.\n   */\n  readonly metadata: SnapshotMetadata;\n\n  /** @hideconstructor protected */\n  constructor(\n    readonly _firestore: Firestore,\n    userDataWriter: AbstractUserDataWriter,\n    key: DocumentKey,\n    document: Document | null,\n    metadata: SnapshotMetadata,\n    converter: UntypedFirestoreDataConverter<AppModelType, DbModelType> | null\n  ) {\n    super(_firestore, userDataWriter, key, document, converter);\n    this._firestoreImpl = _firestore;\n    this.metadata = metadata;\n  }\n\n  /**\n   * Returns whether or not the data exists. True if the document exists.\n   */\n  exists(): this is QueryDocumentSnapshot<AppModelType, DbModelType> {\n    return super.exists();\n  }\n\n  /**\n   * Retrieves all fields in the document as an `Object`. Returns `undefined` if\n   * the document doesn't exist.\n   *\n   * By default, `serverTimestamp()` values that have not yet been\n   * set to their final value will be returned as `null`. You can override\n   * this by passing an options object.\n   *\n   * @param options - An options object to configure how data is retrieved from\n   * the snapshot (for example the desired behavior for server timestamps that\n   * have not yet been set to their final value).\n   * @returns An `Object` containing all fields in the document or `undefined` if\n   * the document doesn't exist.\n   */\n  data(options: SnapshotOptions = {}): AppModelType | undefined {\n    if (!this._document) {\n      return undefined;\n    } else if (this._converter) {\n      // We only want to use the converter and create a new DocumentSnapshot\n      // if a converter has been provided.\n      const snapshot = new QueryDocumentSnapshot(\n        this._firestore,\n        this._userDataWriter,\n        this._key,\n        this._document,\n        this.metadata,\n        /* converter= */ null\n      );\n      return this._converter.fromFirestore(snapshot, options);\n    } else {\n      return this._userDataWriter.convertValue(\n        this._document.data.value,\n        options.serverTimestamps\n      ) as AppModelType;\n    }\n  }\n\n  /**\n   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\n   * document or field doesn't exist.\n   *\n   * By default, a `serverTimestamp()` that has not yet been set to\n   * its final value will be returned as `null`. You can override this by\n   * passing an options object.\n   *\n   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\n   * field.\n   * @param options - An options object to configure how the field is retrieved\n   * from the snapshot (for example the desired behavior for server timestamps\n   * that have not yet been set to their final value).\n   * @returns The data at the specified field location or undefined if no such\n   * field exists in the document.\n   */\n  // We are using `any` here to avoid an explicit cast by our users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(fieldPath: string | FieldPath, options: SnapshotOptions = {}): any {\n    if (this._document) {\n      const value = this._document.data.field(\n        fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n      );\n      if (value !== null) {\n        return this._userDataWriter.convertValue(\n          value,\n          options.serverTimestamps\n        );\n      }\n    }\n    return undefined;\n  }\n\n  static _jsonSchemaVersion: string = 'firestore/documentSnapshot/1.0';\n  static _jsonSchema = {\n    type: property('string', DocumentSnapshot._jsonSchemaVersion),\n    bundleSource: property('string', 'DocumentSnapshot'),\n    bundleName: property('string'),\n    bundle: property('string')\n  };\n\n  /**\n   * Returns a JSON-serializable representation of this `DocumentSnapshot` instance.\n   *\n   * @returns a JSON representation of this object.  Throws a {@link FirestoreError} if this\n   * `DocumentSnapshot` has pending writes.\n   */\n  toJSON(): object {\n    if (this.metadata.hasPendingWrites) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'DocumentSnapshot.toJSON() attempted to serialize a document with pending writes. ' +\n          'Await waitForPendingWrites() before invoking toJSON().'\n      );\n    }\n    const document = this._document;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const result: any = {};\n    result['type'] = DocumentSnapshot._jsonSchemaVersion;\n    result['bundle'] = '';\n    result['bundleSource'] = 'DocumentSnapshot';\n    result['bundleName'] = this._key.toString();\n\n    if (\n      !document ||\n      !document.isValidDocument() ||\n      !document.isFoundDocument()\n    ) {\n      return result;\n    }\n    const documentData = this._userDataWriter.convertObjectMap(\n      document.data.value.mapValue.fields,\n      'previous'\n    );\n    result['bundle'] = buildDocumentSnapshotJsonBundle(\n      this._firestore,\n      document,\n      documentData,\n      this.ref.path\n    );\n    return result;\n  }\n}\n\n/**\n * Builds a `DocumentSnapshot` instance from a JSON object created by\n * {@link DocumentSnapshot.toJSON}.\n *\n * @param firestore - The {@link Firestore} instance the snapshot should be loaded for.\n * @param json - a JSON object represention of a `DocumentSnapshot` instance.\n * @returns an instance of {@link DocumentSnapshot} if the JSON object could be\n * parsed. Throws a {@link FirestoreError} if an error occurs.\n */\nexport function documentSnapshotFromJSON(\n  db: Firestore,\n  json: object\n): DocumentSnapshot;\n/**\n * Builds a `DocumentSnapshot` instance from a JSON object created by\n * {@link DocumentSnapshot.toJSON}.\n *\n * @param firestore - The {@link Firestore} instance the snapshot should be loaded for.\n * @param json - a JSON object represention of a `DocumentSnapshot` instance.\n * @param converter - Converts objects to and from Firestore.\n * @returns an instance of {@link DocumentSnapshot} if the JSON object could be\n * parsed. Throws a {@link FirestoreError} if an error occurs.\n */\nexport function documentSnapshotFromJSON<\n  AppModelType,\n  DbModelType extends DocumentData = DocumentData\n>(\n  db: Firestore,\n  json: object,\n  converter: FirestoreDataConverter<AppModelType, DbModelType>\n): DocumentSnapshot<AppModelType, DbModelType>;\nexport function documentSnapshotFromJSON<\n  AppModelType,\n  DbModelType extends DocumentData = DocumentData\n>(\n  db: Firestore,\n  json: object,\n  converter?: FirestoreDataConverter<AppModelType, DbModelType>\n): DocumentSnapshot<AppModelType, DbModelType> {\n  if (validateJSON(json, DocumentSnapshot._jsonSchema)) {\n    if (json.bundle === NOT_SUPPORTED) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'The provided JSON object was created in a client environment, which is not supported.'\n      );\n    }\n    // Parse the bundle data.\n    const serializer = newSerializer(db._databaseId);\n    const bundleReader = createBundleReaderSync(json.bundle, serializer);\n    const elements = bundleReader.getElements();\n    const bundleLoader: BundleLoader = new BundleLoader(\n      bundleReader.getMetadata(),\n      serializer\n    );\n    for (const element of elements) {\n      bundleLoader.addSizedElement(element);\n    }\n\n    // Ensure that we have the correct number of documents in the bundle.\n    const bundledDocuments = bundleLoader.documents;\n    if (bundledDocuments.length !== 1) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Expected bundle data to contain 1 document, but it contains ${bundledDocuments.length} documents.`\n      );\n    }\n\n    // Build out the internal document data.\n    const document = fromDocument(serializer, bundledDocuments[0].document!);\n    const documentKey = new DocumentKey(\n      ResourcePath.fromString(json.bundleName)\n    );\n\n    // Return the external facing DocumentSnapshot.\n    return new DocumentSnapshot(\n      db,\n      new LiteUserDataWriter(db),\n      documentKey,\n      document,\n      new SnapshotMetadata(\n        /* hasPendingWrites= */ false,\n        /* fromCache= */ false\n      ),\n      converter ? converter : null\n    );\n  }\n  throw new FirestoreError(\n    Code.INTERNAL,\n    'Unexpected error creating DocumentSnapshot from JSON.'\n  );\n}\n\n/**\n * A `QueryDocumentSnapshot` contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\n * specific field.\n *\n * A `QueryDocumentSnapshot` offers the same API surface as a\n * `DocumentSnapshot`. Since query results contain only existing documents, the\n * `exists` property will always be true and `data()` will never return\n * 'undefined'.\n */\nexport class QueryDocumentSnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> extends DocumentSnapshot<AppModelType, DbModelType> {\n  /**\n   * Retrieves all fields in the document as an `Object`.\n   *\n   * By default, `serverTimestamp()` values that have not yet been\n   * set to their final value will be returned as `null`. You can override\n   * this by passing an options object.\n   *\n   * @override\n   * @param options - An options object to configure how data is retrieved from\n   * the snapshot (for example the desired behavior for server timestamps that\n   * have not yet been set to their final value).\n   * @returns An `Object` containing all fields in the document.\n   */\n  data(options: SnapshotOptions = {}): AppModelType {\n    return super.data(options) as AppModelType;\n  }\n}\n\n/**\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\n * representing the results of a query. The documents can be accessed as an\n * array via the `docs` property or enumerated using the `forEach` method. The\n * number of documents can be determined via the `empty` and `size`\n * properties.\n */\nexport class QuerySnapshot<\n  AppModelType = DocumentData,\n  DbModelType extends DocumentData = DocumentData\n> {\n  /**\n   * Metadata about this snapshot, concerning its source and if it has local\n   * modifications.\n   */\n  readonly metadata: SnapshotMetadata;\n\n  /**\n   * The query on which you called `get` or `onSnapshot` in order to get this\n   * `QuerySnapshot`.\n   */\n  readonly query: Query<AppModelType, DbModelType>;\n\n  private _cachedChanges?: Array<DocumentChange<AppModelType, DbModelType>>;\n  private _cachedChangesIncludeMetadataChanges?: boolean;\n\n  /** @hideconstructor */\n  constructor(\n    readonly _firestore: Firestore,\n    readonly _userDataWriter: AbstractUserDataWriter,\n    query: Query<AppModelType, DbModelType>,\n    readonly _snapshot: ViewSnapshot\n  ) {\n    this.metadata = new SnapshotMetadata(\n      _snapshot.hasPendingWrites,\n      _snapshot.fromCache\n    );\n    this.query = query;\n  }\n\n  /** An array of all the documents in the `QuerySnapshot`. */\n  get docs(): Array<QueryDocumentSnapshot<AppModelType, DbModelType>> {\n    const result: Array<QueryDocumentSnapshot<AppModelType, DbModelType>> = [];\n    this.forEach(doc => result.push(doc));\n    return result;\n  }\n\n  /** The number of documents in the `QuerySnapshot`. */\n  get size(): number {\n    return this._snapshot.docs.size;\n  }\n\n  /** True if there are no documents in the `QuerySnapshot`. */\n  get empty(): boolean {\n    return this.size === 0;\n  }\n\n  /**\n   * Enumerates all of the documents in the `QuerySnapshot`.\n   *\n   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\n   * each document in the snapshot.\n   * @param thisArg - The `this` binding for the callback.\n   */\n  forEach(\n    callback: (\n      result: QueryDocumentSnapshot<AppModelType, DbModelType>\n    ) => void,\n    thisArg?: unknown\n  ): void {\n    this._snapshot.docs.forEach(doc => {\n      callback.call(\n        thisArg,\n        new QueryDocumentSnapshot<AppModelType, DbModelType>(\n          this._firestore,\n          this._userDataWriter,\n          doc.key,\n          doc,\n          new SnapshotMetadata(\n            this._snapshot.mutatedKeys.has(doc.key),\n            this._snapshot.fromCache\n          ),\n          this.query.converter\n        )\n      );\n    });\n  }\n\n  /**\n   * Returns an array of the documents changes since the last snapshot. If this\n   * is the first snapshot, all documents will be in the list as 'added'\n   * changes.\n   *\n   * @param options - `SnapshotListenOptions` that control whether metadata-only\n   * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\n   * snapshot events.\n   */\n  docChanges(\n    options: SnapshotListenOptions = {}\n  ): Array<DocumentChange<AppModelType, DbModelType>> {\n    const includeMetadataChanges = !!options.includeMetadataChanges;\n\n    if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'To include metadata changes with your document changes, you must ' +\n          'also pass { includeMetadataChanges:true } to onSnapshot().'\n      );\n    }\n\n    if (\n      !this._cachedChanges ||\n      this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges\n    ) {\n      this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);\n      this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;\n    }\n\n    return this._cachedChanges;\n  }\n\n  static _jsonSchemaVersion: string = 'firestore/querySnapshot/1.0';\n  static _jsonSchema = {\n    type: property('string', QuerySnapshot._jsonSchemaVersion),\n    bundleSource: property('string', 'QuerySnapshot'),\n    bundleName: property('string'),\n    bundle: property('string')\n  };\n\n  /**\n   * Returns a JSON-serializable representation of this `QuerySnapshot` instance.\n   *\n   * @returns a JSON representation of this object. Throws a {@link FirestoreError} if this\n   * `QuerySnapshot` has pending writes.\n   */\n  toJSON(): object {\n    if (this.metadata.hasPendingWrites) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'QuerySnapshot.toJSON() attempted to serialize a document with pending writes. ' +\n          'Await waitForPendingWrites() before invoking toJSON().'\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const result: any = {};\n    result['type'] = QuerySnapshot._jsonSchemaVersion;\n    result['bundleSource'] = 'QuerySnapshot';\n    result['bundleName'] = AutoId.newId();\n\n    const databaseId = this._firestore._databaseId.database;\n    const projectId = this._firestore._databaseId.projectId;\n    const parent = `projects/${projectId}/databases/${databaseId}/documents`;\n    const documents: Document[] = [];\n    const documentData: DocumentData[] = [];\n    const paths: string[] = [];\n\n    this.docs.forEach(doc => {\n      if (doc._document === null) {\n        return;\n      }\n      documents.push(doc._document);\n      documentData.push(\n        this._userDataWriter.convertObjectMap(\n          doc._document.data.value.mapValue.fields,\n          'previous'\n        )\n      );\n      paths.push(doc.ref.path);\n    });\n    result['bundle'] = buildQuerySnapshotJsonBundle(\n      this._firestore,\n      this.query._query,\n      result['bundleName'],\n      parent,\n      paths,\n      documents,\n      documentData\n    );\n    return result;\n  }\n}\n\n/**\n * Builds a `QuerySnapshot` instance from a JSON object created by\n * {@link QuerySnapshot.toJSON}.\n *\n * @param firestore - The {@link Firestore} instance the snapshot should be loaded for.\n * @param json - a JSON object represention of a `QuerySnapshot` instance.\n * @returns an instance of {@link QuerySnapshot} if the JSON object could be\n * parsed. Throws a {@link FirestoreError} if an error occurs.\n */\nexport function querySnapshotFromJSON(\n  db: Firestore,\n  json: object\n): QuerySnapshot;\n/**\n * Builds a `QuerySnapshot` instance from a JSON object created by\n * {@link QuerySnapshot.toJSON}.\n *\n * @param firestore - The {@link Firestore} instance the snapshot should be loaded for.\n * @param json - a JSON object represention of a `QuerySnapshot` instance.\n * @param converter - Converts objects to and from Firestore.\n * @returns an instance of {@link QuerySnapshot} if the JSON object could be\n * parsed. Throws a {@link FirestoreError} if an error occurs.\n */\nexport function querySnapshotFromJSON<\n  AppModelType,\n  DbModelType extends DocumentData = DocumentData\n>(\n  db: Firestore,\n  json: object,\n  converter: FirestoreDataConverter<AppModelType, DbModelType>\n): QuerySnapshot<AppModelType, DbModelType>;\nexport function querySnapshotFromJSON<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  db: Firestore,\n  json: object,\n  converter?: FirestoreDataConverter<AppModelType, DbModelType>\n): QuerySnapshot<AppModelType, DbModelType> {\n  if (validateJSON(json, QuerySnapshot._jsonSchema)) {\n    if (json.bundle === NOT_SUPPORTED) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'The provided JSON object was created in a client environment, which is not supported.'\n      );\n    }\n    // Parse the bundle data.\n    const serializer = newSerializer(db._databaseId);\n    const bundleReader = createBundleReaderSync(json.bundle, serializer);\n    const elements = bundleReader.getElements();\n    const bundleLoader: BundleLoader = new BundleLoader(\n      bundleReader.getMetadata(),\n      serializer\n    );\n    for (const element of elements) {\n      bundleLoader.addSizedElement(element);\n    }\n\n    if (bundleLoader.queries.length !== 1) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Snapshot data expected 1 query but found ${bundleLoader.queries.length} queries.`\n      );\n    }\n\n    // Create an internal Query object from the named query in the bundle.\n    const query = fromBundledQuery(bundleLoader.queries[0].bundledQuery!);\n\n    // Construct the arrays of document data for the query.\n    const bundledDocuments = bundleLoader.documents;\n    let documentSet = new DocumentSet();\n    bundledDocuments.map(bundledDocument => {\n      const document = fromDocument(serializer, bundledDocument.document!);\n      documentSet = documentSet.add(document);\n    });\n    // Create a view snapshot of the query and documents.\n    const viewSnapshot = ViewSnapshot.fromInitialDocuments(\n      query,\n      documentSet,\n      documentKeySet() /* Zero mutated keys signifies no pending writes. */,\n      /* fromCache= */ false,\n      /* hasCachedResults= */ false\n    );\n\n    // Create an external Query object, required to construct the QuerySnapshot.\n    const externalQuery = new Query<AppModelType, DbModelType>(\n      db,\n      converter ? converter : null,\n      query\n    );\n\n    // Return a new QuerySnapshot with all of the collected data.\n    return new QuerySnapshot<AppModelType, DbModelType>(\n      db,\n      new LiteUserDataWriter(db),\n      externalQuery,\n      viewSnapshot\n    );\n  }\n  throw new FirestoreError(\n    Code.INTERNAL,\n    'Unexpected error creating QuerySnapshot from JSON.'\n  );\n}\n\n/** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */\nexport function changesFromSnapshot<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  querySnapshot: QuerySnapshot<AppModelType, DbModelType>,\n  includeMetadataChanges: boolean\n): Array<DocumentChange<AppModelType, DbModelType>> {\n  if (querySnapshot._snapshot.oldDocs.isEmpty()) {\n    // Special case the first snapshot because index calculation is easy and\n    // fast\n    let lastDoc: Document;\n    let index = 0;\n    return querySnapshot._snapshot.docChanges.map(change => {\n      debugAssert(\n        change.type === ChangeType.Added,\n        'Invalid event type for first snapshot'\n      );\n      debugAssert(\n        !lastDoc ||\n          newQueryComparator(querySnapshot._snapshot.query)(\n            lastDoc,\n            change.doc\n          ) < 0,\n        'Got added events in wrong order'\n      );\n      const doc = new QueryDocumentSnapshot<AppModelType, DbModelType>(\n        querySnapshot._firestore,\n        querySnapshot._userDataWriter,\n        change.doc.key,\n        change.doc,\n        new SnapshotMetadata(\n          querySnapshot._snapshot.mutatedKeys.has(change.doc.key),\n          querySnapshot._snapshot.fromCache\n        ),\n        querySnapshot.query.converter\n      );\n      lastDoc = change.doc;\n      return {\n        type: 'added' as DocumentChangeType,\n        doc,\n        oldIndex: -1,\n        newIndex: index++\n      };\n    });\n  } else {\n    // A `DocumentSet` that is updated incrementally as changes are applied to use\n    // to lookup the index of a document.\n    let indexTracker = querySnapshot._snapshot.oldDocs;\n    return querySnapshot._snapshot.docChanges\n      .filter(\n        change => includeMetadataChanges || change.type !== ChangeType.Metadata\n      )\n      .map(change => {\n        const doc = new QueryDocumentSnapshot<AppModelType, DbModelType>(\n          querySnapshot._firestore,\n          querySnapshot._userDataWriter,\n          change.doc.key,\n          change.doc,\n          new SnapshotMetadata(\n            querySnapshot._snapshot.mutatedKeys.has(change.doc.key),\n            querySnapshot._snapshot.fromCache\n          ),\n          querySnapshot.query.converter\n        );\n        let oldIndex = -1;\n        let newIndex = -1;\n        if (change.type !== ChangeType.Added) {\n          oldIndex = indexTracker.indexOf(change.doc.key);\n          debugAssert(oldIndex >= 0, 'Index for document not found');\n          indexTracker = indexTracker.delete(change.doc.key);\n        }\n        if (change.type !== ChangeType.Removed) {\n          indexTracker = indexTracker.add(change.doc);\n          newIndex = indexTracker.indexOf(change.doc.key);\n        }\n        return {\n          type: resultChangeType(change.type),\n          doc,\n          oldIndex,\n          newIndex\n        };\n      });\n  }\n}\n\nexport function resultChangeType(type: ChangeType): DocumentChangeType {\n  switch (type) {\n    case ChangeType.Added:\n      return 'added';\n    case ChangeType.Modified:\n    case ChangeType.Metadata:\n      return 'modified';\n    case ChangeType.Removed:\n      return 'removed';\n    default:\n      return fail(0xf03d, 'Unknown change type', { type });\n  }\n}\n\n// TODO(firestoreexp): Add tests for snapshotEqual with different snapshot\n// metadata\n/**\n * Returns true if the provided snapshots are equal.\n *\n * @param left - A snapshot to compare.\n * @param right - A snapshot to compare.\n * @returns true if the snapshots are equal.\n */\nexport function snapshotEqual<AppModelType, DbModelType extends DocumentData>(\n  left:\n    | DocumentSnapshot<AppModelType, DbModelType>\n    | QuerySnapshot<AppModelType, DbModelType>,\n  right:\n    | DocumentSnapshot<AppModelType, DbModelType>\n    | QuerySnapshot<AppModelType, DbModelType>\n): boolean {\n  if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\n    return (\n      left._firestore === right._firestore &&\n      left._key.isEqual(right._key) &&\n      (left._document === null\n        ? right._document === null\n        : left._document.isEqual(right._document)) &&\n      left._converter === right._converter\n    );\n  } else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\n    return (\n      left._firestore === right._firestore &&\n      queryEqual(left.query, right.query) &&\n      left.metadata.isEqual(right.metadata) &&\n      left._snapshot.isEqual(right._snapshot)\n    );\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Return the Platform-specific build JSON bundle implementations. */\nimport { Firestore } from '../../api/database';\nimport { Query } from '../../core/query';\nimport { DocumentData } from '../../lite-api/reference';\nimport { Document } from '../../model/document';\n\nexport function buildDocumentSnapshotJsonBundle(\n  db: Firestore,\n  document: Document,\n  docData: DocumentData,\n  path: string\n): string {\n  return 'NOT SUPPORTED';\n}\n\nexport function buildQuerySnapshotJsonBundle(\n  db: Firestore,\n  query: Query,\n  bundleName: string,\n  parent: string,\n  paths: string[],\n  docs: Document[],\n  documentData: DocumentData[]\n): string {\n  return 'NOT SUPPORTED';\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Code, FirestoreError } from '../util/error';\n\nexport const DEFAULT_TRANSACTION_OPTIONS: TransactionOptions = {\n  maxAttempts: 5\n};\n\n/**\n * Options to customize transaction behavior.\n */\nexport declare interface TransactionOptions {\n  /** Maximum number of attempts to commit, after which transaction fails. Default is 5. */\n  readonly maxAttempts: number;\n}\n\nexport function validateTransactionOptions(options: TransactionOptions): void {\n  if (options.maxAttempts < 1) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Max attempts must be at least 1'\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Compat, getModularInstance } from '@firebase/util';\n\nimport { DeleteMutation, Mutation, Precondition } from '../model/mutation';\nimport { invokeCommitRpc } from '../remote/datastore';\nimport { Code, FirestoreError } from '../util/error';\nimport { cast } from '../util/input_validation';\n\nimport { getDatastore } from './components';\nimport { Firestore } from './database';\nimport { FieldPath } from './field_path';\nimport {\n  DocumentData,\n  DocumentReference,\n  PartialWithFieldValue,\n  SetOptions,\n  UpdateData,\n  WithFieldValue\n} from './reference';\nimport { applyFirestoreDataConverter } from './reference_impl';\nimport {\n  newUserDataReader,\n  parseSetData,\n  parseUpdateData,\n  parseUpdateVarargs,\n  UserDataReader\n} from './user_data_reader';\n\n/**\n * A write batch, used to perform multiple writes as a single atomic unit.\n *\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\n * provides methods for adding writes to the write batch. None of the writes\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\n * called.\n */\nexport class WriteBatch {\n  // This is the lite version of the WriteBatch API used in the legacy SDK. The\n  // class is a close copy but takes different input types.\n\n  private readonly _dataReader: UserDataReader;\n  private _mutations = [] as Mutation[];\n  private _committed = false;\n\n  /** @hideconstructor */\n  constructor(\n    private readonly _firestore: Firestore,\n    private readonly _commitHandler: (m: Mutation[]) => Promise<void>\n  ) {\n    this._dataReader = newUserDataReader(_firestore);\n  }\n\n  /**\n   * Writes to the document referred to by the provided {@link\n   * DocumentReference}. If the document does not exist yet, it will be created.\n   *\n   * @param documentRef - A reference to the document to be set.\n   * @param data - An object of the fields and values for the document.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: WithFieldValue<AppModelType>\n  ): WriteBatch;\n  /**\n   * Writes to the document referred to by the provided {@link\n   * DocumentReference}. If the document does not exist yet, it will be created.\n   * If you provide `merge` or `mergeFields`, the provided data can be merged\n   * into an existing document.\n   *\n   * @param documentRef - A reference to the document to be set.\n   * @param data - An object of the fields and values for the document.\n   * @param options - An object to configure the set behavior.\n   * @throws Error - If the provided input is not a valid Firestore document.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: PartialWithFieldValue<AppModelType>,\n    options: SetOptions\n  ): WriteBatch;\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: WithFieldValue<AppModelType> | PartialWithFieldValue<AppModelType>,\n    options?: SetOptions\n  ): WriteBatch {\n    this._verifyNotCommitted();\n    const ref = validateReference(documentRef, this._firestore);\n\n    const convertedValue = applyFirestoreDataConverter(\n      ref.converter,\n      data,\n      options\n    );\n    const parsed = parseSetData(\n      this._dataReader,\n      'WriteBatch.set',\n      ref._key,\n      convertedValue,\n      ref.converter !== null,\n      options\n    );\n    this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));\n    return this;\n  }\n\n  /**\n   * Updates fields in the document referred to by the provided {@link\n   * DocumentReference}. The update will fail if applied to a document that does\n   * not exist.\n   *\n   * @param documentRef - A reference to the document to be updated.\n   * @param data - An object containing the fields and values with which to\n   * update the document. Fields can contain dots to reference nested fields\n   * within the document.\n   * @throws Error - If the provided input is not valid Firestore data.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: UpdateData<DbModelType>\n  ): WriteBatch;\n  /**\n   * Updates fields in the document referred to by this {@link\n   * DocumentReference}. The update will fail if applied to a document that does\n   * not exist.\n   *\n   * Nested fields can be update by providing dot-separated field path strings\n   * or by providing `FieldPath` objects.\n   *\n   * @param documentRef - A reference to the document to be updated.\n   * @param field - The first field to update.\n   * @param value - The first value.\n   * @param moreFieldsAndValues - Additional key value pairs.\n   * @throws Error - If the provided input is not valid Firestore data.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    field: string | FieldPath,\n    value: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): WriteBatch;\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    fieldOrUpdateData: string | FieldPath | UpdateData<DbModelType>,\n    value?: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): WriteBatch {\n    this._verifyNotCommitted();\n    const ref = validateReference(documentRef, this._firestore);\n\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    fieldOrUpdateData = getModularInstance(fieldOrUpdateData);\n\n    let parsed;\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof FieldPath\n    ) {\n      parsed = parseUpdateVarargs(\n        this._dataReader,\n        'WriteBatch.update',\n        ref._key,\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      parsed = parseUpdateData(\n        this._dataReader,\n        'WriteBatch.update',\n        ref._key,\n        fieldOrUpdateData\n      );\n    }\n\n    this._mutations.push(\n      parsed.toMutation(ref._key, Precondition.exists(true))\n    );\n    return this;\n  }\n\n  /**\n   * Deletes the document referred to by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be deleted.\n   * @returns This `WriteBatch` instance. Used for chaining method calls.\n   */\n  delete<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>\n  ): WriteBatch {\n    this._verifyNotCommitted();\n    const ref = validateReference(documentRef, this._firestore);\n    this._mutations = this._mutations.concat(\n      new DeleteMutation(ref._key, Precondition.none())\n    );\n    return this;\n  }\n\n  /**\n   * Commits all of the writes in this write batch as a single atomic unit.\n   *\n   * The result of these writes will only be reflected in document reads that\n   * occur after the returned promise resolves. If the client is offline, the\n   * write fails. If you would like to see local modifications or buffer writes\n   * until the client is online, use the full Firestore SDK.\n   *\n   * @returns A `Promise` resolved once all of the writes in the batch have been\n   * successfully written to the backend as an atomic unit (note that it won't\n   * resolve while you're offline).\n   */\n  commit(): Promise<void> {\n    this._verifyNotCommitted();\n    this._committed = true;\n    if (this._mutations.length > 0) {\n      return this._commitHandler(this._mutations);\n    }\n\n    return Promise.resolve();\n  }\n\n  private _verifyNotCommitted(): void {\n    if (this._committed) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'A write batch can no longer be used after commit() ' +\n          'has been called.'\n      );\n    }\n  }\n}\n\nexport function validateReference<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  documentRef:\n    | DocumentReference<AppModelType, DbModelType>\n    | Compat<DocumentReference<AppModelType, DbModelType>>,\n  firestore: Firestore\n): DocumentReference<AppModelType, DbModelType> {\n  documentRef = getModularInstance(documentRef);\n\n  if (documentRef.firestore !== firestore) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Provided document reference is from a different Firestore instance.'\n    );\n  } else {\n    return documentRef as DocumentReference<AppModelType, DbModelType>;\n  }\n}\n\n/**\n * Creates a write batch, used for performing multiple writes as a single\n * atomic operation. The maximum number of writes allowed in a single WriteBatch\n * is 500.\n *\n * The result of these writes will only be reflected in document reads that\n * occur after the returned promise resolves. If the client is offline, the\n * write fails. If you would like to see local modifications or buffer writes\n * until the client is online, use the full Firestore SDK.\n *\n * @returns A `WriteBatch` that can be used to atomically execute multiple\n * writes.\n */\nexport function writeBatch(firestore: Firestore): WriteBatch {\n  firestore = cast(firestore, Firestore);\n  const datastore = getDatastore(firestore);\n  return new WriteBatch(firestore, writes =>\n    invokeCommitRpc(datastore, writes)\n  );\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getModularInstance } from '@firebase/util';\n\nimport { Transaction as InternalTransaction } from '../core/transaction';\nimport {\n  DEFAULT_TRANSACTION_OPTIONS,\n  TransactionOptions as TransactionOptionsInternal,\n  validateTransactionOptions\n} from '../core/transaction_options';\nimport { TransactionRunner } from '../core/transaction_runner';\nimport { fail } from '../util/assert';\nimport { newAsyncQueue } from '../util/async_queue_impl';\nimport { cast } from '../util/input_validation';\nimport { Deferred } from '../util/promise';\n\nimport { getDatastore } from './components';\nimport { Firestore } from './database';\nimport { FieldPath } from './field_path';\nimport {\n  DocumentData,\n  DocumentReference,\n  PartialWithFieldValue,\n  SetOptions,\n  UpdateData,\n  WithFieldValue\n} from './reference';\nimport {\n  applyFirestoreDataConverter,\n  LiteUserDataWriter\n} from './reference_impl';\nimport { DocumentSnapshot } from './snapshot';\nimport { TransactionOptions } from './transaction_options';\nimport {\n  newUserDataReader,\n  parseSetData,\n  parseUpdateData,\n  parseUpdateVarargs,\n  UserDataReader\n} from './user_data_reader';\nimport { validateReference } from './write_batch';\n\n// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\n// legacy SDK.\n\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nexport class Transaction {\n  // This is the tree-shakeable version of the Transaction class used in the\n  // legacy SDK. The class is a close copy but takes different input and output\n  // types. The firestore-exp SDK further extends this class to return its API\n  // type.\n\n  private readonly _dataReader: UserDataReader;\n\n  /** @hideconstructor */\n  constructor(\n    protected readonly _firestore: Firestore,\n    private readonly _transaction: InternalTransaction\n  ) {\n    this._dataReader = newUserDataReader(_firestore);\n  }\n\n  /**\n   * Reads the document referenced by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be read.\n   * @returns A `DocumentSnapshot` with the read data.\n   */\n  get<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>\n  ): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n    const ref = validateReference(documentRef, this._firestore);\n    const userDataWriter = new LiteUserDataWriter(this._firestore);\n    return this._transaction.lookup([ref._key]).then(docs => {\n      if (!docs || docs.length !== 1) {\n        return fail(0x5de9, 'Mismatch in docs returned from document lookup.');\n      }\n      const doc = docs[0];\n      if (doc.isFoundDocument()) {\n        return new DocumentSnapshot<AppModelType, DbModelType>(\n          this._firestore,\n          userDataWriter,\n          doc.key,\n          doc,\n          ref.converter\n        );\n      } else if (doc.isNoDocument()) {\n        return new DocumentSnapshot<AppModelType, DbModelType>(\n          this._firestore,\n          userDataWriter,\n          ref._key,\n          null,\n          ref.converter\n        );\n      } else {\n        throw fail(\n          0x4801,\n          'BatchGetDocumentsRequest returned unexpected document',\n          {\n            doc\n          }\n        );\n      }\n    });\n  }\n\n  /**\n   * Writes to the document referred to by the provided {@link\n   * DocumentReference}. If the document does not exist yet, it will be created.\n   *\n   * @param documentRef - A reference to the document to be set.\n   * @param data - An object of the fields and values for the document.\n   * @throws Error - If the provided input is not a valid Firestore document.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: WithFieldValue<AppModelType>\n  ): this;\n  /**\n   * Writes to the document referred to by the provided {@link\n   * DocumentReference}. If the document does not exist yet, it will be created.\n   * If you provide `merge` or `mergeFields`, the provided data can be merged\n   * into an existing document.\n   *\n   * @param documentRef - A reference to the document to be set.\n   * @param data - An object of the fields and values for the document.\n   * @param options - An object to configure the set behavior.\n   * @throws Error - If the provided input is not a valid Firestore document.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: PartialWithFieldValue<AppModelType>,\n    options: SetOptions\n  ): this;\n  set<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    value: PartialWithFieldValue<AppModelType>,\n    options?: SetOptions\n  ): this {\n    const ref = validateReference(documentRef, this._firestore);\n    const convertedValue = applyFirestoreDataConverter(\n      ref.converter,\n      value,\n      options\n    );\n    const parsed = parseSetData(\n      this._dataReader,\n      'Transaction.set',\n      ref._key,\n      convertedValue,\n      ref.converter !== null,\n      options\n    );\n    this._transaction.set(ref._key, parsed);\n    return this;\n  }\n\n  /**\n   * Updates fields in the document referred to by the provided {@link\n   * DocumentReference}. The update will fail if applied to a document that does\n   * not exist.\n   *\n   * @param documentRef - A reference to the document to be updated.\n   * @param data - An object containing the fields and values with which to\n   * update the document. Fields can contain dots to reference nested fields\n   * within the document.\n   * @throws Error - If the provided input is not valid Firestore data.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    data: UpdateData<DbModelType>\n  ): this;\n  /**\n   * Updates fields in the document referred to by the provided {@link\n   * DocumentReference}. The update will fail if applied to a document that does\n   * not exist.\n   *\n   * Nested fields can be updated by providing dot-separated field path\n   * strings or by providing `FieldPath` objects.\n   *\n   * @param documentRef - A reference to the document to be updated.\n   * @param field - The first field to update.\n   * @param value - The first value.\n   * @param moreFieldsAndValues - Additional key/value pairs.\n   * @throws Error - If the provided input is not valid Firestore data.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    field: string | FieldPath,\n    value: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): this;\n  update<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>,\n    fieldOrUpdateData: string | FieldPath | UpdateData<DbModelType>,\n    value?: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): this {\n    const ref = validateReference(documentRef, this._firestore);\n\n    // For Compat types, we have to \"extract\" the underlying types before\n    // performing validation.\n    fieldOrUpdateData = getModularInstance(fieldOrUpdateData);\n\n    let parsed;\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof FieldPath\n    ) {\n      parsed = parseUpdateVarargs(\n        this._dataReader,\n        'Transaction.update',\n        ref._key,\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      parsed = parseUpdateData(\n        this._dataReader,\n        'Transaction.update',\n        ref._key,\n        fieldOrUpdateData\n      );\n    }\n\n    this._transaction.update(ref._key, parsed);\n    return this;\n  }\n\n  /**\n   * Deletes the document referred to by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be deleted.\n   * @returns This `Transaction` instance. Used for chaining method calls.\n   */\n  delete<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>\n  ): this {\n    const ref = validateReference(documentRef, this._firestore);\n    this._transaction.delete(ref._key);\n    return this;\n  }\n}\n\n/**\n * Executes the given `updateFunction` and then attempts to commit the changes\n * applied within the transaction. If any document read within the transaction\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\n * commit after 5 attempts, the transaction fails.\n *\n * The maximum number of writes allowed in a single transaction is 500.\n *\n * @param firestore - A reference to the Firestore database to run this\n * transaction against.\n * @param updateFunction - The function to execute within the transaction\n * context.\n * @param options - An options object to configure maximum number of attempts to\n * commit.\n * @returns If the transaction completed successfully or was explicitly aborted\n * (the `updateFunction` returned a failed promise), the promise returned by the\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\n * rejected promise with the corresponding failure error is returned.\n */\nexport function runTransaction<T>(\n  firestore: Firestore,\n  updateFunction: (transaction: Transaction) => Promise<T>,\n  options?: TransactionOptions\n): Promise<T> {\n  firestore = cast(firestore, Firestore);\n  const datastore = getDatastore(firestore);\n  const optionsWithDefaults: TransactionOptionsInternal = {\n    ...DEFAULT_TRANSACTION_OPTIONS,\n    ...options\n  };\n  validateTransactionOptions(optionsWithDefaults);\n  const deferred = new Deferred<T>();\n  new TransactionRunner<T>(\n    newAsyncQueue(),\n    datastore,\n    optionsWithDefaults,\n    internalTransaction =>\n      updateFunction(new Transaction(firestore, internalTransaction)),\n    deferred\n  ).run();\n  return deferred.promise;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { firestoreClientTransaction } from '../core/firestore_client';\nimport { Transaction as InternalTransaction } from '../core/transaction';\nimport {\n  TransactionOptions as TransactionOptionsInternal,\n  DEFAULT_TRANSACTION_OPTIONS,\n  validateTransactionOptions\n} from '../core/transaction_options';\nimport { DocumentData, DocumentReference } from '../lite-api/reference';\nimport { Transaction as LiteTransaction } from '../lite-api/transaction';\nimport { validateReference } from '../lite-api/write_batch';\nimport { cast } from '../util/input_validation';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport { DocumentSnapshot, SnapshotMetadata } from './snapshot';\nimport { TransactionOptions } from './transaction_options';\nimport { ExpUserDataWriter } from './user_data_writer';\n\n/**\n * A reference to a transaction.\n *\n * The `Transaction` object passed to a transaction's `updateFunction` provides\n * the methods to read and write data within the transaction context. See\n * {@link runTransaction}.\n */\nexport class Transaction extends LiteTransaction {\n  // This class implements the same logic as the Transaction API in the Lite SDK\n  // but is subclassed in order to return its own DocumentSnapshot types.\n\n  /** @hideconstructor */\n  constructor(\n    protected readonly _firestore: Firestore,\n    _transaction: InternalTransaction\n  ) {\n    super(_firestore, _transaction);\n  }\n\n  /**\n   * Reads the document referenced by the provided {@link DocumentReference}.\n   *\n   * @param documentRef - A reference to the document to be read.\n   * @returns A `DocumentSnapshot` with the read data.\n   */\n  get<AppModelType, DbModelType extends DocumentData>(\n    documentRef: DocumentReference<AppModelType, DbModelType>\n  ): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n    const ref = validateReference(documentRef, this._firestore);\n    const userDataWriter = new ExpUserDataWriter(this._firestore);\n    return super\n      .get(documentRef)\n      .then(\n        liteDocumentSnapshot =>\n          new DocumentSnapshot(\n            this._firestore,\n            userDataWriter,\n            ref._key,\n            liteDocumentSnapshot._document,\n            new SnapshotMetadata(\n              /* hasPendingWrites= */ false,\n              /* fromCache= */ false\n            ),\n            ref.converter\n          )\n      );\n  }\n}\n\n/**\n * Executes the given `updateFunction` and then attempts to commit the changes\n * applied within the transaction. If any document read within the transaction\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\n * commit after 5 attempts, the transaction fails.\n *\n * The maximum number of writes allowed in a single transaction is 500.\n *\n * @param firestore - A reference to the Firestore database to run this\n * transaction against.\n * @param updateFunction - The function to execute within the transaction\n * context.\n * @param options - An options object to configure maximum number of attempts to\n * commit.\n * @returns If the transaction completed successfully or was explicitly aborted\n * (the `updateFunction` returned a failed promise), the promise returned by the\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\n * rejected promise with the corresponding failure error is returned.\n */\nexport function runTransaction<T>(\n  firestore: Firestore,\n  updateFunction: (transaction: Transaction) => Promise<T>,\n  options?: TransactionOptions\n): Promise<T> {\n  firestore = cast(firestore, Firestore);\n  const optionsWithDefaults: TransactionOptionsInternal = {\n    ...DEFAULT_TRANSACTION_OPTIONS,\n    ...options\n  };\n  validateTransactionOptions(optionsWithDefaults);\n  const client = ensureFirestoreConfigured(firestore);\n  return firestoreClientTransaction(\n    client,\n    internalTransaction =>\n      updateFunction(new Transaction(firestore, internalTransaction)),\n    optionsWithDefaults\n  );\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getModularInstance } from '@firebase/util';\n\nimport { loadBundle, namedQuery } from '../api/database';\nimport {\n  CompleteFn,\n  ErrorFn,\n  isPartialObserver,\n  NextFn,\n  PartialObserver\n} from '../api/observer';\nimport { ListenerDataSource } from '../core/event_manager';\nimport {\n  firestoreClientAddSnapshotsInSyncListener,\n  firestoreClientGetDocumentFromLocalCache,\n  firestoreClientGetDocumentsFromLocalCache,\n  firestoreClientGetDocumentsViaSnapshotListener,\n  firestoreClientGetDocumentViaSnapshotListener,\n  firestoreClientListen,\n  firestoreClientWrite\n} from '../core/firestore_client';\nimport { newQueryForPath, Query as InternalQuery } from '../core/query';\nimport { ViewSnapshot } from '../core/view_snapshot';\nimport { FieldPath } from '../lite-api/field_path';\nimport { validateHasExplicitOrderByForLimitToLast } from '../lite-api/query';\nimport {\n  CollectionReference,\n  doc,\n  DocumentData,\n  DocumentReference,\n  PartialWithFieldValue,\n  Query,\n  SetOptions,\n  UpdateData,\n  WithFieldValue\n} from '../lite-api/reference';\nimport { applyFirestoreDataConverter } from '../lite-api/reference_impl';\nimport {\n  newUserDataReader,\n  ParsedUpdateData,\n  parseSetData,\n  parseUpdateData,\n  parseUpdateVarargs\n} from '../lite-api/user_data_reader';\nimport { DocumentKey } from '../model/document_key';\nimport { DeleteMutation, Mutation, Precondition } from '../model/mutation';\nimport { debugAssert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { cast } from '../util/input_validation';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport {\n  DocumentSnapshot,\n  FirestoreDataConverter,\n  QuerySnapshot,\n  SnapshotMetadata\n} from './snapshot';\nimport { ExpUserDataWriter } from './user_data_writer';\n\n/**\n * An options object that can be passed to {@link (onSnapshot:1)} and {@link\n * QuerySnapshot.docChanges} to control which types of changes to include in the\n * result set.\n */\nexport interface SnapshotListenOptions {\n  /**\n   * Include a change even if only the metadata of the query or of a document\n   * changed. Default is false.\n   */\n  readonly includeMetadataChanges?: boolean;\n\n  /**\n   * Set the source the query listens to. Default to \"default\", which\n   * listens to both cache and server.\n   */\n  readonly source?: ListenSource;\n}\n\n/**\n * Describe the source a query listens to.\n *\n * Set to `default` to listen to both cache and server changes. Set to `cache`\n * to listen to changes in cache only.\n */\nexport type ListenSource = 'default' | 'cache';\n\n/**\n * Reads the document referred to by this `DocumentReference`.\n *\n * Note: `getDoc()` attempts to provide up-to-date data when possible by waiting\n * for data from the server, but it may return cached data or fail if you are\n * offline and the server cannot be reached. To specify this behavior, invoke\n * {@link getDocFromCache} or {@link getDocFromServer}.\n *\n * @param reference - The reference of the document to fetch.\n * @returns A Promise resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nexport function getDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const firestore = cast(reference.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n\n  return firestoreClientGetDocumentViaSnapshotListener(\n    client,\n    reference._key\n  ).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\n\n/**\n * Reads the document referred to by this `DocumentReference` from cache.\n * Returns an error if the document is not currently cached.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nexport function getDocFromCache<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const firestore = cast(reference.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  const userDataWriter = new ExpUserDataWriter(firestore);\n\n  return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(\n    doc =>\n      new DocumentSnapshot<AppModelType, DbModelType>(\n        firestore,\n        userDataWriter,\n        reference._key,\n        doc,\n        new SnapshotMetadata(\n          doc !== null && doc.hasLocalMutations,\n          /* fromCache= */ true\n        ),\n        reference.converter\n      )\n  );\n}\n\n/**\n * Reads the document referred to by this `DocumentReference` from the server.\n * Returns an error if the network is not available.\n *\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\n * current document contents.\n */\nexport function getDocFromServer<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<DocumentSnapshot<AppModelType, DbModelType>> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const firestore = cast(reference.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n\n  return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {\n    source: 'server'\n  }).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\n}\n\n/**\n * Executes the query and returns the results as a `QuerySnapshot`.\n *\n * Note: `getDocs()` attempts to provide up-to-date data when possible by\n * waiting for data from the server, but it may return cached data or fail if\n * you are offline and the server cannot be reached. To specify this behavior,\n * invoke {@link getDocsFromCache} or {@link getDocsFromServer}.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nexport function getDocs<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>\n): Promise<QuerySnapshot<AppModelType, DbModelType>> {\n  query = cast<Query<AppModelType, DbModelType>>(query, Query);\n  const firestore = cast(query.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  const userDataWriter = new ExpUserDataWriter(firestore);\n\n  validateHasExplicitOrderByForLimitToLast(query._query);\n  return firestoreClientGetDocumentsViaSnapshotListener(\n    client,\n    query._query\n  ).then(\n    snapshot =>\n      new QuerySnapshot<AppModelType, DbModelType>(\n        firestore,\n        userDataWriter,\n        query,\n        snapshot\n      )\n  );\n}\n\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from cache.\n * Returns an empty result set if no documents matching the query are currently\n * cached.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nexport function getDocsFromCache<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>\n): Promise<QuerySnapshot<AppModelType, DbModelType>> {\n  query = cast<Query<AppModelType, DbModelType>>(query, Query);\n  const firestore = cast(query.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  const userDataWriter = new ExpUserDataWriter(firestore);\n\n  return firestoreClientGetDocumentsFromLocalCache(client, query._query).then(\n    snapshot =>\n      new QuerySnapshot<AppModelType, DbModelType>(\n        firestore,\n        userDataWriter,\n        query,\n        snapshot\n      )\n  );\n}\n\n/**\n * Executes the query and returns the results as a `QuerySnapshot` from the\n * server. Returns an error if the network is not available.\n *\n * @returns A `Promise` that will be resolved with the results of the query.\n */\nexport function getDocsFromServer<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  query: Query<AppModelType, DbModelType>\n): Promise<QuerySnapshot<AppModelType, DbModelType>> {\n  query = cast<Query<AppModelType, DbModelType>>(query, Query);\n  const firestore = cast(query.firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  const userDataWriter = new ExpUserDataWriter(firestore);\n\n  return firestoreClientGetDocumentsViaSnapshotListener(client, query._query, {\n    source: 'server'\n  }).then(\n    snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot)\n  );\n}\n\n/**\n * Writes to the document referred to by this `DocumentReference`. If the\n * document does not yet exist, it will be created.\n *\n * @param reference - A reference to the document to write.\n * @param data - A map of the fields and values for the document.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend (note that it won't resolve while you're offline).\n */\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: WithFieldValue<AppModelType>\n): Promise<void>;\n/**\n * Writes to the document referred to by the specified `DocumentReference`. If\n * the document does not yet exist, it will be created. If you provide `merge`\n * or `mergeFields`, the provided data can be merged into an existing document.\n *\n * @param reference - A reference to the document to write.\n * @param data - A map of the fields and values for the document.\n * @param options - An object to configure the set behavior.\n * @returns A Promise resolved once the data has been successfully written\n * to the backend (note that it won't resolve while you're offline).\n */\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: PartialWithFieldValue<AppModelType>,\n  options: SetOptions\n): Promise<void>;\nexport function setDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: PartialWithFieldValue<AppModelType>,\n  options?: SetOptions\n): Promise<void> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const firestore = cast(reference.firestore, Firestore);\n\n  const convertedValue = applyFirestoreDataConverter(\n    reference.converter,\n    data as WithFieldValue<AppModelType>,\n    options\n  );\n  const dataReader = newUserDataReader(firestore);\n  const parsed = parseSetData(\n    dataReader,\n    'setDoc',\n    reference._key,\n    convertedValue,\n    reference.converter !== null,\n    options\n  );\n\n  const mutation = parsed.toMutation(reference._key, Precondition.none());\n  return executeWrite(firestore, [mutation]);\n}\n\n/**\n * Updates fields in the document referred to by the specified\n * `DocumentReference`. The update will fail if applied to a document that does\n * not exist.\n *\n * @param reference - A reference to the document to update.\n * @param data - An object containing the fields and values with which to\n * update the document. Fields can contain dots to reference nested fields\n * within the document.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend (note that it won't resolve while you're offline).\n */\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  data: UpdateData<DbModelType>\n): Promise<void>;\n/**\n * Updates fields in the document referred to by the specified\n * `DocumentReference` The update will fail if applied to a document that does\n * not exist.\n *\n * Nested fields can be updated by providing dot-separated field path\n * strings or by providing `FieldPath` objects.\n *\n * @param reference - A reference to the document to update.\n * @param field - The first field to update.\n * @param value - The first value.\n * @param moreFieldsAndValues - Additional key value pairs.\n * @returns A `Promise` resolved once the data has been successfully written\n * to the backend (note that it won't resolve while you're offline).\n */\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  field: string | FieldPath,\n  value: unknown,\n  ...moreFieldsAndValues: unknown[]\n): Promise<void>;\nexport function updateDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<unknown>,\n  fieldOrUpdateData: string | FieldPath | UpdateData<DbModelType>,\n  value?: unknown,\n  ...moreFieldsAndValues: unknown[]\n): Promise<void> {\n  reference = cast<DocumentReference<AppModelType, DbModelType>>(\n    reference,\n    DocumentReference\n  );\n  const firestore = cast(reference.firestore, Firestore);\n\n  const dataReader = newUserDataReader(firestore);\n\n  // For Compat types, we have to \"extract\" the underlying types before\n  // performing validation.\n  fieldOrUpdateData = getModularInstance(fieldOrUpdateData);\n\n  let parsed: ParsedUpdateData;\n  if (\n    typeof fieldOrUpdateData === 'string' ||\n    fieldOrUpdateData instanceof FieldPath\n  ) {\n    parsed = parseUpdateVarargs(\n      dataReader,\n      'updateDoc',\n      reference._key,\n      fieldOrUpdateData,\n      value,\n      moreFieldsAndValues\n    );\n  } else {\n    parsed = parseUpdateData(\n      dataReader,\n      'updateDoc',\n      reference._key,\n      fieldOrUpdateData\n    );\n  }\n\n  const mutation = parsed.toMutation(reference._key, Precondition.exists(true));\n  return executeWrite(firestore, [mutation]);\n}\n\n/**\n * Deletes the document referred to by the specified `DocumentReference`.\n *\n * @param reference - A reference to the document to delete.\n * @returns A Promise resolved once the document has been successfully\n * deleted from the backend (note that it won't resolve while you're offline).\n */\nexport function deleteDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>\n): Promise<void> {\n  const firestore = cast(reference.firestore, Firestore);\n  const mutations = [new DeleteMutation(reference._key, Precondition.none())];\n  return executeWrite(firestore, mutations);\n}\n\n/**\n * Add a new document to specified `CollectionReference` with the given data,\n * assigning it a document ID automatically.\n *\n * @param reference - A reference to the collection to add this document to.\n * @param data - An Object containing the data for the new document.\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\n * newly created document after it has been written to the backend (Note that it\n * won't resolve while you're offline).\n */\nexport function addDoc<AppModelType, DbModelType extends DocumentData>(\n  reference: CollectionReference<AppModelType, DbModelType>,\n  data: WithFieldValue<AppModelType>\n): Promise<DocumentReference<AppModelType, DbModelType>> {\n  const firestore = cast(reference.firestore, Firestore);\n\n  const docRef = doc(reference);\n  const convertedValue = applyFirestoreDataConverter(reference.converter, data);\n\n  const dataReader = newUserDataReader(reference.firestore);\n  const parsed = parseSetData(\n    dataReader,\n    'addDoc',\n    docRef._key,\n    convertedValue,\n    reference.converter !== null,\n    {}\n  );\n\n  const mutation = parsed.toMutation(docRef._key, Precondition.exists(false));\n  return executeWrite(firestore, [mutation]).then(() => docRef);\n}\n\n/**\n * A function returned by `onSnapshot()` that removes the listener when invoked.\n */\nexport interface Unsubscribe {\n  /** Removes the listener when invoked. */\n  (): void;\n}\n\n// TODO(firestorexp): Make sure these overloads are tested via the Firestore\n// integration tests\n\n/**\n * Attaches a listener for `DocumentSnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param reference - A reference to the document to listen to.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  observer: {\n    next?: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  }\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param reference - A reference to the document to listen to.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  options: SnapshotListenOptions,\n  observer: {\n    next?: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  }\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param reference - A reference to the document to listen to.\n * @param onNext - A callback to be called every time a new `DocumentSnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param reference - A reference to the document to listen to.\n * @param options - Options controlling the listen behavior.\n * @param onNext - A callback to be called every time a new `DocumentSnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  reference: DocumentReference<AppModelType, DbModelType>,\n  options: SnapshotListenOptions,\n  onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks. The\n * listener can be cancelled by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param query - The query to listen to.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  observer: {\n    next?: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  }\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks. The\n * listener can be cancelled by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param query - The query to listen to.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  options: SnapshotListenOptions,\n  observer: {\n    next?: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  }\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks. The\n * listener can be cancelled by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param query - The query to listen to.\n * @param onNext - A callback to be called every time a new `QuerySnapshot` is available.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events. You may either pass individual `onNext` and\n * `onError` callbacks or pass a single observer object with `next` and `error` callbacks. The\n * listener can be cancelled by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param query - The query to listen to.\n * @param options - Options controlling the listen behavior.\n * @param onNext - A callback to be called every time a new `QuerySnapshot` is available.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  query: Query<AppModelType, DbModelType>,\n  options: SnapshotListenOptions,\n  onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void\n): Unsubscribe;\nexport function onSnapshot<AppModelType, DbModelType extends DocumentData>(\n  reference:\n    | Query<AppModelType, DbModelType>\n    | DocumentReference<AppModelType, DbModelType>,\n  ...args: unknown[]\n): Unsubscribe {\n  // onSnapshot for Query or Document.\n  reference = getModularInstance(reference);\n  let options: SnapshotListenOptions = {\n    includeMetadataChanges: false,\n    source: 'default'\n  };\n  let currArg = 0;\n  if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\n    options = args[currArg++] as SnapshotListenOptions;\n  }\n\n  const internalOptions = {\n    includeMetadataChanges: options.includeMetadataChanges,\n    source: options.source as ListenerDataSource\n  };\n\n  if (isPartialObserver(args[currArg])) {\n    const userObserver = args[currArg] as PartialObserver<\n      QuerySnapshot<AppModelType, DbModelType>\n    >;\n    args[currArg] = userObserver.next?.bind(userObserver);\n    args[currArg + 1] = userObserver.error?.bind(userObserver);\n    args[currArg + 2] = userObserver.complete?.bind(userObserver);\n  }\n\n  let observer: PartialObserver<ViewSnapshot>;\n  let firestore: Firestore;\n  let internalQuery: InternalQuery;\n\n  if (reference instanceof DocumentReference) {\n    firestore = cast(reference.firestore, Firestore);\n    internalQuery = newQueryForPath(reference._key.path);\n\n    observer = {\n      next: snapshot => {\n        if (args[currArg]) {\n          (\n            args[currArg] as NextFn<DocumentSnapshot<AppModelType, DbModelType>>\n          )(\n            convertToDocSnapshot(\n              firestore,\n              reference as DocumentReference<AppModelType, DbModelType>,\n              snapshot\n            )\n          );\n        }\n      },\n      error: args[currArg + 1] as ErrorFn,\n      complete: args[currArg + 2] as CompleteFn\n    };\n  } else {\n    const query = cast<Query<AppModelType, DbModelType>>(reference, Query);\n    firestore = cast(query.firestore, Firestore);\n    internalQuery = query._query;\n    const userDataWriter = new ExpUserDataWriter(firestore);\n    observer = {\n      next: snapshot => {\n        if (args[currArg]) {\n          (args[currArg] as NextFn<QuerySnapshot<AppModelType, DbModelType>>)(\n            new QuerySnapshot(firestore, userDataWriter, query, snapshot)\n          );\n        }\n      },\n      error: args[currArg + 1] as ErrorFn,\n      complete: args[currArg + 2] as CompleteFn\n    };\n\n    validateHasExplicitOrderByForLimitToLast(reference._query);\n  }\n\n  const client = ensureFirestoreConfigured(firestore);\n  return firestoreClientListen(\n    client,\n    internalQuery,\n    internalOptions,\n    observer\n  );\n}\n\n/**\n * Attaches a listener for `QuerySnapshot` events based on data generated by invoking\n * {@link QuerySnapshot.toJSON} You may either pass individual `onNext` and `onError` callbacks or\n * pass a single observer object with `next` and `error` callbacks. The listener can be cancelled by\n * calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link QuerySnapshot.toJSON}.\n * @param onNext - A callback to be called every time a new `QuerySnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void,\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events based on data generated by invoking\n * {@link DocumentSnapshot.toJSON}. You may either pass individual `onNext` and `onError` callbacks or\n * pass a single observer object with `next` and `error` callbacks. The listener can be cancelled by\n * calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link DocumentSnapshot.toJSON}.\n * @param onNext - A callback to be called every time a new `DocumentSnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are\n * never ending.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void,\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events based on data generated by invoking\n * {@link QuerySnapshot.toJSON}. You may either pass individual `onNext` and `onError` callbacks or\n * pass a single observer object with `next` and `error` callbacks. The listener can be cancelled by\n * calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link QuerySnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param onNext - A callback to be called every time a new `QuerySnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  options: SnapshotListenOptions,\n  onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void,\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events based on data generated by invoking\n * {@link DocumentSnapshot.toJSON}. You may either pass individual `onNext` and `onError` callbacks\n * or pass a single observer object with `next` and `error` callbacks. The listener can be cancelled\n * by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link DocumentSnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param onNext - A callback to be called every time a new `DocumentSnapshot` is available.\n * @param onError - A callback to be called if the listen fails or is cancelled. No further\n * callbacks will occur.\n * @param onCompletion - Can be provided, but will not be called since streams are never ending.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  options: SnapshotListenOptions,\n  onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void,\n  onError?: (error: FirestoreError) => void,\n  onCompletion?: () => void,\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events based on QuerySnapshot data generated by invoking\n * {@link QuerySnapshot.toJSON}. You may either pass individual `onNext` and `onError` callbacks or\n * pass a single observer object with `next` and `error` callbacks. The listener can be cancelled by\n * calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link QuerySnapshot.toJSON}.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  observer: {\n    next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events based on data generated by invoking\n * {@link DocumentSnapshot.toJSON} You may either pass individual `onNext` and `onError` callbacks\n * or pass a single observer object with `next` and `error` callbacks. The listener can be cancelled\n * by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link DocumentSnapshot.toJSON}.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  observer: {\n    next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `QuerySnapshot` events based on QuerySnapshot data generated by invoking\n * {@link QuerySnapshot.toJSON} You may either pass individual `onNext` and `onError` callbacks or\n * pass a single observer object with `next` and `error` callbacks. The listener can be cancelled by\n * calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link QuerySnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel\n * the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  options: SnapshotListenOptions,\n  observer: {\n    next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\n/**\n * Attaches a listener for `DocumentSnapshot` events based on QuerySnapshot data generated by\n * invoking {@link DocumentSnapshot.toJSON} You may either pass individual `onNext` and `onError`\n * callbacks or pass a single observer object with `next` and `error` callbacks. The listener can be\n * cancelled by calling the function that is returned when `onSnapshot` is called.\n *\n * NOTE: Although an `onCompletion` callback can be provided, it will never be called because the\n * snapshot stream is never-ending.\n *\n * @param firestore - The {@link Firestore} instance to enable the listener for.\n * @param snapshotJson - A JSON object generated by invoking {@link DocumentSnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot listener.\n */\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  firestore: Firestore,\n  snapshotJson: object,\n  options: SnapshotListenOptions,\n  observer: {\n    next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe;\nexport function onSnapshotResume<\n  AppModelType,\n  DbModelType extends DocumentData\n>(reference: Firestore, snapshotJson: object, ...args: unknown[]): Unsubscribe {\n  const db = getModularInstance(reference);\n  const json = normalizeSnapshotJsonFields(snapshotJson);\n  if (json.error) {\n    throw new FirestoreError(Code.INVALID_ARGUMENT, json.error);\n  }\n  let curArg = 0;\n  let options: SnapshotListenOptions | undefined = undefined;\n  if (typeof args[curArg] === 'object' && !isPartialObserver(args[curArg])) {\n    options = args[curArg++] as SnapshotListenOptions;\n  }\n\n  if (json.bundleSource === 'QuerySnapshot') {\n    let observer: {\n      next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n      error?: (error: FirestoreError) => void;\n      complete?: () => void;\n    } | null = null;\n    if (typeof args[curArg] === 'object' && isPartialObserver(args[curArg])) {\n      const userObserver = args[curArg++] as PartialObserver<\n        QuerySnapshot<AppModelType, DbModelType>\n      >;\n      observer = {\n        next: userObserver.next!,\n        error: userObserver.error,\n        complete: userObserver.complete\n      };\n    } else {\n      observer = {\n        next: args[curArg++] as (\n          snapshot: QuerySnapshot<AppModelType, DbModelType>\n        ) => void,\n        error: args[curArg++] as (error: FirestoreError) => void,\n        complete: args[curArg++] as () => void\n      };\n    }\n    return onSnapshotQuerySnapshotBundle(\n      db,\n      json,\n      options,\n      observer!,\n      args[curArg] as FirestoreDataConverter<DbModelType>\n    );\n  } else if (json.bundleSource === 'DocumentSnapshot') {\n    let observer: {\n      next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n      error?: (error: FirestoreError) => void;\n      complete?: () => void;\n    } | null = null;\n    if (typeof args[curArg] === 'object' && isPartialObserver(args[curArg])) {\n      const userObserver = args[curArg++] as PartialObserver<\n        DocumentSnapshot<AppModelType, DbModelType>\n      >;\n      observer = {\n        next: userObserver.next!,\n        error: userObserver.error,\n        complete: userObserver.complete\n      };\n    } else {\n      observer = {\n        next: args[curArg++] as (\n          snapshot: DocumentSnapshot<AppModelType, DbModelType>\n        ) => void,\n        error: args[curArg++] as (error: FirestoreError) => void,\n        complete: args[curArg++] as () => void\n      };\n    }\n    return onSnapshotDocumentSnapshotBundle(\n      db,\n      json,\n      options,\n      observer!,\n      args[curArg] as FirestoreDataConverter<DbModelType>\n    );\n  } else {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `unsupported bundle source: ${json.bundleSource}`\n    );\n  }\n}\n\n// TODO(firestorexp): Make sure these overloads are tested via the Firestore\n// integration tests\n\n/**\n * Attaches a listener for a snapshots-in-sync event. The snapshots-in-sync\n * event indicates that all listeners affected by a given change have fired,\n * even if a single server-generated change affects multiple listeners.\n *\n * NOTE: The snapshots-in-sync event only indicates that listeners are in sync\n * with each other, but does not relate to whether those snapshots are in sync\n * with the server. Use SnapshotMetadata in the individual listeners to\n * determine if a snapshot is from the cache or the server.\n *\n * @param firestore - The instance of Firestore for synchronizing snapshots.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @returns An unsubscribe function that can be called to cancel the snapshot\n * listener.\n */\nexport function onSnapshotsInSync(\n  firestore: Firestore,\n  observer: {\n    next?: (value: void) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  }\n): Unsubscribe;\n/**\n * Attaches a listener for a snapshots-in-sync event. The snapshots-in-sync\n * event indicates that all listeners affected by a given change have fired,\n * even if a single server-generated change affects multiple listeners.\n *\n * NOTE: The snapshots-in-sync event only indicates that listeners are in sync\n * with each other, but does not relate to whether those snapshots are in sync\n * with the server. Use `SnapshotMetadata` in the individual listeners to\n * determine if a snapshot is from the cache or the server.\n *\n * @param firestore - The `Firestore` instance for synchronizing snapshots.\n * @param onSync - A callback to be called every time all snapshot listeners are\n * in sync with each other.\n * @returns An unsubscribe function that can be called to cancel the snapshot\n * listener.\n */\nexport function onSnapshotsInSync(\n  firestore: Firestore,\n  onSync: () => void\n): Unsubscribe;\nexport function onSnapshotsInSync(\n  firestore: Firestore,\n  arg: unknown\n): Unsubscribe {\n  firestore = cast(firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  const observer = isPartialObserver(arg)\n    ? (arg as PartialObserver<void>)\n    : {\n        next: arg as () => void\n      };\n\n  return firestoreClientAddSnapshotsInSyncListener(client, observer);\n}\n\n/**\n * Locally writes `mutations` on the async queue.\n * @internal\n */\nexport function executeWrite(\n  firestore: Firestore,\n  mutations: Mutation[]\n): Promise<void> {\n  const client = ensureFirestoreConfigured(firestore);\n  return firestoreClientWrite(client, mutations);\n}\n\n/**\n * Converts a {@link ViewSnapshot} that contains the single document specified by `ref`\n * to a {@link DocumentSnapshot}.\n */\nfunction convertToDocSnapshot<AppModelType, DbModelType extends DocumentData>(\n  firestore: Firestore,\n  ref: DocumentReference<AppModelType, DbModelType>,\n  snapshot: ViewSnapshot\n): DocumentSnapshot<AppModelType, DbModelType> {\n  debugAssert(\n    snapshot.docs.size <= 1,\n    'Expected zero or a single result on a document-only query'\n  );\n  const doc = snapshot.docs.get(ref._key);\n\n  const userDataWriter = new ExpUserDataWriter(firestore);\n  return new DocumentSnapshot<AppModelType, DbModelType>(\n    firestore,\n    userDataWriter,\n    ref._key,\n    doc,\n    new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache),\n    ref.converter\n  );\n}\n\n/**\n * Ensures the data required to construct an {@link onSnapshot} listener exist in a `snapshotJson`\n * object that originates from {@link DocumentSnapshot.toJSON} or {@link Querysnapshot.toJSON}. The\n * data is normalized into a typed object.\n *\n * @param snapshotJson - The JSON object that the app provided to {@link onSnapshot}.\n * @returns A normalized object that contains all of the required bundle JSON fields. If\n * {@link snapshotJson} doesn't contain the required fields, or if the fields exist as empty\n * strings, then the {@link snapshotJson.error} field will be a non empty string.\n *\n * @internal\n */\nfunction normalizeSnapshotJsonFields(snapshotJson: object): {\n  bundle: string;\n  bundleName: string;\n  bundleSource: string;\n  error?: string;\n} {\n  const result: {\n    bundle: string;\n    bundleName: string;\n    bundleSource: string;\n    error?: string;\n  } = {\n    bundle: '',\n    bundleName: '',\n    bundleSource: ''\n  };\n  const requiredKeys = ['bundle', 'bundleName', 'bundleSource'];\n  for (const key of requiredKeys) {\n    if (!(key in snapshotJson)) {\n      result.error = `snapshotJson missing required field: ${key}`;\n      break;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const value = (snapshotJson as any)[key];\n    if (typeof value !== 'string') {\n      result.error = `snapshotJson field '${key}' must be a string.`;\n      break;\n    }\n    if (value.length === 0) {\n      result.error = `snapshotJson field '${key}' cannot be an empty string.`;\n      break;\n    }\n    if (key === 'bundle') {\n      result.bundle = value;\n    } else if (key === 'bundleName') {\n      result.bundleName = value;\n    } else if (key === 'bundleSource') {\n      result.bundleSource = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Loads the bundle in a separate task and then invokes {@link onSnapshot} with a\n * {@link DocumentReference} for the document in the bundle.\n *\n * @param firestore - The {@link Firestore} instance for the {@link onSnapshot} operation request.\n * @param json - The JSON bundle to load, produced by {@link DocumentSnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot\n * listener.\n *\n * @internal\n */\nfunction onSnapshotDocumentSnapshotBundle<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  db: Firestore,\n  json: { bundle: string; bundleName: string; bundleSource: string },\n  options: SnapshotListenOptions | undefined,\n  observer: {\n    next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe {\n  let unsubscribed: boolean = false;\n  let internalUnsubscribe: Unsubscribe | undefined;\n  const loadTask = loadBundle(db, json.bundle);\n  loadTask\n    .then(() => {\n      if (!unsubscribed) {\n        const docReference = new DocumentReference(\n          db,\n          converter ? converter : null,\n          DocumentKey.fromPath(json.bundleName)\n        );\n        internalUnsubscribe = onSnapshot(\n          docReference as DocumentReference<AppModelType, DbModelType>,\n          options ? options : {},\n          observer\n        );\n      }\n    })\n    .catch(e => {\n      if (observer.error) {\n        observer.error(e);\n      }\n      return () => {};\n    });\n  return () => {\n    if (unsubscribed) {\n      return;\n    }\n    unsubscribed = true;\n    if (internalUnsubscribe) {\n      internalUnsubscribe();\n    }\n  };\n}\n\n/**\n * Loads the bundle in a separate task and then invokes {@link onSnapshot} with a\n * {@link Query} that represents the Query in the bundle.\n *\n * @param firestore - The {@link Firestore} instance for the {@link onSnapshot} operation request.\n * @param json - The JSON bundle to load, produced by {@link QuerySnapshot.toJSON}.\n * @param options - Options controlling the listen behavior.\n * @param observer - A single object containing `next` and `error` callbacks.\n * @param converter - An optional object that converts objects from Firestore before the onNext\n * listener is invoked.\n * @returns An unsubscribe function that can be called to cancel the snapshot\n * listener.\n *\n * @internal\n */\nfunction onSnapshotQuerySnapshotBundle<\n  AppModelType,\n  DbModelType extends DocumentData\n>(\n  db: Firestore,\n  json: { bundle: string; bundleName: string; bundleSource: string },\n  options: SnapshotListenOptions | undefined,\n  observer: {\n    next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;\n    error?: (error: FirestoreError) => void;\n    complete?: () => void;\n  },\n  converter?: FirestoreDataConverter<DbModelType>\n): Unsubscribe {\n  let unsubscribed: boolean = false;\n  let internalUnsubscribe: Unsubscribe | undefined;\n  const loadTask = loadBundle(db, json.bundle);\n  loadTask\n    .then(() => namedQuery(db, json.bundleName))\n    .then(query => {\n      if (query && !unsubscribed) {\n        const realQuery: Query = (query as Query)!;\n        if (converter) {\n          realQuery.withConverter(converter);\n        }\n        internalUnsubscribe = onSnapshot(\n          query as Query<AppModelType, DbModelType>,\n          options ? options : {},\n          observer\n        );\n      }\n    })\n    .catch(e => {\n      if (observer.error) {\n        observer.error(e);\n      }\n      return () => {};\n    });\n  return () => {\n    if (unsubscribed) {\n      return;\n    }\n    unsubscribed = true;\n    if (internalUnsubscribe) {\n      internalUnsubscribe();\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { WriteBatch } from '../lite-api/write_batch';\nimport { cast } from '../util/input_validation';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport { executeWrite } from './reference_impl';\n\nexport { WriteBatch };\n\n/**\n * Creates a write batch, used for performing multiple writes as a single\n * atomic operation. The maximum number of writes allowed in a single {@link WriteBatch}\n * is 500.\n *\n * Unlike transactions, write batches are persisted offline and therefore are\n * preferable when you don't need to condition your writes on read data.\n *\n * @returns A {@link WriteBatch} that can be used to atomically execute multiple\n * writes.\n */\nexport function writeBatch(firestore: Firestore): WriteBatch {\n  firestore = cast(firestore, Firestore);\n  ensureFirestoreConfigured(firestore);\n  return new WriteBatch(firestore, mutations =>\n    executeWrite(firestore, mutations)\n  );\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { firestoreClientSetIndexConfiguration } from '../core/firestore_client';\nimport { fieldPathFromDotSeparatedString } from '../lite-api/user_data_reader';\nimport {\n  FieldIndex,\n  IndexKind,\n  IndexSegment,\n  IndexState\n} from '../model/field_index';\nimport { Code, FirestoreError } from '../util/error';\nimport { cast } from '../util/input_validation';\nimport { logWarn } from '../util/log';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\n\nexport {\n  connectFirestoreEmulator,\n  EmulatorMockTokenOptions\n} from '../lite-api/database';\n\n/**\n * A single field element in an index configuration.\n *\n * @deprecated Instead of creating cache indexes manually, consider using\n * `enablePersistentCacheIndexAutoCreation()` to let the SDK decide whether to\n * create cache indexes for queries running locally.\n *\n * @beta\n */\nexport interface IndexField {\n  /** The field path to index. */\n  readonly fieldPath: string;\n  /**\n   * What type of array index to create. Set to `CONTAINS` for `array-contains`\n   * and `array-contains-any` indexes.\n   *\n   * Only one of `arrayConfig` or `order` should be set;\n   */\n  readonly arrayConfig?: 'CONTAINS';\n  /**\n   * What type of array index to create. Set to `ASCENDING` or 'DESCENDING` for\n   * `==`, `!=`, `<=`, `<=`, `in` and `not-in` filters.\n   *\n   * Only one of `arrayConfig` or `order` should be set.\n   */\n  readonly order?: 'ASCENDING' | 'DESCENDING';\n\n  [key: string]: unknown;\n}\n\n/**\n * The SDK definition of a Firestore index.\n *\n * @deprecated Instead of creating cache indexes manually, consider using\n * `enablePersistentCacheIndexAutoCreation()` to let the SDK decide whether to\n * create cache indexes for queries running locally.\n *\n * @beta\n */\nexport interface Index {\n  /** The ID of the collection to index. */\n  readonly collectionGroup: string;\n  /** A list of fields to index. */\n  readonly fields?: IndexField[];\n\n  [key: string]: unknown;\n}\n\n/**\n * A list of Firestore indexes to speed up local query execution.\n *\n * See {@link https://firebase.google.com/docs/reference/firestore/indexes/#json_format | JSON Format}\n * for a description of the format of the index definition.\n *\n * @deprecated Instead of creating cache indexes manually, consider using\n * `enablePersistentCacheIndexAutoCreation()` to let the SDK decide whether to\n * create cache indexes for queries running locally.\n *\n * @beta\n */\nexport interface IndexConfiguration {\n  /** A list of all Firestore indexes. */\n  readonly indexes?: Index[];\n\n  [key: string]: unknown;\n}\n\n/**\n * Configures indexing for local query execution. Any previous index\n * configuration is overridden. The `Promise` resolves once the index\n * configuration has been persisted.\n *\n * The index entries themselves are created asynchronously. You can continue to\n * use queries that require indexing even if the indices are not yet available.\n * Query execution will automatically start using the index once the index\n * entries have been written.\n *\n * Indexes are only supported with IndexedDb persistence. If IndexedDb is not\n * enabled, any index configuration is ignored.\n *\n * @param firestore - The {@link Firestore} instance to configure indexes for.\n * @param configuration -The index definition.\n * @throws FirestoreError if the JSON format is invalid.\n * @returns A `Promise` that resolves once all indices are successfully\n * configured.\n *\n * @deprecated Instead of creating cache indexes manually, consider using\n * `enablePersistentCacheIndexAutoCreation()` to let the SDK decide whether to\n * create cache indexes for queries running locally.\n *\n * @beta\n */\nexport function setIndexConfiguration(\n  firestore: Firestore,\n  configuration: IndexConfiguration\n): Promise<void>;\n\n/**\n * Configures indexing for local query execution. Any previous index\n * configuration is overridden. The `Promise` resolves once the index\n * configuration has been persisted.\n *\n * The index entries themselves are created asynchronously. You can continue to\n * use queries that require indexing even if the indices are not yet available.\n * Query execution will automatically start using the index once the index\n * entries have been written.\n *\n * Indexes are only supported with IndexedDb persistence. Invoke either\n * `enableIndexedDbPersistence()` or `enableMultiTabIndexedDbPersistence()`\n * before setting an index configuration. If IndexedDb is not enabled, any\n * index configuration is ignored.\n *\n * The method accepts the JSON format exported by the Firebase CLI (`firebase\n * firestore:indexes`). If the JSON format is invalid, this method throws an\n * error.\n *\n * @param firestore - The {@link Firestore} instance to configure indexes for.\n * @param json -The JSON format exported by the Firebase CLI.\n * @throws FirestoreError if the JSON format is invalid.\n * @returns A `Promise` that resolves once all indices are successfully\n * configured.\n *\n * @deprecated Instead of creating cache indexes manually, consider using\n * `enablePersistentCacheIndexAutoCreation()` to let the SDK decide whether to\n * create cache indexes for queries running locally.\n *\n * @beta\n */\nexport function setIndexConfiguration(\n  firestore: Firestore,\n  json: string\n): Promise<void>;\n\nexport function setIndexConfiguration(\n  firestore: Firestore,\n  jsonOrConfiguration: string | IndexConfiguration\n): Promise<void> {\n  firestore = cast(firestore, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n  if (\n    !client._uninitializedComponentsProvider ||\n    client._uninitializedComponentsProvider._offline.kind === 'memory'\n  ) {\n    // PORTING NOTE: We don't return an error if the user has not enabled\n    // persistence since `enableIndexeddbPersistence()` can fail on the Web.\n    logWarn('Cannot enable indexes when persistence is disabled');\n    return Promise.resolve();\n  }\n  const parsedIndexes = parseIndexes(jsonOrConfiguration);\n  return firestoreClientSetIndexConfiguration(client, parsedIndexes);\n}\n\nexport function parseIndexes(\n  jsonOrConfiguration: string | IndexConfiguration\n): FieldIndex[] {\n  const indexConfiguration =\n    typeof jsonOrConfiguration === 'string'\n      ? (tryParseJson(jsonOrConfiguration) as IndexConfiguration)\n      : jsonOrConfiguration;\n  const parsedIndexes: FieldIndex[] = [];\n\n  if (Array.isArray(indexConfiguration.indexes)) {\n    for (const index of indexConfiguration.indexes) {\n      const collectionGroup = tryGetString(index, 'collectionGroup');\n\n      const segments: IndexSegment[] = [];\n      if (Array.isArray(index.fields)) {\n        for (const field of index.fields) {\n          const fieldPathString = tryGetString(field, 'fieldPath');\n          const fieldPath = fieldPathFromDotSeparatedString(\n            'setIndexConfiguration',\n            fieldPathString\n          );\n\n          if (field.arrayConfig === 'CONTAINS') {\n            segments.push(new IndexSegment(fieldPath, IndexKind.CONTAINS));\n          } else if (field.order === 'ASCENDING') {\n            segments.push(new IndexSegment(fieldPath, IndexKind.ASCENDING));\n          } else if (field.order === 'DESCENDING') {\n            segments.push(new IndexSegment(fieldPath, IndexKind.DESCENDING));\n          }\n        }\n      }\n\n      parsedIndexes.push(\n        new FieldIndex(\n          FieldIndex.UNKNOWN_ID,\n          collectionGroup,\n          segments,\n          IndexState.empty()\n        )\n      );\n    }\n  }\n  return parsedIndexes;\n}\n\nfunction tryParseJson(json: string): Record<string, unknown> {\n  try {\n    return JSON.parse(json);\n  } catch (e) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Failed to parse JSON: ' + (e as Error)?.message\n    );\n  }\n}\n\nfunction tryGetString(data: Record<string, unknown>, property: string): string {\n  if (typeof data[property] !== 'string') {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Missing string value for: ' + property\n    );\n  }\n  return data[property] as string;\n}\n","/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  firestoreClientDeleteAllFieldIndexes,\n  firestoreClientSetPersistentCacheIndexAutoCreationEnabled\n} from '../core/firestore_client';\nimport { cast } from '../util/input_validation';\nimport { logDebug, logWarn } from '../util/log';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\n\n/**\n * A `PersistentCacheIndexManager` for configuring persistent cache indexes used\n * for local query execution.\n *\n * To use, call `getPersistentCacheIndexManager()` to get an instance.\n */\nexport class PersistentCacheIndexManager {\n  /** A type string to uniquely identify instances of this class. */\n  readonly type: 'PersistentCacheIndexManager' = 'PersistentCacheIndexManager';\n\n  /** @hideconstructor */\n  constructor(readonly _firestore: Firestore) {}\n}\n\n/**\n * Returns the PersistentCache Index Manager used by the given `Firestore`\n * object.\n *\n * @returns The `PersistentCacheIndexManager` instance, or `null` if local\n * persistent storage is not in use.\n */\nexport function getPersistentCacheIndexManager(\n  firestore: Firestore\n): PersistentCacheIndexManager | null {\n  firestore = cast(firestore, Firestore);\n\n  const cachedInstance = persistentCacheIndexManagerByFirestore.get(firestore);\n  if (cachedInstance) {\n    return cachedInstance;\n  }\n\n  const client = ensureFirestoreConfigured(firestore);\n  if (client._uninitializedComponentsProvider?._offline.kind !== 'persistent') {\n    return null;\n  }\n\n  const instance = new PersistentCacheIndexManager(firestore);\n  persistentCacheIndexManagerByFirestore.set(firestore, instance);\n  return instance;\n}\n\n/**\n * Enables the SDK to create persistent cache indexes automatically for local\n * query execution when the SDK believes cache indexes can help improve\n * performance.\n *\n * This feature is disabled by default.\n */\nexport function enablePersistentCacheIndexAutoCreation(\n  indexManager: PersistentCacheIndexManager\n): void {\n  setPersistentCacheIndexAutoCreationEnabled(indexManager, true);\n}\n\n/**\n * Stops creating persistent cache indexes automatically for local query\n * execution. The indexes which have been created by calling\n * `enablePersistentCacheIndexAutoCreation()` still take effect.\n */\nexport function disablePersistentCacheIndexAutoCreation(\n  indexManager: PersistentCacheIndexManager\n): void {\n  setPersistentCacheIndexAutoCreationEnabled(indexManager, false);\n}\n\n/**\n * Removes all persistent cache indexes.\n *\n * Please note this function will also deletes indexes generated by\n * `setIndexConfiguration()`, which is deprecated.\n */\nexport function deleteAllPersistentCacheIndexes(\n  indexManager: PersistentCacheIndexManager\n): void {\n  const client = ensureFirestoreConfigured(indexManager._firestore);\n  const promise = firestoreClientDeleteAllFieldIndexes(client);\n\n  promise\n    .then(_ => logDebug('deleting all persistent cache indexes succeeded'))\n    .catch(error =>\n      logWarn('deleting all persistent cache indexes failed', error)\n    );\n}\n\nfunction setPersistentCacheIndexAutoCreationEnabled(\n  indexManager: PersistentCacheIndexManager,\n  isEnabled: boolean\n): void {\n  const client = ensureFirestoreConfigured(indexManager._firestore);\n  const promise = firestoreClientSetPersistentCacheIndexAutoCreationEnabled(\n    client,\n    isEnabled\n  );\n\n  promise\n    .then(_ =>\n      logDebug(\n        `setting persistent cache index auto creation ` +\n          `isEnabled=${isEnabled} succeeded`\n      )\n    )\n    .catch(error =>\n      logWarn(\n        `setting persistent cache index auto creation ` +\n          `isEnabled=${isEnabled} failed`,\n        error\n      )\n    );\n}\n\n/**\n * Maps `Firestore` instances to their corresponding\n * `PersistentCacheIndexManager` instances.\n *\n * Use a `WeakMap` so that the mapping will be automatically dropped when the\n * `Firestore` instance is garbage collected. This emulates a private member\n * as described in https://goo.gle/454yvug.\n */\nconst persistentCacheIndexManagerByFirestore = new WeakMap<\n  Firestore,\n  PersistentCacheIndexManager\n>();\n","/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Unsubscribe } from '../api/reference_impl';\n\nimport {\n  setTestingHooksSpi,\n  ExistenceFilterMismatchInfo,\n  TestingHooksSpi\n} from './testing_hooks_spi';\n\n/**\n * Testing hooks for use by Firestore's integration test suite to reach into the\n * SDK internals to validate logic and behavior that is not visible from the\n * public API surface.\n *\n * @internal\n */\nexport class TestingHooks {\n  private constructor() {\n    throw new Error('instances of this class should not be created');\n  }\n\n  /**\n   * Registers a callback to be notified when an existence filter mismatch\n   * occurs in the Watch listen stream.\n   *\n   * The relative order in which callbacks are notified is unspecified; do not\n   * rely on any particular ordering. If a given callback is registered multiple\n   * times then it will be notified multiple times, once per registration.\n   *\n   * @param callback - the callback to invoke upon existence filter mismatch.\n   *\n   * @returns a function that, when called, unregisters the given callback; only\n   * the first invocation of the returned function does anything; all subsequent\n   * invocations do nothing.\n   */\n  static onExistenceFilterMismatch(\n    callback: ExistenceFilterMismatchCallback\n  ): Unsubscribe {\n    return TestingHooksSpiImpl.instance.onExistenceFilterMismatch(callback);\n  }\n}\n\n/**\n * The signature of callbacks registered with\n * `TestingUtils.onExistenceFilterMismatch()`.\n *\n * The return value, if any, is ignored.\n *\n * @internal\n */\nexport type ExistenceFilterMismatchCallback = (\n  info: ExistenceFilterMismatchInfo\n) => unknown;\n\n/**\n * The implementation of `TestingHooksSpi`.\n */\nclass TestingHooksSpiImpl implements TestingHooksSpi {\n  private readonly existenceFilterMismatchCallbacksById = new Map<\n    Symbol,\n    ExistenceFilterMismatchCallback\n  >();\n\n  private constructor() {}\n\n  static get instance(): TestingHooksSpiImpl {\n    if (!testingHooksSpiImplInstance) {\n      testingHooksSpiImplInstance = new TestingHooksSpiImpl();\n      setTestingHooksSpi(testingHooksSpiImplInstance);\n    }\n    return testingHooksSpiImplInstance;\n  }\n\n  notifyOnExistenceFilterMismatch(info: ExistenceFilterMismatchInfo): void {\n    this.existenceFilterMismatchCallbacksById.forEach(callback =>\n      callback(info)\n    );\n  }\n\n  onExistenceFilterMismatch(\n    callback: ExistenceFilterMismatchCallback\n  ): Unsubscribe {\n    const id = Symbol();\n    const callbacks = this.existenceFilterMismatchCallbacksById;\n    callbacks.set(id, callback);\n    return () => callbacks.delete(id);\n  }\n}\n\nlet testingHooksSpiImplInstance: TestingHooksSpiImpl | null = null;\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  _registerComponent,\n  registerVersion,\n  SDK_VERSION\n} from '@firebase/app';\nimport { Component, ComponentType } from '@firebase/component';\n\nimport { name, version } from '../package.json';\nimport {\n  FirebaseAppCheckTokenProvider,\n  FirebaseAuthCredentialsProvider\n} from '../src/api/credentials';\nimport { setSDKVersion } from '../src/core/version';\n\nimport { Firestore } from './api/database';\nimport { databaseIdFromApp } from './core/database_info';\n\nexport function registerFirestore(\n  variant?: string,\n  useFetchStreams = true\n): void {\n  setSDKVersion(SDK_VERSION);\n  _registerComponent(\n    new Component(\n      'firestore',\n      (container, { instanceIdentifier: databaseId, options: settings }) => {\n        const app = container.getProvider('app').getImmediate()!;\n        const firestoreInstance = new Firestore(\n          new FirebaseAuthCredentialsProvider(\n            container.getProvider('auth-internal')\n          ),\n          new FirebaseAppCheckTokenProvider(\n            app,\n            container.getProvider('app-check-internal')\n          ),\n          databaseIdFromApp(app, databaseId),\n          app\n        );\n        settings = { useFetchStreams, ...settings };\n        firestoreInstance._setSettings(settings);\n        return firestoreInstance;\n      },\n      'PUBLIC' as ComponentType.PUBLIC\n    ).setMultipleInstances(true)\n  );\n  registerVersion(name, version, variant);\n  // BUILD_TARGET will be replaced by values like esm, cjs, etc during the compilation\n  registerVersion(name, version, '__BUILD_TARGET__');\n}\n","/**\n * Cloud Firestore\n *\n * @packageDocumentation\n */\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Firestore } from './api/database';\nimport { registerFirestore } from './register';\n\nregisterFirestore();\n\nexport * from './api';\n\ndeclare module '@firebase/component' {\n  interface NameServiceMapping {\n    'firestore': Firestore;\n  }\n}\n"],"names":["__PRIVATE_isPartialObserver","obj","__PRIVATE_implementsAnyMethods","__PRIVATE_methods","object","method","AggregateField","constructor","aggregateType","_internalFieldPath","this","type","AggregateQuerySnapshot","query","_userDataWriter","_data","data","convertObjectMap","_fieldsProto","ObjectValue","mapValue","fields","clone","value","DocumentSnapshot","_firestore","_key","_document","_converter","id","path","lastSegment","ref","DocumentReference","exists","snapshot","QueryDocumentSnapshot","fromFirestore","convertValue","undefined","get","fieldPath","field","__PRIVATE_fieldPathFromArgument","super","__PRIVATE_validateHasExplicitOrderByForLimitToLast","limitType","explicitOrderBy","length","FirestoreError","Code","UNIMPLEMENTED","AppliableConstraint","QueryConstraint","__PRIVATE_queryConstraint","__PRIVATE_additionalQueryConstraints","queryConstraints","push","concat","__PRIVATE_validateQueryConstraintArray","__PRIVATE_compositeFilterCount","filter","QueryCompositeFilterConstraint","__PRIVATE_fieldFilterCount","QueryFieldFilterConstraint","INVALID_ARGUMENT","constraint","_apply","_field","_op","_value","_create","_parse","__PRIVATE_validateNewFieldFilter","_query","Query","firestore","converter","__PRIVATE_queryWithAddedFilter","__PRIVATE_reader","__PRIVATE_newUserDataReader","__PRIVATE_newQueryFilter","methodName","__PRIVATE_dataReader","databaseId","op","fieldValue","isKeyField","__PRIVATE_validateDisjunctiveFilterElements","__PRIVATE_referenceList","arrayValue","__PRIVATE_parseDocumentIdValue","values","__PRIVATE_parseQueryValue","FieldFilter","create","_databaseId","where","opStr","_queryConstraints","__PRIVATE_parsedFilters","map","__PRIVATE_parsedFilter","getFilters","CompositeFilter","_getOperator","__PRIVATE_validateNewFilter","__PRIVATE_testQuery","__PRIVATE_subFilters","getFlattenedFilters","__PRIVATE_subFilter","_getQueryConstraints","or","forEach","__PRIVATE_validateQueryFilterConstraint","and","QueryOrderByConstraint","_direction","orderBy","__PRIVATE_newQueryOrderBy","direction","startAt","endAt","OrderBy","__PRIVATE_queryWithAddedOrderBy","directionStr","QueryLimitConstraint","_limit","_limitType","__PRIVATE_queryWithLimit","limit","__PRIVATE_validatePositiveNumber","limitToLast","QueryStartAtConstraint","_docOrFields","_inclusive","bound","__PRIVATE_newQueryBoundFromDocOrFields","__PRIVATE_queryWithStartAt","__PRIVATE_docOrFields","startAfter","QueryEndAtConstraint","__PRIVATE_queryWithEndAt","endBefore","inclusive","getModularInstance","__PRIVATE_newQueryBoundFromDocument","doc","NOT_FOUND","components","__PRIVATE_queryNormalizedOrderBy","__PRIVATE_refValue","key","__PRIVATE_isServerTimestamp","canonicalString","Bound","__PRIVATE_newQueryBoundFromFields","__PRIVATE_i","__PRIVATE_rawValue","__PRIVATE_isCollectionGroupQuery","indexOf","child","ResourcePath","fromString","DocumentKey","isDocumentKey","__PRIVATE_wrapped","__PRIVATE_documentIdValue","__PRIVATE_valueDescription","operator","Array","isArray","toString","fieldFilter","__PRIVATE_conflictingOp","__PRIVATE_findOpInsideFilters","filters","__PRIVATE_operators","__PRIVATE_conflictingOps","__PRIVATE_functionName","__PRIVATE_applyFirestoreDataConverter","options","__PRIVATE_convertedValue","merge","mergeFields","toFirestore","__PRIVATE_LiteUserDataWriter","AbstractUserDataWriter","convertBytes","bytes","Bytes","convertReference","name","convertDocumentKey","sum","average","count","aggregateFieldEqual","left","right","aggregateQuerySnapshotEqual","queryEqual","deepEqual","getCountFromServer","getAggregateFromServer","aggregateSpec","__PRIVATE_cast","Firestore","__PRIVATE_client","ensureFirestoreConfigured","__PRIVATE_internalAggregates","__PRIVATE_mapToArray","aggregate","alias","__PRIVATE_AggregateImpl","__PRIVATE_firestoreClientRunAggregateQuery","then","__PRIVATE_aggregateResult","__PRIVATE_convertToAggregateQuerySnapshot","userDataWriter","__PRIVATE_ExpUserDataWriter","__PRIVATE_querySnapshot","__PRIVATE_MemoryLocalCacheImpl","settings","kind","_onlineComponentProvider","OnlineComponentProvider","provider","_offlineComponentProvider","garbageCollector","build","__PRIVATE_LruGcMemoryOfflineComponentProvider","toJSON","__PRIVATE_PersistentLocalCacheImpl","tabManager","_initialize","persistentSingleTabManager","__PRIVATE_MemoryEagerGarbageCollectorImpl","__PRIVATE_MemoryOfflineComponentProvider","__PRIVATE_MemoryLruGarbageCollectorImpl","cacheSize","memoryEagerGarbageCollector","memoryLruGarbageCollector","cacheSizeBytes","memoryLocalCache","persistentLocalCache","__PRIVATE_SingleTabManagerImpl","forceOwnership","onlineComponents","__PRIVATE_IndexedDbOfflineComponentProvider","__PRIVATE_MultiTabManagerImpl","__PRIVATE_MultiTabOfflineComponentProvider","persistentMultipleTabManager","__PRIVATE_NOT_SUPPORTED","SnapshotMetadata","hasPendingWrites","fromCache","isEqual","other","__PRIVATE_LiteDocumentSnapshot","document","metadata","_firestoreImpl","serverTimestamps","FAILED_PRECONDITION","result","_jsonSchemaVersion","isValidDocument","isFoundDocument","documentSnapshotFromJSON","db","json","__PRIVATE_validateJSON","_jsonSchema","bundle","serializer","__PRIVATE_newSerializer","__PRIVATE_bundleReader","__PRIVATE_createBundleReaderSync","elements","__PRIVATE_getElements","__PRIVATE_bundleLoader","__PRIVATE_BundleLoader","getMetadata","element","__PRIVATE_addSizedElement","__PRIVATE_bundledDocuments","documents","__PRIVATE_fromDocument","documentKey","bundleName","property","bundleSource","QuerySnapshot","_snapshot","docs","size","empty","callback","thisArg","call","mutatedKeys","has","docChanges","includeMetadataChanges","excludesMetadataChanges","_cachedChanges","_cachedChangesIncludeMetadataChanges","__PRIVATE_changesFromSnapshot","oldDocs","isEmpty","index","__PRIVATE_change","oldIndex","newIndex","__PRIVATE_indexTracker","delete","add","__PRIVATE_resultChangeType","__PRIVATE_AutoId","newId","database","projectId","__PRIVATE_documentData","__PRIVATE_paths","querySnapshotFromJSON","queries","__PRIVATE_fromBundledQuery","bundledQuery","__PRIVATE_documentSet","DocumentSet","__PRIVATE_bundledDocument","__PRIVATE_viewSnapshot","ViewSnapshot","fromInitialDocuments","__PRIVATE_documentKeySet","__PRIVATE_externalQuery","fail","snapshotEqual","__PRIVATE_DEFAULT_TRANSACTION_OPTIONS","maxAttempts","WriteBatch","_commitHandler","_mutations","_committed","_dataReader","set","documentRef","_verifyNotCommitted","__PRIVATE_validateReference","__PRIVATE_parsed","__PRIVATE_parseSetData","toMutation","Precondition","none","update","__PRIVATE_fieldOrUpdateData","moreFieldsAndValues","FieldPath","__PRIVATE_parseUpdateVarargs","__PRIVATE_parseUpdateData","__PRIVATE_DeleteMutation","commit","Promise","resolve","Transaction","_transaction","lookup","isNoDocument","__PRIVATE_LiteTransaction","__PRIVATE_liteDocumentSnapshot","runTransaction","updateFunction","__PRIVATE_optionsWithDefaults","__PRIVATE_validateTransactionOptions","__PRIVATE_firestoreClientTransaction","__PRIVATE_internalTransaction","getDoc","reference","__PRIVATE_firestoreClientGetDocumentViaSnapshotListener","__PRIVATE_convertToDocSnapshot","getDocFromCache","__PRIVATE_firestoreClientGetDocumentFromLocalCache","hasLocalMutations","getDocFromServer","source","getDocs","__PRIVATE_firestoreClientGetDocumentsViaSnapshotListener","getDocsFromCache","__PRIVATE_firestoreClientGetDocumentsFromLocalCache","getDocsFromServer","setDoc","executeWrite","updateDoc","deleteDoc","addDoc","__PRIVATE_docRef","onSnapshot","args","__PRIVATE_currArg","__PRIVATE_internalOptions","__PRIVATE_userObserver","next","bind","error","complete","observer","__PRIVATE_internalQuery","__PRIVATE_newQueryForPath","__PRIVATE_firestoreClientListen","onSnapshotResume","snapshotJson","__PRIVATE_normalizeSnapshotJsonFields","__PRIVATE_requiredKeys","__PRIVATE_curArg","__PRIVATE_onSnapshotQuerySnapshotBundle","__PRIVATE_internalUnsubscribe","__PRIVATE_unsubscribed","__PRIVATE_loadTask","loadBundle","namedQuery","withConverter","catch","e","__PRIVATE_onSnapshotDocumentSnapshotBundle","__PRIVATE_docReference","fromPath","onSnapshotsInSync","arg","__PRIVATE_firestoreClientAddSnapshotsInSyncListener","mutations","__PRIVATE_firestoreClientWrite","writeBatch","setIndexConfiguration","__PRIVATE_jsonOrConfiguration","_uninitializedComponentsProvider","_offline","__PRIVATE_logWarn","__PRIVATE_parsedIndexes","__PRIVATE_parseIndexes","__PRIVATE_indexConfiguration","__PRIVATE_tryParseJson","JSON","parse","message","indexes","collectionGroup","__PRIVATE_tryGetString","segments","__PRIVATE_fieldPathString","__PRIVATE_fieldPathFromDotSeparatedString","arrayConfig","IndexSegment","order","FieldIndex","UNKNOWN_ID","IndexState","__PRIVATE_firestoreClientSetIndexConfiguration","PersistentCacheIndexManager","getPersistentCacheIndexManager","__PRIVATE_cachedInstance","__PRIVATE_persistentCacheIndexManagerByFirestore","instance","enablePersistentCacheIndexAutoCreation","indexManager","__PRIVATE_setPersistentCacheIndexAutoCreationEnabled","disablePersistentCacheIndexAutoCreation","deleteAllPersistentCacheIndexes","__PRIVATE_firestoreClientDeleteAllFieldIndexes","_","__PRIVATE_logDebug","isEnabled","__PRIVATE_firestoreClientSetPersistentCacheIndexAutoCreationEnabled","WeakMap","TestingHooks","Error","onExistenceFilterMismatch","__PRIVATE_TestingHooksSpiImpl","Map","__PRIVATE_testingHooksSpiImplInstance","__PRIVATE_setTestingHooksSpi","__PRIVATE_notifyOnExistenceFilterMismatch","info","__PRIVATE_existenceFilterMismatchCallbacksById","Symbol","__PRIVATE_callbacks","__PRIVATE_registerFirestore","variant","useFetchStreams","__PRIVATE_setSDKVersion","SDK_VERSION","_registerComponent","Component","container","instanceIdentifier","app","getProvider","getImmediate","__PRIVATE_firestoreInstance","__PRIVATE_FirebaseAuthCredentialsProvider","__PRIVATE_FirebaseAppCheckTokenProvider","__PRIVATE_databaseIdFromApp","_setSettings","setMultipleInstances","registerVersion","version"],"mappings":"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"}