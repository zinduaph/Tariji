{"version":3,"file":"pipelines.cjs.js","sources":["../src/util/proto.ts","../src/lite-api/expressions.ts","../src/core/pipeline-util.ts","../src/lite-api/stage.ts","../src/lite-api/pipeline-source.ts","../src/lite-api/pipeline-result.ts","../src/util/pipeline_util.ts","../src/lite-api/pipeline.ts","../src/api/pipeline.ts","../src/api/pipeline_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ArrayValue as ProtoArrayValue,\n  Function as ProtoFunction,\n  LatLng as ProtoLatLng,\n  MapValue as ProtoMapValue,\n  Pipeline as ProtoPipeline,\n  Timestamp as ProtoTimestamp,\n  Value as ProtoValue\n} from '../protos/firestore_proto_api';\n\nimport { isPlainObject } from './input_validation';\n\n/* eslint @typescript-eslint/no-explicit-any: 0 */\n\nfunction isITimestamp(obj: any): obj is ProtoTimestamp {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'seconds' in obj &&\n    (obj.seconds === null ||\n      typeof obj.seconds === 'number' ||\n      typeof obj.seconds === 'string') &&\n    'nanos' in obj &&\n    (obj.nanos === null || typeof obj.nanos === 'number')\n  ) {\n    return true;\n  }\n\n  return false;\n}\nfunction isILatLng(obj: any): obj is ProtoLatLng {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'latitude' in obj &&\n    (obj.latitude === null || typeof obj.latitude === 'number') &&\n    'longitude' in obj &&\n    (obj.longitude === null || typeof obj.longitude === 'number')\n  ) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIArrayValue(obj: any): obj is ProtoArrayValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('values' in obj && (obj.values === null || Array.isArray(obj.values))) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIMapValue(obj: any): obj is ProtoMapValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('fields' in obj && (obj.fields === null || isPlainObject(obj.fields))) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIFunction(obj: any): obj is ProtoFunction {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'name' in obj &&\n    (obj.name === null || typeof obj.name === 'string') &&\n    'args' in obj &&\n    (obj.args === null || Array.isArray(obj.args))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isIPipeline(obj: any): obj is ProtoPipeline {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('stages' in obj && (obj.stages === null || Array.isArray(obj.stages))) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isFirestoreValue(obj: any): obj is ProtoValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n\n  // Check optional properties and their types\n  if (\n    ('nullValue' in obj &&\n      (obj.nullValue === null || obj.nullValue === 'NULL_VALUE')) ||\n    ('booleanValue' in obj &&\n      (obj.booleanValue === null || typeof obj.booleanValue === 'boolean')) ||\n    ('integerValue' in obj &&\n      (obj.integerValue === null ||\n        typeof obj.integerValue === 'number' ||\n        typeof obj.integerValue === 'string')) ||\n    ('doubleValue' in obj &&\n      (obj.doubleValue === null || typeof obj.doubleValue === 'number')) ||\n    ('timestampValue' in obj &&\n      (obj.timestampValue === null || isITimestamp(obj.timestampValue))) ||\n    ('stringValue' in obj &&\n      (obj.stringValue === null || typeof obj.stringValue === 'string')) ||\n    ('bytesValue' in obj &&\n      (obj.bytesValue === null || obj.bytesValue instanceof Uint8Array)) ||\n    ('referenceValue' in obj &&\n      (obj.referenceValue === null ||\n        typeof obj.referenceValue === 'string')) ||\n    ('geoPointValue' in obj &&\n      (obj.geoPointValue === null || isILatLng(obj.geoPointValue))) ||\n    ('arrayValue' in obj &&\n      (obj.arrayValue === null || isIArrayValue(obj.arrayValue))) ||\n    ('mapValue' in obj &&\n      (obj.mapValue === null || isIMapValue(obj.mapValue))) ||\n    ('fieldReferenceValue' in obj &&\n      (obj.fieldReferenceValue === null ||\n        typeof obj.fieldReferenceValue === 'string')) ||\n    ('functionValue' in obj &&\n      (obj.functionValue === null || isIFunction(obj.functionValue))) ||\n    ('pipelineValue' in obj &&\n      (obj.pipelineValue === null || isIPipeline(obj.pipelineValue)))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirestoreError } from '../api';\nimport { ParseContext } from '../api/parse_context';\nimport {\n  DOCUMENT_KEY_NAME,\n  FieldPath as InternalFieldPath\n} from '../model/path';\nimport { Value as ProtoValue } from '../protos/firestore_proto_api';\nimport {\n  JsonProtoSerializer,\n  ProtoValueSerializable,\n  toMapValue,\n  toStringValue\n} from '../remote/serializer';\nimport { hardAssert } from '../util/assert';\nimport { isPlainObject } from '../util/input_validation';\nimport { isFirestoreValue } from '../util/proto';\nimport { isString } from '../util/types';\n\nimport { Bytes } from './bytes';\nimport { documentId as documentIdFieldPath, FieldPath } from './field_path';\nimport { vector } from './field_value_impl';\nimport { GeoPoint } from './geo_point';\nimport { DocumentReference } from './reference';\nimport { Timestamp } from './timestamp';\nimport { fieldPathFromArgument, parseData, UserData } from './user_data_reader';\nimport { VectorValue } from './vector_value';\n\n/**\n * @beta\n *\n * An enumeration of the different types of expressions.\n */\nexport type ExpressionType =\n  | 'Field'\n  | 'Constant'\n  | 'Function'\n  | 'AggregateFunction'\n  | 'ListOfExpressions'\n  | 'AliasedExpression';\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nfunction valueToDefaultExpr(value: unknown): Expression {\n  let result: Expression | undefined;\n  if (value instanceof Expression) {\n    return value;\n  } else if (isPlainObject(value)) {\n    result = _map(value as Record<string, unknown>, undefined);\n  } else if (value instanceof Array) {\n    result = array(value);\n  } else {\n    result = _constant(value, undefined);\n  }\n\n  return result;\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nfunction vectorToExpr(value: VectorValue | number[] | Expression): Expression {\n  if (value instanceof Expression) {\n    return value;\n  } else if (value instanceof VectorValue) {\n    return constant(value);\n  } else if (Array.isArray(value)) {\n    return constant(vector(value));\n  } else {\n    throw new Error('Unsupported value: ' + typeof value);\n  }\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n * If the input is a string, it is assumed to be a field name, and a\n * field(value) is returned.\n *\n * @private\n * @internal\n * @param value\n */\nfunction fieldOrExpression(value: unknown): Expression {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return valueToDefaultExpr(value);\n  }\n}\n\n/**\n * @beta\n *\n * Represents an expression that can be evaluated to a value within the execution of a {@link\n * @firebase/firestore/pipelines#Pipeline}.\n *\n * Expressions are the building blocks for creating complex queries and transformations in\n * Firestore pipelines. They can represent:\n *\n * - **Field references:** Access values from document fields.\n * - **Literals:** Represent constant values (strings, numbers, booleans).\n * - **Function calls:** Apply functions to one or more expressions.\n *\n * The `Expression` class provides a fluent API for building expressions. You can chain together\n * method calls to create complex expressions.\n */\nexport abstract class Expression implements ProtoValueSerializable, UserData {\n  abstract readonly expressionType: ExpressionType;\n\n  abstract readonly _methodName?: string;\n\n  /**\n   * @private\n   * @internal\n   */\n  abstract _toProto(serializer: JsonProtoSerializer): ProtoValue;\n  _protoValueType = 'ProtoValue' as const;\n\n  /**\n   * @private\n   * @internal\n   */\n  abstract _readUserData(context: ParseContext): void;\n\n  /**\n   * Creates an expression that adds this expression to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Add the value of the 'quantity' field and the 'reserve' field.\n   * field(\"quantity\").add(field(\"reserve\"));\n   * ```\n   *\n   * @param second - The expression or literal to add to this expression.\n   * @param others - Optional additional expressions or literals to add to this expression.\n   * @returns A new `Expression` representing the addition operation.\n   */\n  add(second: Expression | unknown): FunctionExpression {\n    return new FunctionExpression(\n      'add',\n      [this, valueToDefaultExpr(second)],\n      'add'\n    );\n  }\n\n  /**\n   * @beta\n   * Wraps the expression in a [BooleanExpression].\n   *\n   * @returns A [BooleanExpression] representing the same expression.\n   */\n  asBoolean(): BooleanExpression {\n    if (this instanceof BooleanExpression) {\n      return this;\n    } else if (this instanceof Constant) {\n      return new BooleanConstant(this);\n    } else if (this instanceof Field) {\n      return new BooleanField(this);\n    } else if (this instanceof FunctionExpression) {\n      return new BooleanFunctionExpression(this);\n    } else {\n      throw new FirestoreError(\n        'invalid-argument',\n        `Conversion of type ${typeof this} to BooleanExpression not supported.`\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that subtracts another expression from this expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract the 'discount' field from the 'price' field\n   * field(\"price\").subtract(field(\"discount\"));\n   * ```\n   *\n   * @param subtrahend - The expression to subtract from this expression.\n   * @returns A new `Expression` representing the subtraction operation.\n   */\n  subtract(subtrahend: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a constant value from this expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract 20 from the value of the 'total' field\n   * field(\"total\").subtract(20);\n   * ```\n   *\n   * @param subtrahend - The constant value to subtract.\n   * @returns A new `Expression` representing the subtraction operation.\n   */\n  subtract(subtrahend: number): FunctionExpression;\n  subtract(subtrahend: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'subtract',\n      [this, valueToDefaultExpr(subtrahend)],\n      'subtract'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that multiplies this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Multiply the 'quantity' field by the 'price' field\n   * field(\"quantity\").multiply(field(\"price\"));\n   * ```\n   *\n   * @param second - The second expression or literal to multiply by.\n   * @param others - Optional additional expressions or literals to multiply by.\n   * @returns A new `Expression` representing the multiplication operation.\n   */\n  multiply(second: Expression | number): FunctionExpression {\n    return new FunctionExpression(\n      'multiply',\n      [this, valueToDefaultExpr(second)],\n      'multiply'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that divides this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Divide the 'total' field by the 'count' field\n   * field(\"total\").divide(field(\"count\"));\n   * ```\n   *\n   * @param divisor - The expression to divide by.\n   * @returns A new `Expression` representing the division operation.\n   */\n  divide(divisor: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that divides this expression by a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Divide the 'value' field by 10\n   * field(\"value\").divide(10);\n   * ```\n   *\n   * @param divisor - The constant value to divide by.\n   * @returns A new `Expression` representing the division operation.\n   */\n  divide(divisor: number): FunctionExpression;\n  divide(divisor: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'divide',\n      [this, valueToDefaultExpr(divisor)],\n      'divide'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the modulo (remainder) of dividing this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the remainder of dividing the 'value' field by the 'divisor' field\n   * field(\"value\").mod(field(\"divisor\"));\n   * ```\n   *\n   * @param expression - The expression to divide by.\n   * @returns A new `Expression` representing the modulo operation.\n   */\n  mod(expression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that calculates the modulo (remainder) of dividing this expression by a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the remainder of dividing the 'value' field by 10\n   * field(\"value\").mod(10);\n   * ```\n   *\n   * @param value - The constant value to divide by.\n   * @returns A new `Expression` representing the modulo operation.\n   */\n  mod(value: number): FunctionExpression;\n  mod(other: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'mod',\n      [this, valueToDefaultExpr(other)],\n      'mod'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is equal to 21\n   * field(\"age\").equal(21);\n   * ```\n   *\n   * @param expression - The expression to compare for equality.\n   * @returns A new `Expression` representing the equality comparison.\n   */\n  equal(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'city' field is equal to \"London\"\n   * field(\"city\").equal(\"London\");\n   * ```\n   *\n   * @param value - The constant value to compare for equality.\n   * @returns A new `Expression` representing the equality comparison.\n   */\n  equal(value: unknown): BooleanExpression;\n  equal(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'equal',\n      [this, valueToDefaultExpr(other)],\n      'equal'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is not equal to \"completed\"\n   * field(\"status\").notEqual(\"completed\");\n   * ```\n   *\n   * @param expression - The expression to compare for inequality.\n   * @returns A new `Expression` representing the inequality comparison.\n   */\n  notEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'country' field is not equal to \"USA\"\n   * field(\"country\").notEqual(\"USA\");\n   * ```\n   *\n   * @param value - The constant value to compare for inequality.\n   * @returns A new `Expression` representing the inequality comparison.\n   */\n  notEqual(value: unknown): BooleanExpression;\n  notEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'not_equal',\n      [this, valueToDefaultExpr(other)],\n      'notEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is less than 'limit'\n   * field(\"age\").lessThan(field('limit'));\n   * ```\n   *\n   * @param experession - The expression to compare for less than.\n   * @returns A new `Expression` representing the less than comparison.\n   */\n  lessThan(experession: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is less than 50\n   * field(\"price\").lessThan(50);\n   * ```\n   *\n   * @param value - The constant value to compare for less than.\n   * @returns A new `Expression` representing the less than comparison.\n   */\n  lessThan(value: unknown): BooleanExpression;\n  lessThan(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'less_than',\n      [this, valueToDefaultExpr(other)],\n      'lessThan'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than or equal to another\n   * expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'quantity' field is less than or equal to 20\n   * field(\"quantity\").lessThan(constant(20));\n   * ```\n   *\n   * @param expression - The expression to compare for less than or equal to.\n   * @returns A new `Expression` representing the less than or equal to comparison.\n   */\n  lessThanOrEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than or equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'score' field is less than or equal to 70\n   * field(\"score\").lessThan(70);\n   * ```\n   *\n   * @param value - The constant value to compare for less than or equal to.\n   * @returns A new `Expression` representing the less than or equal to comparison.\n   */\n  lessThanOrEqual(value: unknown): BooleanExpression;\n  lessThanOrEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'less_than_or_equal',\n      [this, valueToDefaultExpr(other)],\n      'lessThanOrEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is greater than the 'limit' field\n   * field(\"age\").greaterThan(field(\"limit\"));\n   * ```\n   *\n   * @param expression - The expression to compare for greater than.\n   * @returns A new `Expression` representing the greater than comparison.\n   */\n  greaterThan(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is greater than 100\n   * field(\"price\").greaterThan(100);\n   * ```\n   *\n   * @param value - The constant value to compare for greater than.\n   * @returns A new `Expression` representing the greater than comparison.\n   */\n  greaterThan(value: unknown): BooleanExpression;\n  greaterThan(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'greater_than',\n      [this, valueToDefaultExpr(other)],\n      'greaterThan'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than or equal to another\n   * expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'quantity' field is greater than or equal to field 'requirement' plus 1\n   * field(\"quantity\").greaterThanOrEqual(field('requirement').add(1));\n   * ```\n   *\n   * @param expression - The expression to compare for greater than or equal to.\n   * @returns A new `Expression` representing the greater than or equal to comparison.\n   */\n  greaterThanOrEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than or equal to a constant\n   * value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'score' field is greater than or equal to 80\n   * field(\"score\").greaterThanOrEqual(80);\n   * ```\n   *\n   * @param value - The constant value to compare for greater than or equal to.\n   * @returns A new `Expression` representing the greater than or equal to comparison.\n   */\n  greaterThanOrEqual(value: unknown): BooleanExpression;\n  greaterThanOrEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'greater_than_or_equal',\n      [this, valueToDefaultExpr(other)],\n      'greaterThanOrEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates an array expression with one or more other arrays.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'items' array with another array field.\n   * field(\"items\").arrayConcat(field(\"otherItems\"));\n   * ```\n   * @param secondArray - Second array expression or array literal to concatenate.\n   * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n   * @returns A new `Expression` representing the concatenated array.\n   */\n  arrayConcat(\n    secondArray: Expression | unknown[],\n    ...otherArrays: Array<Expression | unknown[]>\n  ): FunctionExpression {\n    const elements = [secondArray, ...otherArrays];\n    const exprValues = elements.map(value => valueToDefaultExpr(value));\n    return new FunctionExpression(\n      'array_concat',\n      [this, ...exprValues],\n      'arrayConcat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains a specific element.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'sizes' array contains the value from the 'selectedSize' field\n   * field(\"sizes\").arrayContains(field(\"selectedSize\"));\n   * ```\n   *\n   * @param expression - The element to search for in the array.\n   * @returns A new `Expression` representing the 'array_contains' comparison.\n   */\n  arrayContains(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains a specific value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'colors' array contains \"red\"\n   * field(\"colors\").arrayContains(\"red\");\n   * ```\n   *\n   * @param value - The element to search for in the array.\n   * @returns A new `Expression` representing the 'array_contains' comparison.\n   */\n  arrayContains(value: unknown): BooleanExpression;\n  arrayContains(element: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'array_contains',\n      [this, valueToDefaultExpr(element)],\n      'arrayContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains all the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'tags' array contains both the value in field \"tag1\" and the literal value \"tag2\"\n   * field(\"tags\").arrayContainsAll([field(\"tag1\"), \"tag2\"]);\n   * ```\n   *\n   * @param values - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_all' comparison.\n   */\n  arrayContainsAll(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains all the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'tags' array contains both of the values from field \"tag1\" and the literal value \"tag2\"\n   * field(\"tags\").arrayContainsAll(array([field(\"tag1\"), \"tag2\"]));\n   * ```\n   *\n   * @param arrayExpression - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_all' comparison.\n   */\n  arrayContainsAll(arrayExpression: Expression): BooleanExpression;\n  arrayContainsAll(values: unknown[] | Expression): BooleanExpression {\n    const normalizedExpr = Array.isArray(values)\n      ? new ListOfExprs(values.map(valueToDefaultExpr), 'arrayContainsAll')\n      : values;\n    return new FunctionExpression(\n      'array_contains_all',\n      [this, normalizedExpr],\n      'arrayContainsAll'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains any of the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'categories' array contains either values from field \"cate1\" or \"cate2\"\n   * field(\"categories\").arrayContainsAny([field(\"cate1\"), field(\"cate2\")]);\n   * ```\n   *\n   * @param values - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_any' comparison.\n   */\n  arrayContainsAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains any of the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'groups' array contains either the value from the 'userGroup' field\n   * // or the value \"guest\"\n   * field(\"groups\").arrayContainsAny(array([field(\"userGroup\"), \"guest\"]));\n   * ```\n   *\n   * @param arrayExpression - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_any' comparison.\n   */\n  arrayContainsAny(arrayExpression: Expression): BooleanExpression;\n  arrayContainsAny(\n    values: Array<unknown | Expression> | Expression\n  ): BooleanExpression {\n    const normalizedExpr = Array.isArray(values)\n      ? new ListOfExprs(values.map(valueToDefaultExpr), 'arrayContainsAny')\n      : values;\n    return new FunctionExpression(\n      'array_contains_any',\n      [this, normalizedExpr],\n      'arrayContainsAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses an array.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myArray' field.\n   * field(\"myArray\").arrayReverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n   */\n  arrayReverse(): FunctionExpression {\n    return new FunctionExpression('array_reverse', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of an array.\n   *\n   * @example\n   * ```typescript\n   * // Get the number of items in the 'cart' array\n   * field(\"cart\").arrayLength();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the array.\n   */\n  arrayLength(): FunctionExpression {\n    return new FunctionExpression('array_length', [this], 'arrayLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n   * field(\"category\").equalAny(\"Electronics\", field(\"primaryType\"));\n   * ```\n   *\n   * @param values - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'IN' comparison.\n   */\n  equalAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n   * field(\"category\").equalAny(array([\"Electronics\", field(\"primaryType\")]));\n   * ```\n   *\n   * @param arrayExpression - An expression that evaluates to an array of values to check against.\n   * @returns A new `Expression` representing the 'IN' comparison.\n   */\n  equalAny(arrayExpression: Expression): BooleanExpression;\n  equalAny(others: unknown[] | Expression): BooleanExpression {\n    const exprOthers = Array.isArray(others)\n      ? new ListOfExprs(others.map(valueToDefaultExpr), 'equalAny')\n      : others;\n    return new FunctionExpression(\n      'equal_any',\n      [this, exprOthers],\n      'equalAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n   * field(\"status\").notEqualAny([\"pending\", field(\"rejectedStatus\")]);\n   * ```\n   *\n   * @param values - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'notEqualAny' comparison.\n   */\n  notEqualAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to any of the values in the evaluated expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is not equal to any value in the field 'rejectedStatuses'\n   * field(\"status\").notEqualAny(field('rejectedStatuses'));\n   * ```\n   *\n   * @param arrayExpression - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'notEqualAny' comparison.\n   */\n  notEqualAny(arrayExpression: Expression): BooleanExpression;\n  notEqualAny(others: unknown[] | Expression): BooleanExpression {\n    const exprOthers = Array.isArray(others)\n      ? new ListOfExprs(others.map(valueToDefaultExpr), 'notEqualAny')\n      : others;\n    return new FunctionExpression(\n      'not_equal_any',\n      [this, exprOthers],\n      'notEqualAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a field exists in the document.\n   *\n   * @example\n   * ```typescript\n   * // Check if the document has a field named \"phoneNumber\"\n   * field(\"phoneNumber\").exists();\n   * ```\n   *\n   * @returns A new `Expression` representing the 'exists' check.\n   */\n  exists(): BooleanExpression {\n    return new FunctionExpression('exists', [this], 'exists').asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the character length of a string in UTF-8.\n   *\n   * @example\n   * ```typescript\n   * // Get the character length of the 'name' field in its UTF-8 form.\n   * field(\"name\").charLength();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the string.\n   */\n  charLength(): FunctionExpression {\n    return new FunctionExpression('char_length', [this], 'charLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that performs a case-sensitive string comparison.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'title' field contains the word \"guide\" (case-sensitive)\n   * field(\"title\").like(\"%guide%\");\n   * ```\n   *\n   * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n   * @returns A new `Expression` representing the 'like' comparison.\n   */\n  like(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that performs a case-sensitive string comparison.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'title' field contains the word \"guide\" (case-sensitive)\n   * field(\"title\").like(\"%guide%\");\n   * ```\n   *\n   * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n   * @returns A new `Expression` representing the 'like' comparison.\n   */\n  like(pattern: Expression): BooleanExpression;\n  like(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'like',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'like'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified regular expression as a\n   * substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains \"example\" (case-insensitive)\n   * field(\"description\").regexContains(\"(?i)example\");\n   * ```\n   *\n   * @param pattern - The regular expression to use for the search.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  regexContains(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified regular expression as a\n   * substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains the regular expression stored in field 'regex'\n   * field(\"description\").regexContains(field(\"regex\"));\n   * ```\n   *\n   * @param pattern - The regular expression to use for the search.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  regexContains(pattern: Expression): BooleanExpression;\n  regexContains(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'regex_contains',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string matches a specified regular expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'email' field matches a valid email pattern\n   * field(\"email\").regexMatch(\"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n   * ```\n   *\n   * @param pattern - The regular expression to use for the match.\n   * @returns A new `Expression` representing the regular expression match.\n   */\n  regexMatch(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string matches a specified regular expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'email' field matches a regular expression stored in field 'regex'\n   * field(\"email\").regexMatch(field(\"regex\"));\n   * ```\n   *\n   * @param pattern - The regular expression to use for the match.\n   * @returns A new `Expression` representing the regular expression match.\n   */\n  regexMatch(pattern: Expression): BooleanExpression;\n  regexMatch(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'regex_match',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexMatch'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains \"example\".\n   * field(\"description\").stringContains(\"example\");\n   * ```\n   *\n   * @param substring - The substring to search for.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  stringContains(substring: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains the string represented by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains the value of the 'keyword' field.\n   * field(\"description\").stringContains(field(\"keyword\"));\n   * ```\n   *\n   * @param expr - The expression representing the substring to search for.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  stringContains(expr: Expression): BooleanExpression;\n  stringContains(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'string_contains',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'stringContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string starts with a given prefix.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'name' field starts with \"Mr.\"\n   * field(\"name\").startsWith(\"Mr.\");\n   * ```\n   *\n   * @param prefix - The prefix to check for.\n   * @returns A new `Expression` representing the 'starts with' comparison.\n   */\n  startsWith(prefix: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string starts with a given prefix (represented as an\n   * expression).\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'fullName' field starts with the value of the 'firstName' field\n   * field(\"fullName\").startsWith(field(\"firstName\"));\n   * ```\n   *\n   * @param prefix - The prefix expression to check for.\n   * @returns A new `Expression` representing the 'starts with' comparison.\n   */\n  startsWith(prefix: Expression): BooleanExpression;\n  startsWith(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'starts_with',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'startsWith'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string ends with a given postfix.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'filename' field ends with \".txt\"\n   * field(\"filename\").endsWith(\".txt\");\n   * ```\n   *\n   * @param suffix - The postfix to check for.\n   * @returns A new `Expression` representing the 'ends with' comparison.\n   */\n  endsWith(suffix: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string ends with a given postfix (represented as an\n   * expression).\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'url' field ends with the value of the 'extension' field\n   * field(\"url\").endsWith(field(\"extension\"));\n   * ```\n   *\n   * @param suffix - The postfix expression to check for.\n   * @returns A new `Expression` representing the 'ends with' comparison.\n   */\n  endsWith(suffix: Expression): BooleanExpression;\n  endsWith(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'ends_with',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'endsWith'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts a string to lowercase.\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'name' field to lowercase\n   * field(\"name\").toLower();\n   * ```\n   *\n   * @returns A new `Expression` representing the lowercase string.\n   */\n  toLower(): FunctionExpression {\n    return new FunctionExpression('to_lower', [this], 'toLower');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts a string to uppercase.\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'title' field to uppercase\n   * field(\"title\").toUpper();\n   * ```\n   *\n   * @returns A new `Expression` representing the uppercase string.\n   */\n  toUpper(): FunctionExpression {\n    return new FunctionExpression('to_upper', [this], 'toUpper');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that removes leading and trailing characters from a string or byte array.\n   *\n   * @example\n   * ```typescript\n   * // Trim whitespace from the 'userInput' field\n   * field(\"userInput\").trim();\n   *\n   * // Trim quotes from the 'userInput' field\n   * field(\"userInput\").trim('\"');\n   * ```\n   * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n   * trimmed from the input. If not specified, then whitespace will be trimmed.\n   * @returns A new `Expression` representing the trimmed string or byte array.\n   */\n  trim(valueToTrim?: string | Expression | Bytes): FunctionExpression {\n    const args: Expression[] = [this];\n    if (valueToTrim) {\n      args.push(valueToDefaultExpr(valueToTrim));\n    }\n    return new FunctionExpression('trim', args, 'trim');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates string expressions together.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n   * field(\"firstName\").stringConcat(constant(\" \"), field(\"lastName\"));\n   * ```\n   *\n   * @param secondString - The additional expression or string literal to concatenate.\n   * @param otherStrings - Optional additional expressions or string literals to concatenate.\n   * @returns A new `Expression` representing the concatenated string.\n   */\n  stringConcat(\n    secondString: Expression | string,\n    ...otherStrings: Array<Expression | string>\n  ): FunctionExpression {\n    const elements = [secondString, ...otherStrings];\n    const exprs = elements.map(valueToDefaultExpr);\n    return new FunctionExpression(\n      'string_concat',\n      [this, ...exprs],\n      'stringConcat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates expression results together.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'firstName', ' ', and 'lastName' fields into a single value.\n   * field(\"firstName\").concat(constant(\" \"), field(\"lastName\"));\n   * ```\n   *\n   * @param second - The additional expression or literal to concatenate.\n   * @param others - Optional additional expressions or literals to concatenate.\n   * @returns A new `Expression` representing the concatenated value.\n   */\n  concat(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const elements = [second, ...others];\n    const exprs = elements.map(valueToDefaultExpr);\n    return new FunctionExpression('concat', [this, ...exprs], 'concat');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses this string expression.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myString' field.\n   * field(\"myString\").reverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n   */\n  reverse(): FunctionExpression {\n    return new FunctionExpression('reverse', [this], 'reverse');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of this string expression in bytes.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the length of the 'myString' field in bytes.\n   * field(\"myString\").byteLength();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n   */\n  byteLength(): FunctionExpression {\n    return new FunctionExpression('byte_length', [this], 'byteLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the ceiling of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the ceiling of the 'price' field.\n   * field(\"price\").ceil();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n   */\n  ceil(): FunctionExpression {\n    return new FunctionExpression('ceil', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the floor of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the floor of the 'price' field.\n   * field(\"price\").floor();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n   */\n  floor(): FunctionExpression {\n    return new FunctionExpression('floor', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the absolute value of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the absolute value of the 'price' field.\n   * field(\"price\").abs();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n   */\n  abs(): FunctionExpression {\n    return new FunctionExpression('abs', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes e to the power of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Compute e to the power of the 'value' field.\n   * field(\"value\").exp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n   */\n  exp(): FunctionExpression {\n    return new FunctionExpression('exp', [this]);\n  }\n\n  /**\n   * @beta\n   * Accesses a value from a map (object) field using the provided key.\n   *\n   * @example\n   * ```typescript\n   * // Get the 'city' value from the 'address' map field\n   * field(\"address\").mapGet(\"city\");\n   * ```\n   *\n   * @param subfield - The key to access in the map.\n   * @returns A new `Expression` representing the value associated with the given key in the map.\n   */\n  mapGet(subfield: string): FunctionExpression {\n    return new FunctionExpression(\n      'map_get',\n      [this, constant(subfield)],\n      'mapGet'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that counts the number of stage inputs with valid evaluations of the\n   * expression or field.\n   *\n   * @example\n   * ```typescript\n   * // Count the total number of products\n   * field(\"productId\").count().as(\"totalProducts\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'count' aggregation.\n   */\n  count(): AggregateFunction {\n    return AggregateFunction._create('count', [this], 'count');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that calculates the sum of a numeric field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the total revenue from a set of orders\n   * field(\"orderAmount\").sum().as(\"totalRevenue\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'sum' aggregation.\n   */\n  sum(): AggregateFunction {\n    return AggregateFunction._create('sum', [this], 'sum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that calculates the average (mean) of a numeric field across multiple\n   * stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average age of users\n   * field(\"age\").average().as(\"averageAge\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'average' aggregation.\n   */\n  average(): AggregateFunction {\n    return AggregateFunction._create('average', [this], 'average');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the minimum value of a field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the lowest price of all products\n   * field(\"price\").minimum().as(\"lowestPrice\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'minimum' aggregation.\n   */\n  minimum(): AggregateFunction {\n    return AggregateFunction._create('minimum', [this], 'minimum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the maximum value of a field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the highest score in a leaderboard\n   * field(\"score\").maximum().as(\"highestScore\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'maximum' aggregation.\n   */\n  maximum(): AggregateFunction {\n    return AggregateFunction._create('maximum', [this], 'maximum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that counts the number of distinct values of the expression or field.\n   *\n   * @example\n   * ```typescript\n   * // Count the distinct number of products\n   * field(\"productId\").countDistinct().as(\"distinctProducts\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'count_distinct' aggregation.\n   */\n  countDistinct(): AggregateFunction {\n    return AggregateFunction._create('count_distinct', [this], 'countDistinct');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the larger value between this expression and another expression, based on Firestore's value type ordering.\n   *\n   * @example\n   * ```typescript\n   * // Returns the larger value between the 'timestamp' field and the current timestamp.\n   * field(\"timestamp\").logicalMaximum(Function.currentTimestamp());\n   * ```\n   *\n   * @param second - The second expression or literal to compare with.\n   * @param others - Optional additional expressions or literals to compare with.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n   */\n  logicalMaximum(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const values = [second, ...others];\n    return new FunctionExpression(\n      'maximum',\n      [this, ...values.map(valueToDefaultExpr)],\n      'logicalMaximum'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the smaller value between this expression and another expression, based on Firestore's value type ordering.\n   *\n   * @example\n   * ```typescript\n   * // Returns the smaller value between the 'timestamp' field and the current timestamp.\n   * field(\"timestamp\").logicalMinimum(Function.currentTimestamp());\n   * ```\n   *\n   * @param second - The second expression or literal to compare with.\n   * @param others - Optional additional expressions or literals to compare with.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n   */\n  logicalMinimum(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const values = [second, ...others];\n    return new FunctionExpression(\n      'minimum',\n      [this, ...values.map(valueToDefaultExpr)],\n      'minimum'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length (number of dimensions) of this Firestore Vector expression.\n   *\n   * @example\n   * ```typescript\n   * // Get the vector length (dimension) of the field 'embedding'.\n   * field(\"embedding\").vectorLength();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the vector.\n   */\n  vectorLength(): FunctionExpression {\n    return new FunctionExpression('vector_length', [this], 'vectorLength');\n  }\n\n  /**\n   * @beta\n   * Calculates the cosine distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n   * field(\"userVector\").cosineDistance(field(\"itemVector\"));\n   * ```\n   *\n   * @param vectorExpression - The other vector (represented as an Expression) to compare against.\n   * @returns A new `Expression` representing the cosine distance between the two vectors.\n   */\n  cosineDistance(vectorExpression: Expression): FunctionExpression;\n  /**\n   * @beta\n   * Calculates the Cosine distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Cosine distance between the 'location' field and a target location\n   * field(\"location\").cosineDistance(new VectorValue([37.7749, -122.4194]));\n   * ```\n   *\n   * @param vector - The other vector (as a VectorValue) to compare against.\n   * @returns A new `Expression` representing the Cosine* distance between the two vectors.\n   */\n  cosineDistance(vector: VectorValue | number[]): FunctionExpression;\n  cosineDistance(\n    other: Expression | VectorValue | number[]\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'cosine_distance',\n      [this, vectorToExpr(other)],\n      'cosineDistance'\n    );\n  }\n\n  /**\n   * @beta\n   * Calculates the dot product between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the dot product between a feature vector and a target vector\n   * field(\"features\").dotProduct([0.5, 0.8, 0.2]);\n   * ```\n   *\n   * @param vectorExpression - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the dot product between the two vectors.\n   */\n  dotProduct(vectorExpression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Calculates the dot product between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the dot product between a feature vector and a target vector\n   * field(\"features\").dotProduct(new VectorValue([0.5, 0.8, 0.2]));\n   * ```\n   *\n   * @param vector - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the dot product between the two vectors.\n   */\n  dotProduct(vector: VectorValue | number[]): FunctionExpression;\n  dotProduct(other: Expression | VectorValue | number[]): FunctionExpression {\n    return new FunctionExpression(\n      'dot_product',\n      [this, vectorToExpr(other)],\n      'dotProduct'\n    );\n  }\n\n  /**\n   * @beta\n   * Calculates the Euclidean distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Euclidean distance between the 'location' field and a target location\n   * field(\"location\").euclideanDistance([37.7749, -122.4194]);\n   * ```\n   *\n   * @param vectorExpression - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the Euclidean distance between the two vectors.\n   */\n  euclideanDistance(vectorExpression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Calculates the Euclidean distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Euclidean distance between the 'location' field and a target location\n   * field(\"location\").euclideanDistance(new VectorValue([37.7749, -122.4194]));\n   * ```\n   *\n   * @param vector - The other vector (as a VectorValue) to compare against.\n   * @returns A new `Expression` representing the Euclidean distance between the two vectors.\n   */\n  euclideanDistance(vector: VectorValue | number[]): FunctionExpression;\n  euclideanDistance(\n    other: Expression | VectorValue | number[]\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'euclidean_distance',\n      [this, vectorToExpr(other)],\n      'euclideanDistance'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'microseconds' field as microseconds since epoch.\n   * field(\"microseconds\").unixMicrosToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixMicrosToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_micros_to_timestamp',\n      [this],\n      'unixMicrosToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to microseconds since epoch.\n   * field(\"timestamp\").timestampToUnixMicros();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n   */\n  timestampToUnixMicros(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_micros',\n      [this],\n      'timestampToUnixMicros'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'milliseconds' field as milliseconds since epoch.\n   * field(\"milliseconds\").unixMillisToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixMillisToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_millis_to_timestamp',\n      [this],\n      'unixMillisToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to milliseconds since epoch.\n   * field(\"timestamp\").timestampToUnixMillis();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n   */\n  timestampToUnixMillis(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_millis',\n      [this],\n      'timestampToUnixMillis'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'seconds' field as seconds since epoch.\n   * field(\"seconds\").unixSecondsToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixSecondsToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_seconds_to_timestamp',\n      [this],\n      'unixSecondsToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to seconds since epoch.\n   * field(\"timestamp\").timestampToUnixSeconds();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n   */\n  timestampToUnixSeconds(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_seconds',\n      [this],\n      'timestampToUnixSeconds'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that adds a specified amount of time to this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Add some duration determined by field 'unit' and 'amount' to the 'timestamp' field.\n   * field(\"timestamp\").timestampAdd(field(\"unit\"), field(\"amount\"));\n   * ```\n   *\n   * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n   * @param amount - The expression evaluates to amount of the unit.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampAdd(unit: Expression, amount: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that adds a specified amount of time to this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Add 1 day to the 'timestamp' field.\n   * field(\"timestamp\").timestampAdd(\"day\", 1);\n   * ```\n   *\n   * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n   * @param amount - The amount of time to add.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampAdd(\n    unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n    amount: number\n  ): FunctionExpression;\n  timestampAdd(\n    unit:\n      | Expression\n      | 'microsecond'\n      | 'millisecond'\n      | 'second'\n      | 'minute'\n      | 'hour'\n      | 'day',\n    amount: Expression | number\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_add',\n      [this, valueToDefaultExpr(unit), valueToDefaultExpr(amount)],\n      'timestampAdd'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a specified amount of time from this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract some duration determined by field 'unit' and 'amount' from the 'timestamp' field.\n   * field(\"timestamp\").timestampSubtract(field(\"unit\"), field(\"amount\"));\n   * ```\n   *\n   * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n   * @param amount - The expression evaluates to amount of the unit.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampSubtract(unit: Expression, amount: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a specified amount of time from this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract 1 day from the 'timestamp' field.\n   * field(\"timestamp\").timestampSubtract(\"day\", 1);\n   * ```\n   *\n   * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n   * @param amount - The amount of time to subtract.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampSubtract(\n    unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n    amount: number\n  ): FunctionExpression;\n  timestampSubtract(\n    unit:\n      | Expression\n      | 'microsecond'\n      | 'millisecond'\n      | 'second'\n      | 'minute'\n      | 'hour'\n      | 'day',\n    amount: Expression | number\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_subtract',\n      [this, valueToDefaultExpr(unit), valueToDefaultExpr(amount)],\n      'timestampSubtract'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the document ID from a path.\n   *\n   * @example\n   * ```typescript\n   * // Get the document ID from a path.\n   * field(\"__path__\").documentId();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n   */\n  documentId(): FunctionExpression {\n    return new FunctionExpression('document_id', [this], 'documentId');\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns a substring of the results of this expression.\n   *\n   * @param position - Index of the first character of the substring.\n   * @param length - Length of the substring. If not provided, the substring will\n   * end at the end of the input.\n   */\n  substring(position: number, length?: number): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns a substring of the results of this expression.\n   *\n   * @param position - An expression returning the index of the first character of the substring.\n   * @param length - An expression returning the length of the substring. If not provided the\n   * substring will end at the end of the input.\n   */\n  substring(position: Expression, length?: Expression): FunctionExpression;\n  substring(\n    position: Expression | number,\n    length?: Expression | number\n  ): FunctionExpression {\n    const positionExpr = valueToDefaultExpr(position);\n    if (length === undefined) {\n      return new FunctionExpression(\n        'substring',\n        [this, positionExpr],\n        'substring'\n      );\n    } else {\n      return new FunctionExpression(\n        'substring',\n        [this, positionExpr, valueToDefaultExpr(length)],\n        'substring'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that indexes into an array from the beginning or end\n   * and returns the element. If the offset exceeds the array length, an error is\n   * returned. A negative offset, starts from the end.\n   *\n   * @example\n   * ```typescript\n   * // Return the value in the 'tags' field array at index `1`.\n   * field('tags').arrayGet(1);\n   * ```\n   *\n   * @param offset - The index of the element to return.\n   * @returns A new `Expression` representing the 'arrayGet' operation.\n   */\n  arrayGet(offset: number): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that indexes into an array from the beginning or end\n   * and returns the element. If the offset exceeds the array length, an error is\n   * returned. A negative offset, starts from the end.\n   *\n   * @example\n   * ```typescript\n   * // Return the value in the tags field array at index specified by field\n   * // 'favoriteTag'.\n   * field('tags').arrayGet(field('favoriteTag'));\n   * ```\n   *\n   * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n   * @returns A new `Expression` representing the 'arrayGet' operation.\n   */\n  arrayGet(offsetExpr: Expression): FunctionExpression;\n  arrayGet(offset: Expression | number): FunctionExpression {\n    return new FunctionExpression(\n      'array_get',\n      [this, valueToDefaultExpr(offset)],\n      'arrayGet'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that checks if a given expression produces an error.\n   *\n   * @example\n   * ```typescript\n   * // Check if the result of a calculation is an error\n   * field(\"title\").arrayContains(1).isError();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#BooleanExpression} representing the 'isError' check.\n   */\n  isError(): BooleanExpression {\n    return new FunctionExpression('is_error', [this], 'isError').asBoolean();\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the result of the `catchExpr` argument\n   * if there is an error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Returns the first item in the title field arrays, or returns\n   * // the entire title field if the array is empty or the field is another type.\n   * field(\"title\").arrayGet(0).ifError(field(\"title\"));\n   * ```\n   *\n   * @param catchExpr - The catch expression that will be evaluated and\n   * returned if this expression produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchExpr: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Returns the first item in the title field arrays, or returns\n   * // \"Default Title\"\n   * field(\"title\").arrayGet(0).ifError(\"Default Title\");\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: unknown): FunctionExpression;\n  ifError(catchValue: unknown): FunctionExpression | BooleanExpression {\n    const result = new FunctionExpression(\n      'if_error',\n      [this, valueToDefaultExpr(catchValue)],\n      'ifError'\n    );\n\n    return catchValue instanceof BooleanExpression\n      ? result.asBoolean()\n      : result;\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns `true` if the result of this expression\n   * is absent. Otherwise, returns `false` even if the value is `null`.\n   *\n   * @example\n   * ```typescript\n   * // Check if the field `value` is absent.\n   * field(\"value\").isAbsent();\n   * @example\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#BooleanExpression} representing the 'isAbsent' check.\n   */\n  isAbsent(): BooleanExpression {\n    return new FunctionExpression('is_absent', [this], 'isAbsent').asBoolean();\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that removes a key from the map produced by evaluating this expression.\n   *\n   * @example\n   * ```\n   * // Removes the key 'baz' from the input map.\n   * map({foo: 'bar', baz: true}).mapRemove('baz');\n   * ```\n   *\n   * @param key - The name of the key to remove from the input map.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapRemove' operation.\n   */\n  mapRemove(key: string): FunctionExpression;\n  /**\n   * @beta\n   *\n   * Creates an expression that removes a key from the map produced by evaluating this expression.\n   *\n   * @example\n   * ```\n   * // Removes the key 'baz' from the input map.\n   * map({foo: 'bar', baz: true}).mapRemove(constant('baz'));\n   * @example\n   * ```\n   *\n   * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapRemove' operation.\n   */\n  mapRemove(keyExpr: Expression): FunctionExpression;\n  mapRemove(stringExpr: Expression | string): FunctionExpression {\n    return new FunctionExpression(\n      'map_remove',\n      [this, valueToDefaultExpr(stringExpr)],\n      'mapRemove'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that merges multiple map values.\n   *\n   * @example\n   * ```\n   * // Merges the map in the settings field with, a map literal, and a map in\n   * // that is conditionally returned by another expression\n   * field('settings').mapMerge({ enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n   * ```\n   *\n   * @param secondMap - A required second map to merge. Represented as a literal or\n   * an expression that returns a map.\n   * @param otherMaps - Optional additional maps to merge. Each map is represented\n   * as a literal or an expression that returns a map.\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapMerge' operation.\n   */\n  mapMerge(\n    secondMap: Record<string, unknown> | Expression,\n    ...otherMaps: Array<Record<string, unknown> | Expression>\n  ): FunctionExpression {\n    const secondMapExpr = valueToDefaultExpr(secondMap);\n    const otherMapExprs = otherMaps.map(valueToDefaultExpr);\n    return new FunctionExpression(\n      'map_merge',\n      [this, secondMapExpr, ...otherMapExprs],\n      'mapMerge'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the value of this expression raised to the power of another expression.\n   *\n   * @example\n   * ```typescript\n   * // Raise the value of the 'base' field to the power of the 'exponent' field.\n   * field(\"base\").pow(field(\"exponent\"));\n   * ```\n   *\n   * @param exponent - The expression to raise this expression to the power of.\n   * @returns A new `Expression` representing the power operation.\n   */\n  pow(exponent: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the value of this expression raised to the power of a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Raise the value of the 'base' field to the power of 2.\n   * field(\"base\").pow(2);\n   * ```\n   *\n   * @param exponent - The constant value to raise this expression to the power of.\n   * @returns A new `Expression` representing the power operation.\n   */\n  pow(exponent: number): FunctionExpression;\n  pow(exponent: number | Expression): FunctionExpression {\n    return new FunctionExpression('pow', [this, valueToDefaultExpr(exponent)]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the nearest whole number.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field.\n   * field(\"price\").round();\n   * ```\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(): FunctionExpression;\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field to two decimal places.\n   * field(\"price\").round(2);\n   * ```\n   *\n   * @param decimalPlaces - A constant specifying the rounding precision in decimal places.\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(decimalPlaces: number): FunctionExpression;\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field to two decimal places.\n   * field(\"price\").round(constant(2));\n   * ```\n   *\n   * @param decimalPlaces - An expression specifying the rounding precision in decimal places.\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(decimalPlaces: Expression): FunctionExpression;\n  round(decimalPlaces?: number | Expression): FunctionExpression {\n    if (decimalPlaces === undefined) {\n      return new FunctionExpression('round', [this]);\n    } else {\n      return new FunctionExpression(\n        'round',\n        [this, valueToDefaultExpr(decimalPlaces)],\n        'round'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the collection ID from a path.\n   *\n   * @example\n   * ```typescript\n   * // Get the collection ID from a path.\n   * field(\"__path__\").collectionId();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n   */\n  collectionId(): FunctionExpression {\n    return new FunctionExpression('collection_id', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n   *\n   * @example\n   * ```typescript\n   * // Get the length of the 'name' field.\n   * field(\"name\").length();\n   *\n   * // Get the number of items in the 'cart' array.\n   * field(\"cart\").length();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n   */\n  length(): FunctionExpression {\n    return new FunctionExpression('length', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the natural logarithm of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the natural logarithm of the 'value' field.\n   * field(\"value\").ln();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the natural logarithm of the numeric value.\n   */\n  ln(): FunctionExpression {\n    return new FunctionExpression('ln', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the square root of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the square root of the 'value' field.\n   * field(\"value\").sqrt();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n   */\n  sqrt(): FunctionExpression {\n    return new FunctionExpression('sqrt', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses a string.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myString' field.\n   * field(\"myString\").stringReverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n   */\n  stringReverse(): FunctionExpression {\n    return new FunctionExpression('string_reverse', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the `elseValue` argument if this expression results in an absent value, else\n   * return the result of the this expression evaluation.\n   *\n   * @example\n   * ```typescript\n   * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n   * // if the field is absent.\n   * field(\"optional_field\").ifAbsent(\"default_value\")\n   * ```\n   *\n   * @param elseValue - The value that will be returned if this Expression evaluates to an absent value.\n   * @returns A new [Expression] representing the ifAbsent operation.\n   */\n  ifAbsent(elseValue: unknown): Expression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the `elseValue` argument if this expression results in an absent value, else\n   * return the result of this expression evaluation.\n   *\n   * ```typescript\n   * // Returns the value of the optional field 'optional_field', or if that is\n   * // absent, then returns the value of the field `\n   * field(\"optional_field\").ifAbsent(field('default_field'))\n   * ```\n   *\n   * @param elseExpression - The Expression that will be evaluated if this Expression evaluates to an absent value.\n   * @returns A new [Expression] representing the ifAbsent operation.\n   */\n  ifAbsent(elseExpression: unknown): Expression;\n\n  ifAbsent(elseValueOrExpression: Expression | unknown): Expression {\n    return new FunctionExpression(\n      'if_absent',\n      [this, valueToDefaultExpr(elseValueOrExpression)],\n      'ifAbsent'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that joins the elements of an array into a string.\n   *\n   * @example\n   * ```typescript\n   * // Join the elements of the 'tags' field with the delimiter from the 'separator' field.\n   * field(\"tags\").join(field(\"separator\"))\n   * ```\n   *\n   * @param delimiterExpression - The expression that evaluates to the delimiter string.\n   * @returns A new Expression representing the join operation.\n   */\n  join(delimiterExpression: Expression): Expression;\n\n  /**\n   * @beta\n   * Creates an expression that joins the elements of an array field into a string.\n   *\n   * @example\n   * ```typescript\n   * // Join the elements of the 'tags' field with a comma and space.\n   * field(\"tags\").join(\", \")\n   * ```\n   *\n   * @param delimiter - The string to use as a delimiter.\n   * @returns A new Expression representing the join operation.\n   */\n  join(delimiter: string): Expression;\n\n  join(delimeterValueOrExpression: string | Expression): Expression {\n    return new FunctionExpression(\n      'join',\n      [this, valueToDefaultExpr(delimeterValueOrExpression)],\n      'join'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the base-10 logarithm of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the base-10 logarithm of the 'value' field.\n   * field(\"value\").log10();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the base-10 logarithm of the numeric value.\n   */\n  log10(): FunctionExpression {\n    return new FunctionExpression('log10', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the sum of the elements in an array.\n   *\n   * @example\n   * ```typescript\n   * // Compute the sum of the elements in the 'scores' field.\n   * field(\"scores\").arraySum();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the sum of the elements in the array.\n   */\n  arraySum(): FunctionExpression {\n    return new FunctionExpression('sum', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that splits the result of this expression into an\n   * array of substrings based on the provided delimiter.\n   *\n   * @example\n   * ```typescript\n   * // Split the 'scoresCsv' field on delimiter ','\n   * field('scoresCsv').split(',')\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n   */\n  split(delimiter: string): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that splits the result of this expression into an\n   * array of substrings based on the provided delimiter.\n   *\n   * @example\n   * ```typescript\n   * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n   * field('scores').split(conditional(field('format').equal('csv'), constant(','), constant(':'))\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n   */\n  split(delimiter: Expression): FunctionExpression;\n  split(delimiter: string | Expression): FunctionExpression {\n    return new FunctionExpression('split', [\n      this,\n      valueToDefaultExpr(delimiter)\n    ]);\n  }\n\n  /**\n   * Creates an expression that truncates a timestamp to a specified granularity.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'createdAt' timestamp to the beginning of the day.\n   * field('createdAt').timestampTruncate('day')\n   * ```\n   *\n   * @param granularity - The granularity to truncate to.\n   * @param timezone - The timezone to use for truncation. Valid values are from\n   * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n   * @returns A new `Expression` representing the truncated timestamp.\n   */\n  timestampTruncate(\n    granularity: TimeGranularity,\n    timezone?: string | Expression\n  ): FunctionExpression;\n\n  /**\n   * Creates an expression that truncates a timestamp to a specified granularity.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n   * field('createdAt').timestampTruncate(field('granularity'))\n   * ```\n   *\n   * @param granularity - The granularity to truncate to.\n   * @param timezone - The timezone to use for truncation. Valid values are from\n   * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n   * @returns A new `Expression` representing the truncated timestamp.\n   */\n  timestampTruncate(\n    granularity: Expression,\n    timezone?: string | Expression\n  ): FunctionExpression;\n  timestampTruncate(\n    granularity: TimeGranularity | Expression,\n    timezone?: string | Expression\n  ): FunctionExpression {\n    const internalGranularity = isString(granularity)\n      ? granularity.toLowerCase()\n      : granularity;\n\n    const args = [this, valueToDefaultExpr(internalGranularity)];\n    if (timezone) {\n      args.push(valueToDefaultExpr(timezone));\n    }\n    return new FunctionExpression('timestamp_trunc', args);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the data type of this expression's result, as a string.\n   *\n   * @example\n   * ```typescript\n   * // Get the data type of the value in field 'title'\n   * field('title').type()\n   * ```\n   *\n   * @returns A new `Expression` representing the data type.\n   */\n  type(): FunctionExpression {\n    return new FunctionExpression('type', [this]);\n  }\n\n  // TODO(new-expression): Add new expression method definitions above this line\n\n  /**\n   * @beta\n   * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on this expression.\n   *\n   * @example\n   * ```typescript\n   * // Sort documents by the 'name' field in ascending order\n   * pipeline().collection(\"users\")\n   *   .sort(field(\"name\").ascending());\n   * ```\n   *\n   * @returns A new `Ordering` for ascending sorting.\n   */\n  ascending(): Ordering {\n    return ascending(this);\n  }\n\n  /**\n   * @beta\n   * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on this expression.\n   *\n   * @example\n   * ```typescript\n   * // Sort documents by the 'createdAt' field in descending order\n   * firestore.pipeline().collection(\"users\")\n   *   .sort(field(\"createdAt\").descending());\n   * ```\n   *\n   * @returns A new `Ordering` for descending sorting.\n   */\n  descending(): Ordering {\n    return descending(this);\n  }\n\n  /**\n   * @beta\n   * Assigns an alias to this expression.\n   *\n   * Aliases are useful for renaming fields in the output of a stage or for giving meaningful\n   * names to calculated values.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the total price and assign it the alias \"totalPrice\" and add it to the output.\n   * firestore.pipeline().collection(\"items\")\n   *   .addFields(field(\"price\").multiply(field(\"quantity\")).as(\"totalPrice\"));\n   * ```\n   *\n   * @param name - The alias to assign to this expression.\n   * @returns A new {@link @firebase/firestore/pipelines#AliasedExpression} that wraps this\n   *     expression and associates it with the provided alias.\n   */\n  as(name: string): AliasedExpression {\n    return new AliasedExpression(this, name, 'as');\n  }\n}\n\n/**\n * @beta\n * Specify time granularity for expressions.\n */\nexport type TimeGranularity =\n  | 'microsecond'\n  | 'millisecond'\n  | 'second'\n  | 'minute'\n  | 'hour'\n  | 'day'\n  | 'week'\n  | 'week(monday)'\n  | 'week(tuesday)'\n  | 'week(wednesday)'\n  | 'week(thursday)'\n  | 'week(friday)'\n  | 'week(saturday)'\n  | 'week(sunday)'\n  | 'isoWeek'\n  | 'month'\n  | 'quarter'\n  | 'year'\n  | 'isoYear';\n\n/**\n * @beta\n *\n * An interface that represents a selectable expression.\n */\nexport interface Selectable {\n  selectable: true;\n  /**\n   * @private\n   * @internal\n   */\n  readonly alias: string;\n  /**\n   * @private\n   * @internal\n   */\n  readonly expr: Expression;\n}\n\n/**\n * @beta\n *\n * A class that represents an aggregate function.\n */\nexport class AggregateFunction implements ProtoValueSerializable, UserData {\n  exprType: ExpressionType = 'AggregateFunction';\n\n  /**\n   * @internal\n   */\n  _methodName?: string;\n\n  constructor(private name: string, private params: Expression[]) {}\n\n  /**\n   * @internal\n   * @private\n   */\n  static _create(\n    name: string,\n    params: Expression[],\n    methodName: string\n  ): AggregateFunction {\n    const af = new AggregateFunction(name, params);\n    af._methodName = methodName;\n\n    return af;\n  }\n\n  /**\n   * @beta\n   * Assigns an alias to this AggregateFunction. The alias specifies the name that\n   * the aggregated value will have in the output document.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average price of all items and assign it the alias \"averagePrice\".\n   * firestore.pipeline().collection(\"items\")\n   *   .aggregate(field(\"price\").average().as(\"averagePrice\"));\n   * ```\n   *\n   * @param name - The alias to assign to this AggregateFunction.\n   * @returns A new {@link @firebase/firestore/pipelines#AliasedAggregate} that wraps this\n   *     AggregateFunction and associates it with the provided alias.\n   */\n  as(name: string): AliasedAggregate {\n    return new AliasedAggregate(this, name, 'as');\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      functionValue: {\n        name: this.name,\n        args: this.params.map(p => p._toProto(serializer))\n      }\n    };\n  }\n\n  _protoValueType = 'ProtoValue' as const;\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.params.forEach(expr => {\n      return expr._readUserData(context);\n    });\n  }\n}\n\n/**\n * @beta\n *\n * An AggregateFunction with alias.\n */\nexport class AliasedAggregate implements UserData {\n  constructor(\n    readonly aggregate: AggregateFunction,\n    readonly alias: string,\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.aggregate._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class AliasedExpression implements Selectable, UserData {\n  exprType: ExpressionType = 'AliasedExpression';\n  selectable = true as const;\n\n  constructor(\n    readonly expr: Expression,\n    readonly alias: string,\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.expr._readUserData(context);\n  }\n}\n\n/**\n * @internal\n */\nclass ListOfExprs extends Expression implements UserData {\n  expressionType: ExpressionType = 'ListOfExpressions';\n\n  constructor(\n    private exprs: Expression[],\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      arrayValue: {\n        values: this.exprs.map(p => p._toProto(serializer)!)\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.exprs.forEach((expr: Expression) => expr._readUserData(context));\n  }\n}\n\n/**\n * @beta\n *\n * Represents a reference to a field in a Firestore document, or outputs of a {@link @firebase/firestore/pipelines#Pipeline} stage.\n *\n * <p>Field references are used to access document field values in expressions and to specify fields\n * for sorting, filtering, and projecting data in Firestore pipelines.\n *\n * <p>You can create a `Field` instance using the static {@link @firebase/firestore/pipelines#field} method:\n *\n * @example\n * ```typescript\n * // Create a Field instance for the 'name' field\n * const nameField = field(\"name\");\n *\n * // Create a Field instance for a nested field 'address.city'\n * const cityField = field(\"address.city\");\n * ```\n */\nexport class Field extends Expression implements Selectable {\n  readonly expressionType: ExpressionType = 'Field';\n  selectable = true as const;\n\n  /**\n   * @internal\n   * @private\n   * @hideconstructor\n   * @param fieldPath\n   */\n  constructor(\n    private fieldPath: InternalFieldPath,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  get fieldName(): string {\n    return this.fieldPath.canonicalString();\n  }\n\n  get alias(): string {\n    return this.fieldName;\n  }\n\n  get expr(): Expression {\n    return this;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      fieldReferenceValue: this.fieldPath.canonicalString()\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {}\n}\n\n/**\n * @beta\n * Creates a {@link @firebase/firestore/pipelines#Field} instance representing the field at the given path.\n *\n * The path can be a simple field name (e.g., \"name\") or a dot-separated path to a nested field\n * (e.g., \"address.city\").\n *\n * @example\n * ```typescript\n * // Create a Field instance for the 'title' field\n * const titleField = field(\"title\");\n *\n * // Create a Field instance for a nested field 'author.firstName'\n * const authorFirstNameField = field(\"author.firstName\");\n * ```\n *\n * @param name - The path to the field.\n * @returns A new {@link @firebase/firestore/pipelines#Field} instance representing the specified field.\n */\nexport function field(name: string): Field;\n\n/**\n * @beta\n * Creates a {@link @firebase/firestore/pipelines#Field} instance representing the field at the given path.\n *\n * @param path - A FieldPath specifying the field.\n * @returns A new {@link @firebase/firestore/pipelines#Field} instance representing the specified field.\n */\nexport function field(path: FieldPath): Field;\nexport function field(nameOrPath: string | FieldPath): Field {\n  return _field(nameOrPath, 'field');\n}\n\nexport function _field(\n  nameOrPath: string | FieldPath,\n  methodName: string | undefined\n): Field {\n  if (typeof nameOrPath === 'string') {\n    if (DOCUMENT_KEY_NAME === nameOrPath) {\n      return new Field(documentIdFieldPath()._internalPath, methodName);\n    }\n    return new Field(fieldPathFromArgument('field', nameOrPath), methodName);\n  } else {\n    return new Field(nameOrPath._internalPath, methodName);\n  }\n}\n\n/**\n * @internal\n *\n * Represents a constant value that can be used in a Firestore pipeline expression.\n *\n * You can create a `Constant` instance using the static {@link @firebase/firestore/pipelines#field} method:\n *\n * @example\n * ```typescript\n * // Create a Constant instance for the number 10\n * const ten = constant(10);\n *\n * // Create a Constant instance for the string \"hello\"\n * const hello = constant(\"hello\");\n * ```\n */\nexport class Constant extends Expression {\n  readonly expressionType: ExpressionType = 'Constant';\n\n  private _protoValue?: ProtoValue;\n\n  /**\n   * @private\n   * @internal\n   * @hideconstructor\n   * @param value - The value of the constant.\n   */\n  constructor(\n    private value: unknown,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  static _fromProto(value: ProtoValue): Constant {\n    const result = new Constant(value, undefined);\n    result._protoValue = value;\n    return result;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(_: JsonProtoSerializer): ProtoValue {\n    hardAssert(\n      this._protoValue !== undefined,\n      0x00ed,\n      'Value of this constant has not been serialized to proto value'\n    );\n    return this._protoValue;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    if (isFirestoreValue(this._protoValue)) {\n      return;\n    } else {\n      this._protoValue = parseData(this.value, context)!;\n    }\n  }\n}\n\n/**\n * @beta\n * Creates a `Constant` instance for a number value.\n *\n * @param value - The number value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: number): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a string value.\n *\n * @param value - The string value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: string): Expression;\n\n/**\n * @beta\n * Creates a `BooleanExpression` instance for a boolean value.\n *\n * @param value - The boolean value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: boolean): BooleanExpression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a null value.\n *\n * @param value - The null value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: null): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a GeoPoint value.\n *\n * @param value - The GeoPoint value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: GeoPoint): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Timestamp value.\n *\n * @param value - The Timestamp value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Timestamp): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Date value.\n *\n * @param value - The Date value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Date): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Bytes value.\n *\n * @param value - The Bytes value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Bytes): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a DocumentReference value.\n *\n * @param value - The DocumentReference value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: DocumentReference): Expression;\n\n/**\n * Creates a `Constant` instance for a Firestore proto value.\n * For internal use only.\n * @private\n * @internal\n * @param value - The Firestore proto value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: ProtoValue): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a VectorValue value.\n *\n * @param value - The VectorValue value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: VectorValue): Expression;\n\nexport function constant(value: unknown): Expression | BooleanExpression {\n  return _constant(value, 'constant');\n}\n\n/**\n * @internal\n * @private\n * @param value\n * @param methodName\n */\nexport function _constant(\n  value: unknown,\n  methodName: string | undefined\n): Constant | BooleanExpression {\n  const c = new Constant(value, methodName);\n  if (typeof value === 'boolean') {\n    return new BooleanConstant(c);\n  } else {\n    return c;\n  }\n}\n\n/**\n * Internal only\n * @internal\n * @private\n */\nexport class MapValue extends Expression {\n  constructor(\n    private plainObject: Map<string, Expression>,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  expressionType: ExpressionType = 'Constant';\n\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.plainObject.forEach(expr => {\n      expr._readUserData(context);\n    });\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return toMapValue(serializer, this.plainObject);\n  }\n}\n\n/**\n * @beta\n *\n * This class defines the base class for Firestore {@link @firebase/firestore/pipelines#Pipeline} functions, which can be evaluated within pipeline\n * execution.\n *\n * Typically, you would not use this class or its children directly. Use either the functions like {@link @firebase/firestore/pipelines#and}, {@link @firebase/firestore/pipelines#(equal:1)},\n * or the methods on {@link @firebase/firestore/pipelines#Expression} ({@link @firebase/firestore/pipelines#Expression.(equal:1)}, {@link @firebase/firestore/pipelines#Expression.(lessThan:1)}, etc.) to construct new Function instances.\n */\nexport class FunctionExpression extends Expression {\n  readonly expressionType: ExpressionType = 'Function';\n\n  constructor(name: string, params: Expression[]);\n  constructor(\n    name: string,\n    params: Expression[],\n    _methodName: string | undefined\n  );\n  constructor(\n    private name: string,\n    private params: Expression[],\n    readonly _methodName?: string\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      functionValue: {\n        name: this.name,\n        args: this.params.map(p => p._toProto(serializer))\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.params.forEach(expr => {\n      return expr._readUserData(context);\n    });\n  }\n}\n\n/**\n * @beta\n *\n * An interface that represents a filter condition.\n */\nexport abstract class BooleanExpression extends Expression {\n  abstract get _expr(): Expression;\n\n  get _methodName(): string | undefined {\n    return this._expr._methodName;\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the count of input documents satisfying\n   * this boolean expression.\n   *\n   * @example\n   * ```typescript\n   * // Find the count of documents with a score greater than 90\n   * field(\"score\").greaterThan(90).countIf().as(\"highestScore\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'countIf' aggregation.\n   */\n  countIf(): AggregateFunction {\n    return AggregateFunction._create('count_if', [this], 'countIf');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that negates this boolean expression.\n   *\n   * @example\n   * ```typescript\n   * // Find documents where the 'tags' field does not contain 'completed'\n   * field(\"tags\").arrayContains(\"completed\").not();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the negated filter condition.\n   */\n  not(): BooleanExpression {\n    return new FunctionExpression('not', [this], 'not').asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates a conditional expression that evaluates to the 'then' expression\n   * if `this` expression evaluates to `true`,\n   * or evaluates to the 'else' expression if `this` expressions evaluates `false`.\n   *\n   * @example\n   * ```typescript\n   * // If 'age' is greater than 18, return \"Adult\"; otherwise, return \"Minor\".\n   * field(\"age\").greaterThanOrEqual(18).conditional(constant(\"Adult\"), constant(\"Minor\"));\n   * ```\n   *\n   * @param thenExpr - The expression to evaluate if the condition is true.\n   * @param elseExpr - The expression to evaluate if the condition is false.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the conditional expression.\n   */\n  conditional(thenExpr: Expression, elseExpr: Expression): FunctionExpression {\n    return new FunctionExpression(\n      'conditional',\n      [this, thenExpr, elseExpr],\n      'conditional'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error\n   * // but always returns a boolean expression.\n   * constant(50).divide('length').gt(1).ifError(constant(false));\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: BooleanExpression): BooleanExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error\n   * // but always returns a boolean expression.\n   * constant(50).divide('length').gt(1).ifError(false);\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: boolean): BooleanExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error.\n   * constant(50).divide('length').gt(1).ifError(constant(0));\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error.\n   * constant(50).divide('length').gt(1).ifError(0);\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: unknown): FunctionExpression;\n  ifError(catchValue: unknown): unknown {\n    const normalizedCatchValue = valueToDefaultExpr(catchValue);\n    const expr = new FunctionExpression(\n      'if_error',\n      [this, normalizedCatchValue],\n      'ifError'\n    );\n\n    return normalizedCatchValue instanceof BooleanExpression\n      ? expr.asBoolean()\n      : expr;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return this._expr._toProto(serializer);\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this._expr._readUserData(context);\n  }\n}\n\nexport class BooleanFunctionExpression extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Function';\n  constructor(readonly _expr: FunctionExpression) {\n    super();\n  }\n}\n\nexport class BooleanConstant extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Constant';\n  constructor(readonly _expr: Constant) {\n    super();\n  }\n}\n\nexport class BooleanField extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Field';\n  constructor(readonly _expr: Field) {\n    super();\n  }\n}\n\n/**\n * @beta\n * Creates an aggregation that counts the number of stage inputs where the provided\n * boolean expression evaluates to true.\n *\n * @example\n * ```typescript\n * // Count the number of documents where 'is_active' field equals true\n * countIf(field(\"is_active\").equal(true)).as(\"numActiveDocuments\");\n * ```\n *\n * @param booleanExpr - The boolean expression to evaluate on each input.\n * @returns A new `AggregateFunction` representing the 'countIf' aggregation.\n */\nexport function countIf(booleanExpr: BooleanExpression): AggregateFunction {\n  return booleanExpr.countIf();\n}\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index 1.\n * arrayGet('tags', 1);\n * ```\n *\n * @param arrayField - The name of the array field.\n * @param offset - The index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayField: string,\n  offset: number\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index specified by field\n * // 'favoriteTag'.\n * arrayGet('tags', field('favoriteTag'));\n * ```\n *\n * @param arrayField - The name of the array field.\n * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayField: string,\n  offsetExpr: Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index 1.\n * arrayGet(field('tags'), 1);\n * ```\n *\n * @param arrayExpression - An `Expression` evaluating to an array.\n * @param offset - The index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayExpression: Expression,\n  offset: number\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index specified by field\n * // 'favoriteTag'.\n * arrayGet(field('tags'), field('favoriteTag'));\n * ```\n *\n * @param arrayExpression - An `Expression` evaluating to an array.\n * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayExpression: Expression,\n  offsetExpr: Expression\n): FunctionExpression;\nexport function arrayGet(\n  array: Expression | string,\n  offset: Expression | number\n): FunctionExpression {\n  return fieldOrExpression(array).arrayGet(valueToDefaultExpr(offset));\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a given expression produces an error.\n *\n * @example\n * ```typescript\n * // Check if the result of a calculation is an error\n * isError(field(\"title\").arrayContains(1));\n * ```\n *\n * @param value - The expression to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isError' check.\n */\nexport function isError(value: Expression): BooleanExpression {\n  return value.isError().asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * This overload is useful when a BooleanExpression is required.\n *\n * @example\n * ```typescript\n * // Create an expression that protects against a divide by zero error\n * // but always returns a boolean expression.\n * ifError(constant(50).divide('length').gt(1), constant(false));\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchExpr - The catch expression that will be evaluated and\n * returned if the tryExpr produces an error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: BooleanExpression,\n  catchExpr: BooleanExpression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the first item in the title field arrays, or returns\n * // the entire title field if the array is empty or the field is another type.\n * ifError(field(\"title\").arrayGet(0), field(\"title\"));\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchExpr - The catch expression that will be evaluated and\n * returned if the tryExpr produces an error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: Expression,\n  catchExpr: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the first item in the title field arrays, or returns\n * // \"Default Title\"\n * ifError(field(\"title\").arrayGet(0), \"Default Title\");\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchValue - The value that will be returned if the tryExpr produces an\n * error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: Expression,\n  catchValue: unknown\n): FunctionExpression;\n\nexport function ifError(\n  tryExpr: Expression,\n  catchValue: unknown\n): FunctionExpression | BooleanExpression {\n  if (\n    tryExpr instanceof BooleanExpression &&\n    catchValue instanceof BooleanExpression\n  ) {\n    return tryExpr.ifError(catchValue).asBoolean();\n  } else {\n    return tryExpr.ifError(valueToDefaultExpr(catchValue));\n  }\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns `true` if a value is absent. Otherwise,\n * returns `false` even if the value is `null`.\n *\n * @example\n * ```typescript\n * // Check if the field `value` is absent.\n * isAbsent(field(\"value\"));\n * ```\n *\n * @param value - The expression to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isAbsent' check.\n */\nexport function isAbsent(value: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns `true` if a field is absent. Otherwise,\n * returns `false` even if the field value is `null`.\n *\n * @example\n * ```typescript\n * // Check if the field `value` is absent.\n * isAbsent(\"value\");\n * ```\n *\n * @param field - The field to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isAbsent' check.\n */\nexport function isAbsent(field: string): BooleanExpression;\nexport function isAbsent(value: Expression | string): BooleanExpression {\n  return fieldOrExpression(value).isAbsent();\n}\n\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map at the specified field name.\n *\n * @example\n * ```\n * // Removes the key 'city' field from the map in the address field of the input document.\n * mapRemove('address', 'city');\n * ```\n *\n * @param mapField - The name of a field containing a map value.\n * @param key - The name of the key to remove from the input map.\n */\nexport function mapRemove(mapField: string, key: string): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map produced by evaluating an expression.\n *\n * @example\n * ```\n * // Removes the key 'baz' from the input map.\n * mapRemove(map({foo: 'bar', baz: true}), 'baz');\n * @example\n * ```\n *\n * @param mapExpr - An expression return a map value.\n * @param key - The name of the key to remove from the input map.\n */\nexport function mapRemove(mapExpr: Expression, key: string): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map at the specified field name.\n *\n * @example\n * ```\n * // Removes the key 'city' field from the map in the address field of the input document.\n * mapRemove('address', constant('city'));\n * ```\n *\n * @param mapField - The name of a field containing a map value.\n * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n */\nexport function mapRemove(\n  mapField: string,\n  keyExpr: Expression\n): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map produced by evaluating an expression.\n *\n * @example\n * ```\n * // Removes the key 'baz' from the input map.\n * mapRemove(map({foo: 'bar', baz: true}), constant('baz'));\n * @example\n * ```\n *\n * @param mapExpr - An expression return a map value.\n * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n */\nexport function mapRemove(\n  mapExpr: Expression,\n  keyExpr: Expression\n): FunctionExpression;\n\nexport function mapRemove(\n  mapExpr: Expression | string,\n  stringExpr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(mapExpr).mapRemove(valueToDefaultExpr(stringExpr));\n}\n\n/**\n * @beta\n *\n * Creates an expression that merges multiple map values.\n *\n * @example\n * ```\n * // Merges the map in the settings field with, a map literal, and a map in\n * // that is conditionally returned by another expression\n * mapMerge('settings', { enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n * ```\n *\n * @param mapField - Name of a field containing a map value that will be merged.\n * @param secondMap - A required second map to merge. Represented as a literal or\n * an expression that returns a map.\n * @param otherMaps - Optional additional maps to merge. Each map is represented\n * as a literal or an expression that returns a map.\n */\nexport function mapMerge(\n  mapField: string,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that merges multiple map values.\n *\n * @example\n * ```\n * // Merges the map in the settings field with, a map literal, and a map in\n * // that is conditionally returned by another expression\n * mapMerge(field('settings'), { enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n * ```\n *\n * @param firstMap - An expression or literal map value that will be merged.\n * @param secondMap - A required second map to merge. Represented as a literal or\n * an expression that returns a map.\n * @param otherMaps - Optional additional maps to merge. Each map is represented\n * as a literal or an expression that returns a map.\n */\nexport function mapMerge(\n  firstMap: Record<string, unknown> | Expression,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression;\n\nexport function mapMerge(\n  firstMap: string | Record<string, unknown> | Expression,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression {\n  const secondMapExpr = valueToDefaultExpr(secondMap);\n  const otherMapExprs = otherMaps.map(valueToDefaultExpr);\n  return fieldOrExpression(firstMap).mapMerge(secondMapExpr, ...otherMapExprs);\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the document ID from a path.\n *\n * @example\n * ```typescript\n * // Get the document ID from a path.\n * documentId(myDocumentReference);\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n */\nexport function documentId(\n  documentPath: string | DocumentReference\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the document ID from a path.\n *\n * @example\n * ```typescript\n * // Get the document ID from a path.\n * documentId(field(\"__path__\"));\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n */\nexport function documentId(documentPathExpr: Expression): FunctionExpression;\n\nexport function documentId(\n  documentPath: Expression | string | DocumentReference\n): FunctionExpression {\n  // @ts-ignore\n  const documentPathExpr = valueToDefaultExpr(documentPath);\n  return documentPathExpr.documentId();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param field - The name of a field containing a string or byte array to compute the substring from.\n * @param position - Index of the first character of the substring.\n * @param length - Length of the substring.\n */\nexport function substring(\n  field: string,\n  position: number,\n  length?: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param input - An expression returning a string or byte array to compute the substring from.\n * @param position - Index of the first character of the substring.\n * @param length - Length of the substring.\n */\nexport function substring(\n  input: Expression,\n  position: number,\n  length?: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param field - The name of a field containing a string or byte array to compute the substring from.\n * @param position - An expression that returns the index of the first character of the substring.\n * @param length - An expression that returns the length of the substring.\n */\nexport function substring(\n  field: string,\n  position: Expression,\n  length?: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param input - An expression returning a string or byte array to compute the substring from.\n * @param position - An expression that returns the index of the first character of the substring.\n * @param length - An expression that returns the length of the substring.\n */\nexport function substring(\n  input: Expression,\n  position: Expression,\n  length?: Expression\n): FunctionExpression;\n\nexport function substring(\n  field: Expression | string,\n  position: Expression | number,\n  length?: Expression | number\n): FunctionExpression {\n  const fieldExpr = fieldOrExpression(field);\n  const positionExpr = valueToDefaultExpr(position);\n  const lengthExpr =\n    length === undefined ? undefined : valueToDefaultExpr(length);\n  return fieldExpr.substring(positionExpr, lengthExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that adds two expressions together.\n *\n * @example\n * ```typescript\n * // Add the value of the 'quantity' field and the 'reserve' field.\n * add(field(\"quantity\"), field(\"reserve\"));\n * ```\n *\n * @param first - The first expression to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the addition operation.\n */\nexport function add(\n  first: Expression,\n  second: Expression | unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a field's value to an expression.\n *\n * @example\n * ```typescript\n * // Add the value of the 'quantity' field and the 'reserve' field.\n * add(\"quantity\", field(\"reserve\"));\n * ```\n *\n * @param fieldName - The name of the field containing the value to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the addition operation.\n */\nexport function add(\n  fieldName: string,\n  second: Expression | unknown\n): FunctionExpression;\n\nexport function add(\n  first: Expression | string,\n  second: Expression | unknown\n): FunctionExpression {\n  return fieldOrExpression(first).add(valueToDefaultExpr(second));\n}\n\n/**\n * @beta\n *\n * Creates an expression that subtracts two expressions.\n *\n * @example\n * ```typescript\n * // Subtract the 'discount' field from the 'price' field\n * subtract(field(\"price\"), field(\"discount\"));\n * ```\n *\n * @param left - The expression to subtract from.\n * @param right - The expression to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  left: Expression,\n  right: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a constant value from an expression.\n *\n * @example\n * ```typescript\n * // Subtract the constant value 2 from the 'value' field\n * subtract(field(\"value\"), 2);\n * ```\n *\n * @param expression - The expression to subtract from.\n * @param value - The constant value to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  expression: Expression,\n  value: unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts an expression from a field's value.\n *\n * @example\n * ```typescript\n * // Subtract the 'discount' field from the 'price' field\n * subtract(\"price\", field(\"discount\"));\n * ```\n *\n * @param fieldName - The field name to subtract from.\n * @param expression - The expression to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  fieldName: string,\n  expression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a constant value from a field's value.\n *\n * @example\n * ```typescript\n * // Subtract 20 from the value of the 'total' field\n * subtract(\"total\", 20);\n * ```\n *\n * @param fieldName - The field name to subtract from.\n * @param value - The constant value to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(fieldName: string, value: unknown): FunctionExpression;\nexport function subtract(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.subtract(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that multiplies two expressions together.\n *\n * @example\n * ```typescript\n * // Multiply the 'quantity' field by the 'price' field\n * multiply(field(\"quantity\"), field(\"price\"));\n * ```\n *\n * @param first - The first expression to multiply.\n * @param second - The second expression or literal to multiply.\n * @param others - Optional additional expressions or literals to multiply.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the multiplication operation.\n */\nexport function multiply(\n  first: Expression,\n  second: Expression | unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that multiplies a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Multiply the 'quantity' field by the 'price' field\n * multiply(\"quantity\", field(\"price\"));\n * ```\n *\n * @param fieldName - The name of the field containing the value to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the multiplication operation.\n */\nexport function multiply(\n  fieldName: string,\n  second: Expression | unknown\n): FunctionExpression;\n\nexport function multiply(\n  first: Expression | string,\n  second: Expression | unknown\n): FunctionExpression {\n  return fieldOrExpression(first).multiply(valueToDefaultExpr(second));\n}\n\n/**\n * @beta\n *\n * Creates an expression that divides two expressions.\n *\n * @example\n * ```typescript\n * // Divide the 'total' field by the 'count' field\n * divide(field(\"total\"), field(\"count\"));\n * ```\n *\n * @param left - The expression to be divided.\n * @param right - The expression to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(left: Expression, right: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides an expression by a constant value.\n *\n * @example\n * ```typescript\n * // Divide the 'value' field by 10\n * divide(field(\"value\"), 10);\n * ```\n *\n * @param expression - The expression to be divided.\n * @param value - The constant value to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(\n  expression: Expression,\n  value: unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Divide the 'total' field by the 'count' field\n * divide(\"total\", field(\"count\"));\n * ```\n *\n * @param fieldName - The field name to be divided.\n * @param expressions - The expression to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(\n  fieldName: string,\n  expressions: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides a field's value by a constant value.\n *\n * @example\n * ```typescript\n * // Divide the 'value' field by 10\n * divide(\"value\", 10);\n * ```\n *\n * @param fieldName - The field name to be divided.\n * @param value - The constant value to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(fieldName: string, value: unknown): FunctionExpression;\nexport function divide(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.divide(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing two expressions.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 'field2'.\n * mod(field(\"field1\"), field(\"field2\"));\n * ```\n *\n * @param left - The dividend expression.\n * @param right - The divisor expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(left: Expression, right: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing an expression by a constant.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 5.\n * mod(field(\"field1\"), 5);\n * ```\n *\n * @param expression - The dividend expression.\n * @param value - The divisor constant.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(expression: Expression, value: unknown): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 'field2'.\n * mod(\"field1\", field(\"field2\"));\n * ```\n *\n * @param fieldName - The dividend field name.\n * @param expression - The divisor expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(\n  fieldName: string,\n  expression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing a field's value by a constant.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 5.\n * mod(\"field1\", 5);\n * ```\n *\n * @param fieldName - The dividend field name.\n * @param value - The divisor constant.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(fieldName: string, value: unknown): FunctionExpression;\nexport function mod(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.mod(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that creates a Firestore map value from an input object.\n *\n * @example\n * ```typescript\n * // Create a map from the input object and reference the 'baz' field value from the input document.\n * map({foo: 'bar', baz: Field.of('baz')}).as('data');\n * ```\n *\n * @param elements - The input map to evaluate in the expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the map function.\n */\nexport function map(elements: Record<string, unknown>): FunctionExpression {\n  return _map(elements, 'map');\n}\nexport function _map(\n  elements: Record<string, unknown>,\n  methodName: string | undefined\n): FunctionExpression {\n  const result: Expression[] = [];\n  for (const key in elements) {\n    if (Object.prototype.hasOwnProperty.call(elements, key)) {\n      const value = elements[key];\n      result.push(constant(key));\n      result.push(valueToDefaultExpr(value));\n    }\n  }\n  return new FunctionExpression('map', result, 'map');\n}\n\n/**\n * Internal use only\n * Converts a plainObject to a mapValue in the proto representation,\n * rather than a functionValue+map that is the result of the map(...) function.\n * This behaves different from constant(plainObject) because it\n * traverses the input object, converts values in the object to expressions,\n * and calls _readUserData on each of these expressions.\n * @private\n * @internal\n * @param plainObject\n */\nexport function _mapValue(plainObject: Record<string, unknown>): MapValue {\n  const result: Map<string, Expression> = new Map<string, Expression>();\n  for (const key in plainObject) {\n    if (Object.prototype.hasOwnProperty.call(plainObject, key)) {\n      const value = plainObject[key];\n      result.set(key, valueToDefaultExpr(value));\n    }\n  }\n  return new MapValue(result, undefined);\n}\n\n/**\n * @beta\n *\n * Creates an expression that creates a Firestore array value from an input array.\n *\n * @example\n * ```typescript\n * // Create an array value from the input array and reference the 'baz' field value from the input document.\n * array(['bar', Field.of('baz')]).as('foo');\n * ```\n *\n * @param elements - The input array to evaluate in the expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the array function.\n */\nexport function array(elements: unknown[]): FunctionExpression {\n  return _array(elements, 'array');\n}\nexport function _array(\n  elements: unknown[],\n  methodName: string | undefined\n): FunctionExpression {\n  return new FunctionExpression(\n    'array',\n    elements.map(element => valueToDefaultExpr(element)),\n    methodName\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if two expressions are equal.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to an expression\n * equal(field(\"age\"), field(\"minAge\").add(10));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(left: Expression, right: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to 21\n * equal(field(\"age\"), 21);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to the 'limit' field\n * equal(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'city' field is equal to string constant \"London\"\n * equal(\"city\", \"London\");\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(fieldName: string, value: unknown): BooleanExpression;\nexport function equal(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.equal(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if two expressions are not equal.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to field 'finalState'\n * notEqual(field(\"status\"), field(\"finalState\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to \"completed\"\n * notEqual(field(\"status\"), \"completed\");\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to the value of 'expectedStatus'\n * notEqual(\"status\", field(\"expectedStatus\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'country' field is not equal to \"USA\"\n * notEqual(\"country\", \"USA\");\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(fieldName: string, value: unknown): BooleanExpression;\nexport function notEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.notEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is less than the second expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than 30\n * lessThan(field(\"age\"), field(\"limit\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is less than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than 30\n * lessThan(field(\"age\"), 30);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than the 'limit' field\n * lessThan(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is less than 50\n * lessThan(\"price\", 50);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(fieldName: string, value: unknown): BooleanExpression;\nexport function lessThan(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.lessThan(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is less than or equal to the second\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to 20\n * lessThan(field(\"quantity\"), field(\"limit\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is less than or equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to 20\n * lessThan(field(\"quantity\"), 20);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n * Creates an expression that checks if a field's value is less than or equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to the 'limit' field\n * lessThan(\"quantity\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than or equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'score' field is less than or equal to 70\n * lessThan(\"score\", 70);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function lessThanOrEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.lessThanOrEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is greater than the second\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18\n * greaterThan(field(\"age\"), Constant(9).add(9));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is greater than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18\n * greaterThan(field(\"age\"), 18);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than an expression.\n *\n * @example\n * ```typescript\n * // Check if the value of field 'age' is greater than the value of field 'limit'\n * greaterThan(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is greater than 100\n * greaterThan(\"price\", 100);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function greaterThan(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.greaterThan(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is greater than or equal to the\n * second expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is greater than or equal to the field \"threshold\"\n * greaterThanOrEqual(field(\"quantity\"), field(\"threshold\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is greater than or equal to a constant\n * value.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is greater than or equal to 10\n * greaterThanOrEqual(field(\"quantity\"), 10);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than or equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the value of field 'age' is greater than or equal to the value of field 'limit'\n * greaterThanOrEqual(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The expression to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  fieldName: string,\n  value: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than or equal to a constant\n * value.\n *\n * @example\n * ```typescript\n * // Check if the 'score' field is greater than or equal to 80\n * greaterThanOrEqual(\"score\", 80);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function greaterThanOrEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.greaterThanOrEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that concatenates an array expression with other arrays.\n *\n * @example\n * ```typescript\n * // Combine the 'items' array with two new item arrays\n * arrayConcat(field(\"items\"), [field(\"newItems\"), field(\"otherItems\")]);\n * ```\n *\n * @param firstArray - The first array expression to concatenate to.\n * @param secondArray - The second array expression or array literal to concatenate to.\n * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated array.\n */\nexport function arrayConcat(\n  firstArray: Expression,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that concatenates a field's array value with other arrays.\n *\n * @example\n * ```typescript\n * // Combine the 'items' array with two new item arrays\n * arrayConcat(\"items\", [field(\"newItems\"), field(\"otherItems\")]);\n * ```\n *\n * @param firstArrayField - The first array to concatenate to.\n * @param secondArray - The second array expression or array literal to concatenate to.\n * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated array.\n */\nexport function arrayConcat(\n  firstArrayField: string,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression;\n\nexport function arrayConcat(\n  firstArray: Expression | string,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression {\n  const exprValues = otherArrays.map(element => valueToDefaultExpr(element));\n  return fieldOrExpression(firstArray).arrayConcat(\n    fieldOrExpression(secondArray),\n    ...exprValues\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains the value of field 'selectedColor'\n * arrayContains(field(\"colors\"), field(\"selectedColor\"));\n * ```\n *\n * @param array - The array expression to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  array: Expression,\n  element: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains \"red\"\n * arrayContains(field(\"colors\"), \"red\");\n * ```\n *\n * @param array - The array expression to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  array: Expression,\n  element: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains the value of field 'selectedColor'\n * arrayContains(\"colors\", field(\"selectedColor\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  fieldName: string,\n  element: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains a specific value.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains \"red\"\n * arrayContains(\"colors\", \"red\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  fieldName: string,\n  element: unknown\n): BooleanExpression;\nexport function arrayContains(\n  array: Expression | string,\n  element: unknown\n): BooleanExpression {\n  const arrayExpr = fieldOrExpression(array);\n  const elementExpr = valueToDefaultExpr(element);\n  return arrayExpr.arrayContains(elementExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'categories' array contains either values from field \"cate1\" or \"Science\"\n * arrayContainsAny(field(\"categories\"), [field(\"cate1\"), \"Science\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  array: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'groups' array contains either the value from the 'userGroup' field\n * // or the value \"guest\"\n * arrayContainsAny(\"categories\", [field(\"cate1\"), \"Science\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'categories' array contains either values from field \"cate1\" or \"Science\"\n * arrayContainsAny(field(\"categories\"), array([field(\"cate1\"), \"Science\"]));\n * ```\n *\n * @param array - The array expression to check.\n * @param values - An expression that evaluates to an array, whose elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  array: Expression,\n  values: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'groups' array contains either the value from the 'userGroup' field\n * // or the value \"guest\"\n * arrayContainsAny(\"categories\", array([field(\"cate1\"), \"Science\"]));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - An expression that evaluates to an array, whose elements to check for in the array field.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  fieldName: string,\n  values: Expression\n): BooleanExpression;\nexport function arrayContainsAny(\n  array: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(array).arrayContainsAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains all the specified elements.\n *\n * @example\n * ```typescript\n * // Check if the \"tags\" array contains all of the values: \"SciFi\", \"Adventure\", and the value from field \"tag1\"\n * arrayContainsAll(field(\"tags\"), [field(\"tag1\"), constant(\"SciFi\"), \"Adventure\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  array: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains all the specified values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'tags' array contains both of the values from field 'tag1', the value \"SciFi\", and \"Adventure\"\n * arrayContainsAll(\"tags\", [field(\"tag1\"), \"SciFi\", \"Adventure\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains all the specified elements.\n *\n * @example\n * ```typescript\n * // Check if the \"tags\" array contains all of the values: \"SciFi\", \"Adventure\", and the value from field \"tag1\"\n * arrayContainsAll(field(\"tags\"), [field(\"tag1\"), constant(\"SciFi\"), \"Adventure\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param arrayExpression - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  array: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains all the specified values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'tags' array contains both of the values from field 'tag1', the value \"SciFi\", and \"Adventure\"\n * arrayContainsAll(\"tags\", [field(\"tag1\"), \"SciFi\", \"Adventure\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param arrayExpression - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\nexport function arrayContainsAll(\n  array: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(array).arrayContainsAll(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of an array in a specified field.\n *\n * @example\n * ```typescript\n * // Get the number of items in field 'cart'\n * arrayLength('cart');\n * ```\n *\n * @param fieldName - The name of the field containing an array to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function arrayLength(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of an array expression.\n *\n * @example\n * ```typescript\n * // Get the number of items in the 'cart' array\n * arrayLength(field(\"cart\"));\n * ```\n *\n * @param array - The array expression to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function arrayLength(array: Expression): FunctionExpression;\nexport function arrayLength(array: Expression | string): FunctionExpression {\n  return fieldOrExpression(array).arrayLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression, when evaluated, is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(field(\"category\"), [constant(\"Electronics\"), field(\"primaryType\")]);\n * ```\n *\n * @param expression - The expression whose results to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  expression: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is equal to any of the provided values.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is set to a value in the disabledCategories field\n * equalAny(field(\"category\"), field('disabledCategories'));\n * ```\n *\n * @param expression - The expression whose results to compare.\n * @param arrayExpression - An expression that evaluates to an array, whose elements to check for equality to the input.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  expression: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(\"category\", [constant(\"Electronics\"), field(\"primaryType\")]);\n * ```\n *\n * @param fieldName - The field to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(\"category\", [\"Electronics\", field(\"primaryType\")]);\n * ```\n *\n * @param fieldName - The field to compare.\n * @param arrayExpression - An expression that evaluates to an array, whose elements to check for equality to the input field.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\nexport function equalAny(\n  element: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(element).equalAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n * notEqualAny(field(\"status\"), [\"pending\", field(\"rejectedStatus\")]);\n * ```\n *\n * @param element - The expression to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  element: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n * notEqualAny(\"status\", [constant(\"pending\"), field(\"rejectedStatus\")]);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of the field 'rejectedStatus'\n * notEqualAny(field(\"status\"), [\"pending\", field(\"rejectedStatus\")]);\n * ```\n *\n * @param element - The expression to compare.\n * @param arrayExpression - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  element: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to any of the values in the evaluated expression.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to any value in the field 'rejectedStatuses'\n * notEqualAny(\"status\", field(\"rejectedStatuses\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param arrayExpression - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\n\nexport function notEqualAny(\n  element: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(element).notEqualAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'XOR' (exclusive OR) operation on multiple BooleanExpressions.\n *\n * @example\n * ```typescript\n * // Check if only one of the conditions is true: 'age' greater than 18, 'city' is \"London\",\n * // or 'status' is \"active\".\n * const condition = xor(\n *     greaterThan(\"age\", 18),\n *     equal(\"city\", \"London\"),\n *     equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first condition.\n * @param second - The second condition.\n * @param additionalConditions - Additional conditions to 'XOR' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'XOR' operation.\n */\nexport function xor(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...additionalConditions: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'xor',\n    [first, second, ...additionalConditions],\n    'xor'\n  ).asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates a conditional expression that evaluates to a 'then' expression if a condition is true\n * and an 'else' expression if the condition is false.\n *\n * @example\n * ```typescript\n * // If 'age' is greater than 18, return \"Adult\"; otherwise, return \"Minor\".\n * conditional(\n *     greaterThan(\"age\", 18), constant(\"Adult\"), constant(\"Minor\"));\n * ```\n *\n * @param condition - The condition to evaluate.\n * @param thenExpr - The expression to evaluate if the condition is true.\n * @param elseExpr - The expression to evaluate if the condition is false.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the conditional expression.\n */\nexport function conditional(\n  condition: BooleanExpression,\n  thenExpr: Expression,\n  elseExpr: Expression\n): FunctionExpression {\n  return new FunctionExpression(\n    'conditional',\n    [condition, thenExpr, elseExpr],\n    'conditional'\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that negates a filter condition.\n *\n * @example\n * ```typescript\n * // Find documents where the 'completed' field is NOT true\n * not(equal(\"completed\", true));\n * ```\n *\n * @param booleanExpr - The filter condition to negate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the negated filter condition.\n */\nexport function not(booleanExpr: BooleanExpression): BooleanExpression {\n  return booleanExpr.not();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the largest value between multiple input\n * expressions or literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the largest value between the 'field1' field, the 'field2' field,\n * // and 1000\n * logicalMaximum(field(\"field1\"), field(\"field2\"), 1000);\n * ```\n *\n * @param first - The first operand expression.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n */\nexport function logicalMaximum(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the largest value between multiple input\n * expressions or literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the largest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMaximum(\"field1\", field(\"field2\"), 1000);\n * ```\n *\n * @param fieldName - The first operand field name.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n */\nexport function logicalMaximum(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function logicalMaximum(\n  first: Expression | string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return fieldOrExpression(first).logicalMaximum(\n    valueToDefaultExpr(second),\n    ...others.map(value => valueToDefaultExpr(value))\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the smallest value between multiple input\n * expressions and literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the smallest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMinimum(field(\"field1\"), field(\"field2\"), 1000);\n * ```\n *\n * @param first - The first operand expression.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n */\nexport function logicalMinimum(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the smallest value between a field's value\n * and other input expressions or literal values.\n * Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the smallest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMinimum(\"field1\", field(\"field2\"), 1000);\n * ```\n *\n * @param fieldName - The first operand field name.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n */\nexport function logicalMinimum(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function logicalMinimum(\n  first: Expression | string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return fieldOrExpression(first).logicalMinimum(\n    valueToDefaultExpr(second),\n    ...others.map(value => valueToDefaultExpr(value))\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field exists.\n *\n * @example\n * ```typescript\n * // Check if the document has a field named \"phoneNumber\"\n * exists(field(\"phoneNumber\"));\n * ```\n *\n * @param value - An expression evaluates to the name of the field to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'exists' check.\n */\nexport function exists(value: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field exists.\n *\n * @example\n * ```typescript\n * // Check if the document has a field named \"phoneNumber\"\n * exists(\"phoneNumber\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'exists' check.\n */\nexport function exists(fieldName: string): BooleanExpression;\nexport function exists(valueOrField: Expression | string): BooleanExpression {\n  return fieldOrExpression(valueOrField).exists();\n}\n\n/**\n * @beta\n *\n * Creates an expression that reverses a string.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * reverse(field(\"myString\"));\n * ```\n *\n * @param stringExpression - An expression evaluating to a string value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function reverse(stringExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that reverses a string value in the specified field.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * reverse(\"myString\");\n * ```\n *\n * @param field - The name of the field representing the string to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function reverse(field: string): FunctionExpression;\nexport function reverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).reverse();\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the byte length of a string in UTF-8, or just the length of a Blob.\n *\n * @example\n * ```typescript\n * // Calculate the length of the 'myString' field in bytes.\n * byteLength(field(\"myString\"));\n * ```\n *\n * @param expr - The expression representing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n */\nexport function byteLength(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a string represented by a field in UTF-8 bytes, or just the length of a Blob.\n *\n * @example\n * ```typescript\n * // Calculate the length of the 'myString' field in bytes.\n * byteLength(\"myString\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n */\nexport function byteLength(fieldName: string): FunctionExpression;\nexport function byteLength(expr: Expression | string): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.byteLength();\n}\n\n/**\n * @beta\n * Creates an expression that reverses an array.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myArray' field.\n * arrayReverse(\"myArray\");\n * ```\n *\n * @param fieldName - The name of the field to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n */\nexport function arrayReverse(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that reverses an array.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myArray' field.\n * arrayReverse(field(\"myArray\"));\n * ```\n *\n * @param arrayExpression - An expression evaluating to an array value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n */\nexport function arrayReverse(arrayExpression: Expression): FunctionExpression;\nexport function arrayReverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).arrayReverse();\n}\n\n/**\n * @beta\n * Creates an expression that computes e to the power of the expression's result.\n *\n * @example\n * ```typescript\n * // Compute e to the power of 2.\n * exp(constant(2));\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n */\nexport function exp(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes e to the power of the expression's result.\n *\n * @example\n * ```typescript\n * // Compute e to the power of the 'value' field.\n * exp('value');\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n */\nexport function exp(fieldName: string): FunctionExpression;\n\nexport function exp(\n  expressionOrFieldName: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expressionOrFieldName).exp();\n}\n\n/**\n * @beta\n * Creates an expression that computes the ceiling of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the ceiling of the 'price' field.\n * ceil(\"price\");\n * ```\n *\n * @param fieldName - The name of the field to compute the ceiling of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n */\nexport function ceil(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the ceiling of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the ceiling of the 'price' field.\n * ceil(field(\"price\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the ceiling will be computed for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n */\nexport function ceil(expression: Expression): FunctionExpression;\nexport function ceil(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).ceil();\n}\n\n/**\n * @beta\n * Creates an expression that computes the floor of a numeric value.\n *\n * @param expr - The expression to compute the floor of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n */\nexport function floor(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the floor of a numeric value.\n *\n * @param fieldName - The name of the field to compute the floor of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n */\nexport function floor(fieldName: string): FunctionExpression;\nexport function floor(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).floor();\n}\n\n/**\n * @beta\n * Creates an aggregation that counts the number of distinct values of a field.\n *\n * @param expr - The expression or field to count distinct values of.\n * @returns A new `AggregateFunction` representing the 'count_distinct' aggregation.\n */\nexport function countDistinct(expr: Expression | string): AggregateFunction {\n  return fieldOrExpression(expr).countDistinct();\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the character length of a string field in UTF8.\n *\n * @example\n * ```typescript\n * // Get the character length of the 'name' field in UTF-8.\n * strLength(\"name\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string.\n */\nexport function charLength(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the character length of a string expression in UTF-8.\n *\n * @example\n * ```typescript\n * // Get the character length of the 'name' field in UTF-8.\n * strLength(field(\"name\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string.\n */\nexport function charLength(stringExpression: Expression): FunctionExpression;\nexport function charLength(value: Expression | string): FunctionExpression {\n  const valueExpr = fieldOrExpression(value);\n  return valueExpr.charLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison against a\n * field.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(\"title\", \"%guide%\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(fieldName: string, pattern: string): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison against a\n * field.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(\"title\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(fieldName: string, pattern: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(field(\"title\"), \"%guide%\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(field(\"title\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function like(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.like(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified regular expression as\n * a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(\"description\", \"(?i)example\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  fieldName: string,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified regular expression as\n * a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(\"description\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  fieldName: string,\n  pattern: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified regular\n * expression as a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(field(\"description\"), \"(?i)example\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified regular\n * expression as a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(field(\"description\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function regexContains(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexContains(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field matches a specified regular expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(\"email\", \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  fieldName: string,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field matches a specified regular expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(\"email\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  fieldName: string,\n  pattern: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression matches a specified regular\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(field(\"email\"), \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n * ```\n *\n * @param stringExpression - The expression representing the string to match against.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression matches a specified regular\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(field(\"email\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to match against.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function regexMatch(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexMatch(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\".\n * stringContains(\"description\", \"example\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param substring - The substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  fieldName: string,\n  substring: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a substring specified by an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains the value of the 'keyword' field.\n * stringContains(\"description\", field(\"keyword\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param substring - The expression representing the substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  fieldName: string,\n  substring: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\".\n * stringContains(field(\"description\"), \"example\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param substring - The substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  stringExpression: Expression,\n  substring: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a substring specified by another expression.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains the value of the 'keyword' field.\n * stringContains(field(\"description\"), field(\"keyword\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param substring - The expression representing the substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  stringExpression: Expression,\n  substring: Expression\n): BooleanExpression;\nexport function stringContains(\n  left: Expression | string,\n  substring: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const substringExpr = valueToDefaultExpr(substring);\n  return leftExpr.stringContains(substringExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the 'name' field starts with \"Mr.\"\n * startsWith(\"name\", \"Mr.\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  fieldName: string,\n  prefix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the 'fullName' field starts with the value of the 'firstName' field\n * startsWith(\"fullName\", field(\"firstName\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param prefix - The expression representing the prefix.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  fieldName: string,\n  prefix: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields starts with \"Mr.\"\n * startsWith(field(\"fullName\"), \"Mr.\");\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  stringExpression: Expression,\n  prefix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields starts with \"Mr.\"\n * startsWith(field(\"fullName\"), field(\"prefix\"));\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  stringExpression: Expression,\n  prefix: Expression\n): BooleanExpression;\nexport function startsWith(\n  expr: Expression | string,\n  prefix: Expression | string\n): BooleanExpression {\n  return fieldOrExpression(expr).startsWith(valueToDefaultExpr(prefix));\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the 'filename' field ends with \".txt\"\n * endsWith(\"filename\", \".txt\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(fieldName: string, suffix: string): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the 'url' field ends with the value of the 'extension' field\n * endsWith(\"url\", field(\"extension\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param suffix - The expression representing the postfix.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  fieldName: string,\n  suffix: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields ends with \"Jr.\"\n * endsWith(field(\"fullName\"), \"Jr.\");\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  stringExpression: Expression,\n  suffix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields ends with \"Jr.\"\n * endsWith(field(\"fullName\"), constant(\"Jr.\"));\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  stringExpression: Expression,\n  suffix: Expression\n): BooleanExpression;\nexport function endsWith(\n  expr: Expression | string,\n  suffix: Expression | string\n): BooleanExpression {\n  return fieldOrExpression(expr).endsWith(valueToDefaultExpr(suffix));\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a string field to lowercase.\n *\n * @example\n * ```typescript\n * // Convert the 'name' field to lowercase\n * toLower(\"name\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the lowercase string.\n */\nexport function toLower(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a string expression to lowercase.\n *\n * @example\n * ```typescript\n * // Convert the 'name' field to lowercase\n * toLower(field(\"name\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to convert to lowercase.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the lowercase string.\n */\nexport function toLower(stringExpression: Expression): FunctionExpression;\nexport function toLower(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).toLower();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a string field to uppercase.\n *\n * @example\n * ```typescript\n * // Convert the 'title' field to uppercase\n * toUpper(\"title\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the uppercase string.\n */\nexport function toUpper(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a string expression to uppercase.\n *\n * @example\n * ```typescript\n * // Convert the 'title' field to uppercase\n * toUppercase(field(\"title\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to convert to uppercase.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the uppercase string.\n */\nexport function toUpper(stringExpression: Expression): FunctionExpression;\nexport function toUpper(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).toUpper();\n}\n\n/**\n * @beta\n *\n * Creates an expression that removes leading and trailing whitespace from a string or byte array.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the 'userInput' field\n * trim(\"userInput\");\n *\n * // Trim quotes from the 'userInput' field\n * trim(\"userInput\", '\"');\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n * trimmed from the input. If not specified, then whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string.\n */\nexport function trim(\n  fieldName: string,\n  valueToTrim?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that removes leading and trailing characters from a string or byte array expression.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the 'userInput' field\n * trim(field(\"userInput\"));\n *\n * // Trim quotes from the 'userInput' field\n * trim(field(\"userInput\"), '\"');\n * ```\n *\n * @param stringExpression - The expression representing the string or byte array to trim.\n * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n * trimmed from the input. If not specified, then whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string or byte array.\n */\nexport function trim(\n  stringExpression: Expression,\n  valueToTrim?: string | Expression\n): FunctionExpression;\nexport function trim(\n  expr: Expression | string,\n  valueToTrim?: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(expr).trim(valueToTrim);\n}\n\n/**\n * @beta\n *\n * Creates an expression that concatenates string functions, fields or constants together.\n *\n * @example\n * ```typescript\n * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n * stringConcat(\"firstName\", \" \", field(\"lastName\"));\n * ```\n *\n * @param fieldName - The field name containing the initial string value.\n * @param secondString - An expression or string literal to concatenate.\n * @param otherStrings - Optional additional expressions or literals (typically strings) to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated string.\n */\nexport function stringConcat(\n  fieldName: string,\n  secondString: Expression | string,\n  ...otherStrings: Array<Expression | string>\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that concatenates string expressions together.\n *\n * @example\n * ```typescript\n * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n * stringConcat(field(\"firstName\"), \" \", field(\"lastName\"));\n * ```\n *\n * @param firstString - The initial string expression to concatenate to.\n * @param secondString - An expression or string literal to concatenate.\n * @param otherStrings - Optional additional expressions or literals (typically strings) to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated string.\n */\nexport function stringConcat(\n  firstString: Expression,\n  secondString: Expression | string,\n  ...otherStrings: Array<Expression | string>\n): FunctionExpression;\nexport function stringConcat(\n  first: string | Expression,\n  second: string | Expression,\n  ...elements: Array<string | Expression>\n): FunctionExpression {\n  return fieldOrExpression(first).stringConcat(\n    valueToDefaultExpr(second),\n    ...elements.map(valueToDefaultExpr)\n  );\n}\n\n/**\n * @beta\n *\n * Accesses a value from a map (object) field using the provided key.\n *\n * @example\n * ```typescript\n * // Get the 'city' value from the 'address' map field\n * mapGet(\"address\", \"city\");\n * ```\n *\n * @param fieldName - The field name of the map field.\n * @param subField - The key to access in the map.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the value associated with the given key in the map.\n */\nexport function mapGet(fieldName: string, subField: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Accesses a value from a map (object) expression using the provided key.\n *\n * @example\n * ```typescript\n * // Get the 'city' value from the 'address' map field\n * mapGet(field(\"address\"), \"city\");\n * ```\n *\n * @param mapExpression - The expression representing the map.\n * @param subField - The key to access in the map.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the value associated with the given key in the map.\n */\nexport function mapGet(\n  mapExpression: Expression,\n  subField: string\n): FunctionExpression;\nexport function mapGet(\n  fieldOrExpr: string | Expression,\n  subField: string\n): FunctionExpression {\n  return fieldOrExpression(fieldOrExpr).mapGet(subField);\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that counts the total number of stage inputs.\n *\n * @example\n * ```typescript\n * // Count the total number of input documents\n * countAll().as(\"totalDocument\");\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'countAll' aggregation.\n */\nexport function countAll(): AggregateFunction {\n  return AggregateFunction._create('count', [], 'count');\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that counts the number of stage inputs with valid evaluations of the\n * provided expression.\n *\n * @example\n * ```typescript\n * // Count the number of items where the price is greater than 10\n * count(field(\"price\").greaterThan(10)).as(\"expensiveItemCount\");\n * ```\n *\n * @param expression - The expression to count.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'count' aggregation.\n */\nexport function count(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n * Creates an aggregation that counts the number of stage inputs where the input field exists.\n *\n * @example\n * ```typescript\n * // Count the total number of products\n * count(\"productId\").as(\"totalProducts\");\n * ```\n *\n * @param fieldName - The name of the field to count.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'count' aggregation.\n */\nexport function count(fieldName: string): AggregateFunction;\nexport function count(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).count();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the sum of values from an expression across multiple\n * stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the total revenue from a set of orders\n * sum(field(\"orderAmount\")).as(\"totalRevenue\");\n * ```\n *\n * @param expression - The expression to sum up.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'sum' aggregation.\n */\nexport function sum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the sum of a field's values across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Calculate the total revenue from a set of orders\n * sum(\"orderAmount\").as(\"totalRevenue\");\n * ```\n *\n * @param fieldName - The name of the field containing numeric values to sum up.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'sum' aggregation.\n */\nexport function sum(fieldName: string): AggregateFunction;\nexport function sum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).sum();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the average (mean) of values from an expression across\n * multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the average age of users\n * average(field(\"age\")).as(\"averageAge\");\n * ```\n *\n * @param expression - The expression representing the values to average.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'average' aggregation.\n */\nexport function average(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the average (mean) of a field's values across multiple\n * stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the average age of users\n * average(\"age\").as(\"averageAge\");\n * ```\n *\n * @param fieldName - The name of the field containing numeric values to average.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'average' aggregation.\n */\nexport function average(fieldName: string): AggregateFunction;\nexport function average(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).average();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the minimum value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the lowest price of all products\n * minimum(field(\"price\")).as(\"lowestPrice\");\n * ```\n *\n * @param expression - The expression to find the minimum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'minimum' aggregation.\n */\nexport function minimum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the minimum value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the lowest price of all products\n * minimum(\"price\").as(\"lowestPrice\");\n * ```\n *\n * @param fieldName - The name of the field to find the minimum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'minimum' aggregation.\n */\nexport function minimum(fieldName: string): AggregateFunction;\nexport function minimum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).minimum();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the maximum value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the highest score in a leaderboard\n * maximum(field(\"score\")).as(\"highestScore\");\n * ```\n *\n * @param expression - The expression to find the maximum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'maximum' aggregation.\n */\nexport function maximum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the maximum value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the highest score in a leaderboard\n * maximum(\"score\").as(\"highestScore\");\n * ```\n *\n * @param fieldName - The name of the field to find the maximum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'maximum' aggregation.\n */\nexport function maximum(fieldName: string): AggregateFunction;\nexport function maximum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).maximum();\n}\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a field's vector value and a literal vector value.\n *\n * @example\n * ```typescript\n * // Calculate the Cosine distance between the 'location' field and a target location\n * cosineDistance(\"location\", [37.7749, -122.4194]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles) or {@link VectorValue} to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n * cosineDistance(\"userVector\", field(\"itemVector\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a vector expression and a vector literal.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'location' field and a target location\n * cosineDistance(field(\"location\"), [37.7749, -122.4194]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n * cosineDistance(field(\"userVector\"), field(\"itemVector\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function cosineDistance(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.cosineDistance(expr2);\n}\n\n/**\n * @beta\n *\n * Calculates the dot product between a field's vector value and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the dot product distance between a feature vector and a target vector\n * dotProduct(\"features\", [0.5, 0.8, 0.2]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles or VectorValue) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the dot product distance between two document vectors: 'docVector1' and 'docVector2'\n * dotProduct(\"docVector1\", field(\"docVector2\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between a vector expression and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the dot product between a feature vector and a target vector\n * dotProduct(field(\"features\"), [0.5, 0.8, 0.2]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to calculate with.\n * @param vector - The other vector (as an array of doubles or VectorValue) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the dot product between two document vectors: 'docVector1' and 'docVector2'\n * dotProduct(field(\"docVector1\"), field(\"docVector2\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to calculate with.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function dotProduct(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.dotProduct(expr2);\n}\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a field's vector value and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between the 'location' field and a target location\n * euclideanDistance(\"location\", [37.7749, -122.4194]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between two vector fields: 'pointA' and 'pointB'\n * euclideanDistance(\"pointA\", field(\"pointB\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a vector expression and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between the 'location' field and a target location\n *\n * euclideanDistance(field(\"location\"), [37.7749, -122.4194]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between two vector fields: 'pointA' and 'pointB'\n * euclideanDistance(field(\"pointA\"), field(\"pointB\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function euclideanDistance(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.euclideanDistance(expr2);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a Firestore Vector.\n *\n * @example\n * ```typescript\n * // Get the vector length (dimension) of the field 'embedding'.\n * vectorLength(field(\"embedding\"));\n * ```\n *\n * @param vectorExpression - The expression representing the Firestore Vector.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function vectorLength(vectorExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a Firestore Vector represented by a field.\n *\n * @example\n * ```typescript\n * // Get the vector length (dimension) of the field 'embedding'.\n * vectorLength(\"embedding\");\n * ```\n *\n * @param fieldName - The name of the field representing the Firestore Vector.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function vectorLength(fieldName: string): FunctionExpression;\nexport function vectorLength(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).vectorLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'microseconds' field as microseconds since epoch.\n * unixMicrosToTimestamp(field(\"microseconds\"));\n * ```\n *\n * @param expr - The expression representing the number of microseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMicrosToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'microseconds' field as microseconds since epoch.\n * unixMicrosToTimestamp(\"microseconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of microseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMicrosToTimestamp(fieldName: string): FunctionExpression;\nexport function unixMicrosToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expr).unixMicrosToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to microseconds since epoch.\n * timestampToUnixMicros(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n */\nexport function timestampToUnixMicros(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to microseconds since epoch.\n * timestampToUnixMicros(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n */\nexport function timestampToUnixMicros(fieldName: string): FunctionExpression;\nexport function timestampToUnixMicros(\n  expr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expr).timestampToUnixMicros();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'milliseconds' field as milliseconds since epoch.\n * unixMillisToTimestamp(field(\"milliseconds\"));\n * ```\n *\n * @param expr - The expression representing the number of milliseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMillisToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'milliseconds' field as milliseconds since epoch.\n * unixMillisToTimestamp(\"milliseconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of milliseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMillisToTimestamp(fieldName: string): FunctionExpression;\nexport function unixMillisToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.unixMillisToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to milliseconds since epoch.\n * timestampToUnixMillis(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n */\nexport function timestampToUnixMillis(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to milliseconds since epoch.\n * timestampToUnixMillis(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n */\nexport function timestampToUnixMillis(fieldName: string): FunctionExpression;\nexport function timestampToUnixMillis(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.timestampToUnixMillis();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'seconds' field as seconds since epoch.\n * unixSecondsToTimestamp(field(\"seconds\"));\n * ```\n *\n * @param expr - The expression representing the number of seconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixSecondsToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'seconds' field as seconds since epoch.\n * unixSecondsToTimestamp(\"seconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of seconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixSecondsToTimestamp(fieldName: string): FunctionExpression;\nexport function unixSecondsToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.unixSecondsToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to seconds since epoch.\n * timestampToUnixSeconds(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n */\nexport function timestampToUnixSeconds(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to seconds since epoch.\n * timestampToUnixSeconds(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n */\nexport function timestampToUnixSeconds(fieldName: string): FunctionExpression;\nexport function timestampToUnixSeconds(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.timestampToUnixSeconds();\n}\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp.\n *\n * @example\n * ```typescript\n * // Add some duration determined by field 'unit' and 'amount' to the 'timestamp' field.\n * timestampAdd(field(\"timestamp\"), field(\"unit\"), field(\"amount\"));\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n * @param amount - The expression evaluates to amount of the unit.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  timestamp: Expression,\n  unit: Expression,\n  amount: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp.\n *\n * @example\n * ```typescript\n * // Add 1 day to the 'timestamp' field.\n * timestampAdd(field(\"timestamp\"), \"day\", 1);\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  timestamp: Expression,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp represented by a field.\n *\n * @example\n * ```typescript\n * // Add 1 day to the 'timestamp' field.\n * timestampAdd(\"timestamp\", \"day\", 1);\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  fieldName: string,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\nexport function timestampAdd(\n  timestamp: Expression | string,\n  unit:\n    | Expression\n    | 'microsecond'\n    | 'millisecond'\n    | 'second'\n    | 'minute'\n    | 'hour'\n    | 'day',\n  amount: Expression | number\n): FunctionExpression {\n  const normalizedTimestamp = fieldOrExpression(timestamp);\n  const normalizedUnit = valueToDefaultExpr(unit);\n  const normalizedAmount = valueToDefaultExpr(amount);\n  return normalizedTimestamp.timestampAdd(normalizedUnit, normalizedAmount);\n}\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp.\n *\n * @example\n * ```typescript\n * // Subtract some duration determined by field 'unit' and 'amount' from the 'timestamp' field.\n * timestampSubtract(field(\"timestamp\"), field(\"unit\"), field(\"amount\"));\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n * @param amount - The expression evaluates to amount of the unit.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  timestamp: Expression,\n  unit: Expression,\n  amount: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp.\n *\n * @example\n * ```typescript\n * // Subtract 1 day from the 'timestamp' field.\n * timestampSubtract(field(\"timestamp\"), \"day\", 1);\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  timestamp: Expression,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp represented by a field.\n *\n * @example\n * ```typescript\n * // Subtract 1 day from the 'timestamp' field.\n * timestampSubtract(\"timestamp\", \"day\", 1);\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  fieldName: string,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\nexport function timestampSubtract(\n  timestamp: Expression | string,\n  unit:\n    | Expression\n    | 'microsecond'\n    | 'millisecond'\n    | 'second'\n    | 'minute'\n    | 'hour'\n    | 'day',\n  amount: Expression | number\n): FunctionExpression {\n  const normalizedTimestamp = fieldOrExpression(timestamp);\n  const normalizedUnit = valueToDefaultExpr(unit);\n  const normalizedAmount = valueToDefaultExpr(amount);\n  return normalizedTimestamp.timestampSubtract(\n    normalizedUnit,\n    normalizedAmount\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that evaluates to the current server timestamp.\n *\n * @example\n * ```typescript\n * // Get the current server timestamp\n * currentTimestamp()\n * ```\n *\n * @returns A new Expression representing the current server timestamp.\n */\nexport function currentTimestamp(): FunctionExpression {\n  return new FunctionExpression('current_timestamp', [], 'currentTimestamp');\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'AND' operation on multiple filter conditions.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18 AND the 'city' field is \"London\" AND\n * // the 'status' field is \"active\"\n * const condition = and(greaterThan(\"age\", 18), equal(\"city\", \"London\"), equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first filter condition.\n * @param second - The second filter condition.\n * @param more - Additional filter conditions to 'AND' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'AND' operation.\n */\nexport function and(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...more: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'and',\n    [first, second, ...more],\n    'and'\n  ).asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'OR' operation on multiple filter conditions.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18 OR the 'city' field is \"London\" OR\n * // the 'status' field is \"active\"\n * const condition = or(greaterThan(\"age\", 18), equal(\"city\", \"London\"), equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first filter condition.\n * @param second - The second filter condition.\n * @param more - Additional filter conditions to 'OR' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'OR' operation.\n */\nexport function or(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...more: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'or',\n    [first, second, ...more],\n    'xor'\n  ).asBoolean();\n}\n\n/**\n * @beta\n * Creates an expression that returns the value of the base expression raised to the power of the exponent expression.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of the 'exponent' field.\n * pow(field(\"base\"), field(\"exponent\"));\n * ```\n *\n * @param base - The expression to raise to the power of the exponent.\n * @param exponent - The expression to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: Expression, exponent: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base expression raised to the power of the exponent.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of 2.\n * pow(field(\"base\"), 2);\n * ```\n *\n * @param base - The expression to raise to the power of the exponent.\n * @param exponent - The constant value to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: Expression, exponent: number): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base field raised to the power of the exponent expression.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of the 'exponent' field.\n * pow(\"base\", field(\"exponent\"));\n * ```\n *\n * @param base - The name of the field to raise to the power of the exponent.\n * @param exponent - The expression to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: string, exponent: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base field raised to the power of the exponent.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of 2.\n * pow(\"base\", 2);\n * ```\n *\n * @param base - The name of the field to raise to the power of the exponent.\n * @param exponent - The constant value to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: string, exponent: number): FunctionExpression;\nexport function pow(\n  base: Expression | string,\n  exponent: Expression | number\n): FunctionExpression {\n  return fieldOrExpression(base).pow(exponent as number);\n}\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the nearest whole number.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field.\n * round(\"price\");\n * ```\n *\n * @param fieldName - The name of the field to round.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the nearest whole number.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field.\n * round(field(\"price\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be rounded.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field to two decimal places.\n * round(\"price\", 2);\n * ```\n *\n * @param fieldName - The name of the field to round.\n * @param decimalPlaces - A constant or expression specifying the rounding precision in decimal places.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(\n  fieldName: string,\n  decimalPlaces: number | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field to two decimal places.\n * round(field(\"price\"), constant(2));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be rounded.\n * @param decimalPlaces - A constant or expression specifying the rounding precision in decimal places.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(\n  expression: Expression,\n  decimalPlaces: number | Expression\n): FunctionExpression;\nexport function round(\n  expr: Expression | string,\n  decimalPlaces?: number | Expression\n): FunctionExpression {\n  if (decimalPlaces === undefined) {\n    return fieldOrExpression(expr).round();\n  } else {\n    return fieldOrExpression(expr).round(valueToDefaultExpr(decimalPlaces));\n  }\n}\n\n/**\n * @beta\n * Creates an expression that returns the collection ID from a path.\n *\n * @example\n * ```typescript\n * // Get the collection ID from a path.\n * collectionId(\"__name__\");\n * ```\n *\n * @param fieldName - The name of the field to get the collection ID from.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n */\nexport function collectionId(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the collection ID from a path.\n *\n * @example\n * ```typescript\n * // Get the collection ID from a path.\n * collectionId(field(\"__name__\"));\n * ```\n *\n * @param expression - An expression evaluating to a path, which the collection ID will be extracted from.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n */\nexport function collectionId(expression: Expression): FunctionExpression;\nexport function collectionId(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).collectionId();\n}\n\n/**\n * @beta\n * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n *\n * @example\n * ```typescript\n * // Get the length of the 'name' field.\n * length(\"name\");\n *\n * // Get the number of items in the 'cart' array.\n * length(\"cart\");\n * ```\n *\n * @param fieldName - The name of the field to calculate the length of.\n * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n */\nexport function length(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n *\n * @example\n * ```typescript\n * // Get the length of the 'name' field.\n * length(field(\"name\"));\n *\n * // Get the number of items in the 'cart' array.\n * length(field(\"cart\"));\n * ```\n *\n * @param expression - An expression evaluating to a string, array, map, vector, or bytes, which the length will be calculated for.\n * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n */\nexport function length(expression: Expression): FunctionExpression;\nexport function length(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).length();\n}\n\n/**\n * @beta\n * Creates an expression that computes the natural logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the natural logarithm of the 'value' field.\n * ln(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the natural logarithm of.\n * @returns A new `Expression` representing the natural logarithm of the numeric value.\n */\nexport function ln(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the natural logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the natural logarithm of the 'value' field.\n * ln(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the natural logarithm will be computed for.\n * @returns A new `Expression` representing the natural logarithm of the numeric value.\n */\nexport function ln(expression: Expression): FunctionExpression;\nexport function ln(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).ln();\n}\n\n/**\n * @beta\n * Creates an expression that computes the logarithm of an expression to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with base 10.\n * log(field(\"value\"), 10);\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the logarithm will be computed for.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(expression: Expression, base: number): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of an expression to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with the base in the 'base' field.\n * log(field(\"value\"), field(\"base\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the logarithm will be computed for.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(\n  expression: Expression,\n  base: Expression\n): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of a field to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with base 10.\n * log(\"value\", 10);\n * ```\n *\n * @param fieldName - The name of the field to compute the logarithm of.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(fieldName: string, base: number): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of a field to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with the base in the 'base' field.\n * log(\"value\", field(\"base\"));\n * ```\n *\n * @param fieldName - The name of the field to compute the logarithm of.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(fieldName: string, base: Expression): FunctionExpression;\nexport function log(\n  expr: Expression | string,\n  base: number | Expression\n): FunctionExpression {\n  return new FunctionExpression('log', [\n    fieldOrExpression(expr),\n    valueToDefaultExpr(base)\n  ]);\n}\n\n/**\n * @beta\n * Creates an expression that computes the square root of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the square root of the 'value' field.\n * sqrt(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the square root will be computed for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n */\nexport function sqrt(expression: Expression): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the square root of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the square root of the 'value' field.\n * sqrt(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the square root of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n */\nexport function sqrt(fieldName: string): FunctionExpression;\nexport function sqrt(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).sqrt();\n}\n\n/**\n * @beta\n * Creates an expression that reverses a string.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * strReverse(field(\"myString\"));\n * ```\n *\n * @param stringExpression - An expression evaluating to a string value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function stringReverse(stringExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that reverses a string value in the specified field.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * strReverse(\"myString\");\n * ```\n *\n * @param field - The name of the field representing the string to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function stringReverse(field: string): FunctionExpression;\nexport function stringReverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).stringReverse();\n}\n\n/**\n * @beta\n * Creates an expression that concatenates strings, arrays, or blobs. Types cannot be mixed.\n *\n * @example\n * ```typescript\n * // Concatenate the 'firstName' and 'lastName' fields with a space in between.\n * concat(field(\"firstName\"), \" \", field(\"lastName\"))\n * ```\n *\n * @param first - The first expressions to concatenate.\n * @param second - The second literal or expression to concatenate.\n * @param others - Additional literals or expressions to concatenate.\n * @returns A new `Expression` representing the concatenation.\n */\nexport function concat(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that concatenates strings, arrays, or blobs. Types cannot be mixed.\n *\n * @example\n * ```typescript\n * // Concatenate a field with a literal string.\n * concat(field(\"firstName\"), \"Doe\")\n * ```\n *\n * @param fieldName - The name of a field to concatenate.\n * @param second - The second literal or expression to concatenate.\n * @param others - Additional literal or expressions to concatenate.\n * @returns A new `Expression` representing the concatenation.\n */\nexport function concat(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function concat(\n  fieldNameOrExpression: string | Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return new FunctionExpression('concat', [\n    fieldOrExpression(fieldNameOrExpression),\n    valueToDefaultExpr(second),\n    ...others.map(valueToDefaultExpr)\n  ]);\n}\n\n/**\n * @beta\n * Creates an expression that computes the absolute value of a numeric value.\n *\n * @param expr - The expression to compute the absolute value of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n */\nexport function abs(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the absolute value of a numeric value.\n *\n * @param fieldName - The field to compute the absolute value of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n */\nexport function abs(fieldName: string): FunctionExpression;\nexport function abs(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).abs();\n}\n\n/**\n * @beta\n * Creates an expression that returns the `elseExpr` argument if `ifExpr` is absent, else return\n * the result of the `ifExpr` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(field(\"optional_field\"), constant(\"default_value\"))\n * ```\n *\n * @param ifExpr - The expression to check for absence.\n * @param elseExpr - The expression that will be evaluated and returned if [ifExpr] is absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(ifExpr: Expression, elseExpr: Expression): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseValue` argument if `ifExpr` is absent, else\n * return the result of the `ifExpr` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(field(\"optional_field\"), \"default_value\")\n * ```\n *\n * @param ifExpr - The expression to check for absence.\n * @param elseValue - The value that will be returned if `ifExpr` evaluates to an absent value.\n * @returns A new [Expression] representing the ifAbsent operation.\n */\nexport function ifAbsent(ifExpr: Expression, elseValue: unknown): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseExpr` argument if `ifFieldName` is absent, else\n * return the value of the field.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns the value of\n * // 'default_field' if 'optional_field' is absent.\n * ifAbsent(\"optional_field\", field(\"default_field\"))\n * ```\n *\n * @param ifFieldName - The field to check for absence.\n * @param elseExpr - The expression that will be evaluated and returned if `ifFieldName` is\n * absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(ifFieldName: string, elseExpr: Expression): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseValue` argument if `ifFieldName` is absent, else\n * return the value of the field.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(\"optional_field\", \"default_value\")\n * ```\n *\n * @param ifFieldName - The field to check for absence.\n * @param elseValue - The value that will be returned if [ifFieldName] is absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(\n  ifFieldName: string | Expression,\n  elseValue: Expression | unknown\n): Expression;\nexport function ifAbsent(\n  fieldNameOrExpression: string | Expression,\n  elseValue: Expression | unknown\n): Expression {\n  return fieldOrExpression(fieldNameOrExpression).ifAbsent(\n    valueToDefaultExpr(elseValue)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with a comma and space.\n * join(\"tags\", \", \")\n * ```\n *\n * @param arrayFieldName - The name of the field containing the array.\n * @param delimiter - The string to use as a delimiter.\n * @returns A new Expression representing the join operation.\n */\nexport function join(arrayFieldName: string, delimiter: string): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join an array of string using the delimiter from the 'separator' field.\n * join(array(['foo', 'bar']), field(\"separator\"))\n * ```\n *\n * @param arrayExpression - An expression that evaluates to an array.\n * @param delimiterExpression - The expression that evaluates to the delimiter string.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayExpression: Expression,\n  delimiterExpression: Expression\n): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with a comma and space.\n * join(field(\"tags\"), \", \")\n * ```\n *\n * @param arrayExpression - An expression that evaluates to an array.\n * @param delimiter - The string to use as a delimiter.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayExpression: Expression,\n  delimiter: string\n): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with the delimiter from the 'separator' field.\n * join('tags', field(\"separator\"))\n * ```\n *\n * @param arrayFieldName - The name of the field containing the array.\n * @param delimiterExpression - The expression that evaluates to the delimiter string.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayFieldName: string,\n  delimiterExpression: Expression\n): Expression;\nexport function join(\n  fieldNameOrExpression: string | Expression,\n  delimiterValueOrExpression: Expression | string\n): Expression {\n  return fieldOrExpression(fieldNameOrExpression).join(\n    valueToDefaultExpr(delimiterValueOrExpression)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that computes the base-10 logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the base-10 logarithm of the 'value' field.\n * log10(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the base-10 logarithm of.\n * @returns A new `Expression` representing the base-10 logarithm of the numeric value.\n */\nexport function log10(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the base-10 logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the base-10 logarithm of the 'value' field.\n * log10(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the base-10 logarithm will be computed for.\n * @returns A new `Expression` representing the base-10 logarithm of the numeric value.\n */\nexport function log10(expression: Expression): FunctionExpression;\nexport function log10(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).log10();\n}\n\n/**\n * @beta\n * Creates an expression that computes the sum of the elements in an array.\n *\n * @example\n * ```typescript\n * // Compute the sum of the elements in the 'scores' field.\n * arraySum(\"scores\");\n * ```\n *\n * @param fieldName - The name of the field to compute the sum of.\n * @returns A new `Expression` representing the sum of the elements in the array.\n */\nexport function arraySum(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the sum of the elements in an array.\n *\n * @example\n * ```typescript\n * // Compute the sum of the elements in the 'scores' field.\n * arraySum(field(\"scores\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric array, which the sum will be computed for.\n * @returns A new `Expression` representing the sum of the elements in the array.\n */\nexport function arraySum(expression: Expression): FunctionExpression;\nexport function arraySum(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).arraySum();\n}\n\n/**\n * @beta\n * Creates an expression that splits the value of a field on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scoresCsv' field on delimiter ','\n * split('scoresCsv', ',')\n * ```\n *\n * @param fieldName - Split the value in this field.\n * @param delimiter - Split on this delimiter.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(fieldName: string, delimiter: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits the value of a field on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n * split('scores', conditional(field('format').equal('csv'), constant(','), constant(':'))\n * ```\n *\n * @param fieldName - Split the value in this field.\n * @param delimiter - Split on this delimiter returned by evaluating this expression.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  fieldName: string,\n  delimiter: Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits a string into an array of substrings based on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scoresCsv' field on delimiter ','\n * split(field('scoresCsv'), ',')\n * ```\n *\n * @param expression - Split the result of this expression.\n * @param delimiter - Split on this delimiter.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  expression: Expression,\n  delimiter: string\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits a string into an array of substrings based on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n * split(field('scores'), conditional(field('format').equal('csv'), constant(','), constant(':'))\n * ```\n *\n * @param expression - Split the result of this expression.\n * @param delimiter - Split on this delimiter returned by evaluating this expression.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  expression: Expression,\n  delimiter: Expression\n): FunctionExpression;\nexport function split(\n  fieldNameOrExpression: string | Expression,\n  delimiter: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldNameOrExpression).split(\n    valueToDefaultExpr(delimiter)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the beginning of the day.\n * field('createdAt').timestampTruncate('day')\n * ```\n *\n * @param fieldName - Truncate the timestamp value contained in this field.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  fieldName: string,\n  granularity: TimeGranularity,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n * field('createdAt').timestampTruncate(field('granularity'))\n * ```\n *\n * @param fieldName - Truncate the timestamp value contained in this field.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  fieldName: string,\n  granularity: Expression,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the beginning of the day.\n * field('createdAt').timestampTruncate('day')\n * ```\n *\n * @param timestampExpression - Truncate the timestamp value that is returned by this expression.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  timestampExpression: Expression,\n  granularity: TimeGranularity,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n * field('createdAt').timestampTruncate(field('granularity'))\n * ```\n *\n * @param timestampExpression - Truncate the timestamp value that is returned by this expression.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  timestampExpression: Expression,\n  granularity: Expression,\n  timezone?: string | Expression\n): FunctionExpression;\nexport function timestampTruncate(\n  fieldNameOrExpression: string | Expression,\n  granularity: TimeGranularity | Expression,\n  timezone?: string | Expression\n): FunctionExpression {\n  const internalGranularity = isString(granularity)\n    ? valueToDefaultExpr(granularity.toLowerCase())\n    : granularity;\n  return fieldOrExpression(fieldNameOrExpression).timestampTruncate(\n    internalGranularity,\n    timezone\n  );\n}\n\n/**\n * @beta\n * Creates an expression that returns the data type of the data in the specified field.\n *\n * @example\n * ```typescript\n * // Get the data type of the value in field 'title'\n * type('title')\n * ```\n *\n * @returns A new `Expression` representing the data type.\n */\nexport function type(fieldName: string): FunctionExpression;\n/**\n * @beta\n * Creates an expression that returns the data type of an expression's result.\n *\n * @example\n * ```typescript\n * // Get the data type of a conditional expression\n * type(conditional(exists('foo'), constant(1), constant(true)))\n * ```\n *\n * @returns A new `Expression` representing the data type.\n */\nexport function type(expression: Expression): FunctionExpression;\nexport function type(\n  fieldNameOrExpression: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldNameOrExpression).type();\n}\n\n// TODO(new-expression): Add new top-level expression function definitions above this line\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on an expression.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in lowercase in ascending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(ascending(field(\"name\").toLower()));\n * ```\n *\n * @param expr - The expression to create an ascending ordering for.\n * @returns A new `Ordering` for ascending sorting.\n */\nexport function ascending(expr: Expression): Ordering;\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on a field.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in ascending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(ascending(\"name\"));\n * ```\n *\n * @param fieldName - The field to create an ascending ordering for.\n * @returns A new `Ordering` for ascending sorting.\n */\nexport function ascending(fieldName: string): Ordering;\nexport function ascending(field: Expression | string): Ordering {\n  return new Ordering(fieldOrExpression(field), 'ascending', 'ascending');\n}\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on an expression.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in lowercase in descending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(descending(field(\"name\").toLower()));\n * ```\n *\n * @param expr - The expression to create a descending ordering for.\n * @returns A new `Ordering` for descending sorting.\n */\nexport function descending(expr: Expression): Ordering;\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on a field.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in descending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(descending(\"name\"));\n * ```\n *\n * @param fieldName - The field to create a descending ordering for.\n * @returns A new `Ordering` for descending sorting.\n */\nexport function descending(fieldName: string): Ordering;\nexport function descending(field: Expression | string): Ordering {\n  return new Ordering(fieldOrExpression(field), 'descending', 'descending');\n}\n\n/**\n * @beta\n *\n * Represents an ordering criterion for sorting documents in a Firestore pipeline.\n *\n * You create `Ordering` instances using the `ascending` and `descending` helper functions.\n */\nexport class Ordering implements ProtoValueSerializable, UserData {\n  constructor(\n    public readonly expr: Expression,\n    public readonly direction: 'ascending' | 'descending',\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      mapValue: {\n        fields: {\n          direction: toStringValue(this.direction),\n          expression: this.expr._toProto(serializer)\n        }\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.expr._readUserData(context);\n  }\n\n  _protoValueType: 'ProtoValue' = 'ProtoValue';\n}\n\nexport function isSelectable(val: unknown): val is Selectable {\n  const candidate = val as Selectable;\n  return (\n    candidate.selectable && isString(candidate.alias) && isExpr(candidate.expr)\n  );\n}\n\nexport function isOrdering(val: unknown): val is Ordering {\n  const candidate = val as Ordering;\n  return (\n    isExpr(candidate.expr) &&\n    (candidate.direction === 'ascending' ||\n      candidate.direction === 'descending')\n  );\n}\n\nexport function isAliasedAggregate(val: unknown): val is AliasedAggregate {\n  const candidate = val as AliasedAggregate;\n  return (\n    isString(candidate.alias) &&\n    candidate.aggregate instanceof AggregateFunction\n  );\n}\n\nexport function isExpr(val: unknown): val is Expression {\n  return val instanceof Expression;\n}\n\nexport function isBooleanExpr(val: unknown): val is BooleanExpression {\n  return val instanceof BooleanExpression;\n}\n\nexport function isField(val: unknown): val is Field {\n  return val instanceof Field;\n}\n\nexport function toField(value: string | Field): Field {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return value as Field;\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Firestore } from '../lite-api/database';\nimport {\n  Constant,\n  BooleanExpression,\n  and,\n  or,\n  Ordering,\n  lessThan,\n  greaterThan,\n  field\n} from '../lite-api/expressions';\nimport { Pipeline } from '../lite-api/pipeline';\nimport { doc } from '../lite-api/reference';\nimport { fail } from '../util/assert';\n\nimport { Bound } from './bound';\nimport {\n  CompositeFilter as CompositeFilterInternal,\n  CompositeOperator,\n  FieldFilter as FieldFilterInternal,\n  Filter as FilterInternal,\n  Operator\n} from './filter';\nimport { Direction } from './order_by';\nimport {\n  isCollectionGroupQuery,\n  isDocumentQuery,\n  LimitType,\n  Query,\n  queryNormalizedOrderBy\n} from './query';\n\n/* eslint @typescript-eslint/no-explicit-any: 0 */\n\nexport function toPipelineBooleanExpr(f: FilterInternal): BooleanExpression {\n  if (f instanceof FieldFilterInternal) {\n    const fieldValue = field(f.field.toString());\n    // Comparison filters\n    const value = f.value;\n    switch (f.op) {\n      case Operator.LESS_THAN:\n        return and(\n          fieldValue.exists(),\n          fieldValue.lessThan(Constant._fromProto(value))\n        );\n      case Operator.LESS_THAN_OR_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.lessThanOrEqual(Constant._fromProto(value))\n        );\n      case Operator.GREATER_THAN:\n        return and(\n          fieldValue.exists(),\n          fieldValue.greaterThan(Constant._fromProto(value))\n        );\n      case Operator.GREATER_THAN_OR_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.greaterThanOrEqual(Constant._fromProto(value))\n        );\n      case Operator.EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.equal(Constant._fromProto(value))\n        );\n      case Operator.NOT_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.notEqual(Constant._fromProto(value))\n        );\n      case Operator.ARRAY_CONTAINS:\n        return and(\n          fieldValue.exists(),\n          fieldValue.arrayContains(Constant._fromProto(value))\n        );\n      case Operator.IN: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        if (!values) {\n          return and(fieldValue.exists(), fieldValue.equalAny([]));\n        } else if (values.length === 1) {\n          return and(fieldValue.exists(), fieldValue.equal(values[0]));\n        } else {\n          return and(fieldValue.exists(), fieldValue.equalAny(values));\n        }\n      }\n      case Operator.ARRAY_CONTAINS_ANY: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        return and(fieldValue.exists(), fieldValue.arrayContainsAny(values!));\n      }\n      case Operator.NOT_IN: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        if (!values) {\n          return and(fieldValue.exists(), fieldValue.notEqualAny([]));\n        } else if (values.length === 1) {\n          return and(fieldValue.exists(), fieldValue.notEqual(values[0]));\n        } else {\n          return and(fieldValue.exists(), fieldValue.notEqualAny(values));\n        }\n      }\n      default:\n        fail(0x9047, 'Unexpected operator');\n    }\n  } else if (f instanceof CompositeFilterInternal) {\n    switch (f.op) {\n      case CompositeOperator.AND: {\n        const conditions = f.getFilters().map(f => toPipelineBooleanExpr(f));\n        return and(conditions[0], conditions[1], ...conditions.slice(2));\n      }\n      case CompositeOperator.OR: {\n        const conditions = f.getFilters().map(f => toPipelineBooleanExpr(f));\n        return or(conditions[0], conditions[1], ...conditions.slice(2));\n      }\n      default:\n        fail(0x89ea, 'Unexpected operator');\n    }\n  }\n\n  throw new Error(`Failed to convert filter to pipeline conditions: ${f}`);\n}\n\nfunction reverseOrderings(orderings: Ordering[]): Ordering[] {\n  return orderings.map(\n    o =>\n      new Ordering(\n        o.expr,\n        o.direction === 'ascending' ? 'descending' : 'ascending',\n        undefined\n      )\n  );\n}\n\nexport function toPipeline(query: Query, db: Firestore): Pipeline {\n  let pipeline: Pipeline;\n  if (isCollectionGroupQuery(query)) {\n    pipeline = db.pipeline().collectionGroup(query.collectionGroup!);\n  } else if (isDocumentQuery(query)) {\n    pipeline = db.pipeline().documents([doc(db, query.path.canonicalString())]);\n  } else {\n    pipeline = db.pipeline().collection(query.path.canonicalString());\n  }\n\n  // filters\n  for (const filter of query.filters) {\n    pipeline = pipeline.where(toPipelineBooleanExpr(filter));\n  }\n\n  // orders\n  const orders = queryNormalizedOrderBy(query);\n  const existsConditions = orders.map(order =>\n    field(order.field.canonicalString()).exists()\n  );\n  if (existsConditions.length > 1) {\n    pipeline = pipeline.where(\n      and(\n        existsConditions[0],\n        existsConditions[1],\n        ...existsConditions.slice(2)\n      )\n    );\n  } else {\n    pipeline = pipeline.where(existsConditions[0]);\n  }\n\n  const orderings = orders.map(order =>\n    order.dir === Direction.ASCENDING\n      ? field(order.field.canonicalString()).ascending()\n      : field(order.field.canonicalString()).descending()\n  );\n\n  if (orderings.length > 0) {\n    if (query.limitType === LimitType.Last) {\n      const actualOrderings = reverseOrderings(orderings);\n      pipeline = pipeline.sort(actualOrderings[0], ...actualOrderings.slice(1));\n      // cursors\n      if (query.startAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.startAt, orderings, 'after')\n        );\n      }\n\n      if (query.endAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.endAt, orderings, 'before')\n        );\n      }\n\n      pipeline = pipeline.limit(query.limit!);\n      pipeline = pipeline.sort(orderings[0], ...orderings.slice(1));\n    } else {\n      pipeline = pipeline.sort(orderings[0], ...orderings.slice(1));\n      if (query.startAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.startAt, orderings, 'after')\n        );\n      }\n      if (query.endAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.endAt, orderings, 'before')\n        );\n      }\n\n      if (query.limit !== null) {\n        pipeline = pipeline.limit(query.limit);\n      }\n    }\n  }\n\n  return pipeline;\n}\n\nfunction whereConditionsFromCursor(\n  bound: Bound,\n  orderings: Ordering[],\n  position: 'before' | 'after'\n): BooleanExpression {\n  // The filterFunc is either greater than or less than\n  const filterFunc = position === 'before' ? lessThan : greaterThan;\n  const cursors = bound.position.map(value => Constant._fromProto(value));\n  const size = cursors.length;\n\n  let field = orderings[size - 1].expr;\n  let value = cursors[size - 1];\n\n  // Add condition for last bound\n  let condition: BooleanExpression = filterFunc(field, value);\n  if (bound.inclusive) {\n    // When the cursor bound is inclusive, then the last bound\n    // can be equal to the value, otherwise it's not equal\n    condition = or(condition, field.equal(value));\n  }\n\n  // Iterate backwards over the remaining bounds, adding\n  // a condition for each one\n  for (let i = size - 2; i >= 0; i--) {\n    field = orderings[i].expr;\n    value = cursors[i];\n\n    // For each field in the orderings, the condition is either\n    // a) lt|gt the cursor value,\n    // b) or equal the cursor value and lt|gt the cursor values for other fields\n    condition = or(\n      filterFunc(field, value),\n      and(field.equal(value), condition)\n    );\n  }\n\n  return condition;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParseContext } from '../api/parse_context';\nimport { OptionsUtil } from '../core/options_util';\nimport {\n  ApiClientObjectMap,\n  firestoreV1ApiClientInterfaces,\n  Stage as ProtoStage\n} from '../protos/firestore_proto_api';\nimport { toNumber } from '../remote/number_serializer';\nimport {\n  JsonProtoSerializer,\n  ProtoSerializable,\n  toMapValue,\n  toPipelineValue,\n  toStringValue\n} from '../remote/serializer';\nimport { hardAssert } from '../util/assert';\n\nimport {\n  AggregateFunction,\n  BooleanExpression,\n  Expression,\n  Field,\n  field,\n  Ordering\n} from './expressions';\nimport { Pipeline } from './pipeline';\nimport { StageOptions } from './stage_options';\nimport { isUserData, UserData } from './user_data_reader';\n\n/**\n * @beta\n */\nexport abstract class Stage implements ProtoSerializable<ProtoStage>, UserData {\n  /**\n   * Store optionsProto parsed by _readUserData.\n   * @private\n   * @internal\n   * @protected\n   */\n  protected optionsProto:\n    | ApiClientObjectMap<firestoreV1ApiClientInterfaces.Value>\n    | undefined = undefined;\n  protected knownOptions: Record<string, unknown>;\n  protected rawOptions?: Record<string, unknown>;\n\n  constructor(options: StageOptions) {\n    ({ rawOptions: this.rawOptions, ...this.knownOptions } = options);\n  }\n\n  _readUserData(context: ParseContext): void {\n    this.optionsProto = this._optionsUtil.getOptionsProto(\n      context,\n      this.knownOptions,\n      this.rawOptions\n    );\n  }\n\n  _toProto(_: JsonProtoSerializer): ProtoStage {\n    return {\n      name: this._name,\n      options: this.optionsProto\n    };\n  }\n\n  abstract get _optionsUtil(): OptionsUtil;\n  abstract get _name(): string;\n}\n\n/**\n * @beta\n */\nexport class AddFields extends Stage {\n  get _name(): string {\n    return 'add_fields';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private fields: Map<string, Expression>, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.fields)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.fields, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class RemoveFields extends Stage {\n  get _name(): string {\n    return 'remove_fields';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private fields: Field[], options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.fields.map(f => f._toProto(serializer))\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.fields, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Aggregate extends Stage {\n  get _name(): string {\n    return 'aggregate';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private groups: Map<string, Expression>,\n    private accumulators: Map<string, AggregateFunction>,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        toMapValue(serializer, this.accumulators),\n        toMapValue(serializer, this.groups)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.groups, context);\n    readUserDataHelper(this.accumulators, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Distinct extends Stage {\n  get _name(): string {\n    return 'distinct';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private groups: Map<string, Expression>, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.groups)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.groups, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class CollectionSource extends Stage {\n  get _name(): string {\n    return 'collection';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      forceIndex: {\n        serverName: 'force_index'\n      }\n    });\n  }\n\n  private formattedCollectionPath: string;\n\n  constructor(collection: string, options: StageOptions) {\n    super(options);\n\n    // prepend slash to collection string\n    this.formattedCollectionPath = collection.startsWith('/')\n      ? collection\n      : '/' + collection;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [{ referenceValue: this.formattedCollectionPath }]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class CollectionGroupSource extends Stage {\n  get _name(): string {\n    return 'collection_group';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      forceIndex: {\n        serverName: 'force_index'\n      }\n    });\n  }\n\n  constructor(private collectionId: string, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [{ referenceValue: '' }, { stringValue: this.collectionId }]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class DatabaseSource extends Stage {\n  get _name(): string {\n    return 'database';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer)\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class DocumentsSource extends Stage {\n  get _name(): string {\n    return 'documents';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  private formattedPaths: string[];\n\n  constructor(docPaths: string[], options: StageOptions) {\n    super(options);\n    this.formattedPaths = docPaths.map(path =>\n      path.startsWith('/') ? path : '/' + path\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.formattedPaths.map(p => {\n        return { referenceValue: p };\n      })\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Where extends Stage {\n  get _name(): string {\n    return 'where';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private condition: BooleanExpression, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [this.condition._toProto(serializer)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.condition, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class FindNearest extends Stage {\n  get _name(): string {\n    return 'find_nearest';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      limit: {\n        serverName: 'limit'\n      },\n      distanceField: {\n        serverName: 'distance_field'\n      }\n    });\n  }\n\n  constructor(\n    private vectorValue: Expression,\n    private field: Field,\n    private distanceMeasure: 'euclidean' | 'cosine' | 'dot_product',\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        this.field._toProto(serializer),\n        this.vectorValue._toProto(serializer),\n        toStringValue(this.distanceMeasure)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.vectorValue, context);\n    readUserDataHelper(this.field, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Limit extends Stage {\n  get _name(): string {\n    return 'limit';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private limit: number, options: StageOptions) {\n    hardAssert(\n      !isNaN(limit) && limit !== Infinity && limit !== -Infinity,\n      0x882c,\n      'Invalid limit value'\n    );\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.limit)]\n    };\n  }\n}\n\n/**\n * @beta\n */\nexport class Offset extends Stage {\n  get _name(): string {\n    return 'offset';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private offset: number, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.offset)]\n    };\n  }\n}\n\n/**\n * @beta\n */\nexport class Select extends Stage {\n  get _name(): string {\n    return 'select';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private selections: Map<string, Expression>,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.selections)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.selections, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Sort extends Stage {\n  get _name(): string {\n    return 'sort';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private orderings: Ordering[], options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.orderings.map(o => o._toProto(serializer))\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.orderings, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Sample extends Stage {\n  get _name(): string {\n    return 'sample';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private rate: number,\n    private mode: 'percent' | 'documents',\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.rate)!, toStringValue(this.mode)!]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Union extends Stage {\n  get _name(): string {\n    return 'union';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private other: Pipeline, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toPipelineValue(this.other._toProto(serializer))]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Unnest extends Stage {\n  get _name(): string {\n    return 'unnest';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      indexField: {\n        serverName: 'index_field'\n      }\n    });\n  }\n\n  constructor(\n    private alias: string,\n    private expr: Expression,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        this.expr._toProto(serializer),\n        field(this.alias)._toProto(serializer)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.expr, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Replace extends Stage {\n  static readonly MODE = 'full_replace';\n\n  get _name(): string {\n    return 'replace_with';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private map: Expression, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [this.map._toProto(serializer), toStringValue(Replace.MODE)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.map, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class RawStage extends Stage {\n  /**\n   * @private\n   * @internal\n   */\n  constructor(\n    private name: string,\n    private params: Array<AggregateFunction | Expression>,\n    rawOptions: Record<string, unknown>\n  ) {\n    super({ rawOptions });\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      name: this.name,\n      args: this.params.map(o => o._toProto(serializer)),\n      options: this.optionsProto\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.params, context);\n  }\n\n  get _name(): string {\n    return this.name;\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n}\n\n/**\n * Helper to read user data across a number of different formats.\n * @param name - Name of the calling function. Used for error messages when invalid user data is encountered.\n * @param expressionMap\n * @returns the expressionMap argument.\n * @private\n */\nfunction readUserDataHelper<\n  T extends Map<string, UserData> | UserData[] | UserData\n>(expressionMap: T, context: ParseContext): T {\n  if (isUserData(expressionMap)) {\n    expressionMap._readUserData(context);\n  } else if (Array.isArray(expressionMap)) {\n    expressionMap.forEach(readableData => readableData._readUserData(context));\n  } else {\n    expressionMap.forEach(expr => expr._readUserData(context));\n  }\n  return expressionMap;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DatabaseId } from '../core/database_info';\nimport { toPipeline } from '../core/pipeline-util';\nimport { Code, FirestoreError } from '../util/error';\nimport { isString } from '../util/types';\n\nimport { Pipeline } from './pipeline';\nimport {\n  CollectionReference,\n  DocumentReference,\n  isCollectionReference,\n  Query\n} from './reference';\nimport {\n  CollectionGroupSource,\n  CollectionSource,\n  DatabaseSource,\n  DocumentsSource,\n  Stage\n} from './stage';\nimport {\n  CollectionGroupStageOptions,\n  CollectionStageOptions,\n  DatabaseStageOptions,\n  DocumentsStageOptions\n} from './stage_options';\nimport { UserDataReader, UserDataSource } from './user_data_reader';\n\n/**\n * @beta\n * Provides the entry point for defining the data source of a Firestore {@link @firebase/firestore/pipelines#Pipeline}.\n *\n * Use the methods of this class (e.g., {@link @firebase/firestore/pipelines#PipelineSource.(collection:1)}, {@link @firebase/firestore/pipelines#PipelineSource.(collectionGroup:1)},\n * {@link @firebase/firestore/pipelines#PipelineSource.(database:1)}, or {@link @firebase/firestore/pipelines#PipelineSource.(documents:1)}) to specify the initial data\n * for your pipeline, such as a collection, a collection group, the entire database, or a set of specific documents.\n */\nexport class PipelineSource<PipelineType> {\n  /**\n   * @internal\n   * @private\n   * @param databaseId\n   * @param userDataReader\n   * @param _createPipeline\n   */\n  constructor(\n    private databaseId: DatabaseId,\n    private userDataReader: UserDataReader,\n    /**\n     * @internal\n     * @private\n     */\n    public _createPipeline: (stages: Stage[]) => PipelineType\n  ) {}\n\n  /**\n   * @beta\n   * Returns all documents from the entire collection. The collection can be nested.\n   * @param collection - Name or reference to the collection that will be used as the Pipeline source.\n   */\n  collection(collection: string | CollectionReference): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from the entire collection. The collection can be nested.\n   * @param options - Options defining how this CollectionStage is evaluated.\n   */\n  collection(options: CollectionStageOptions): PipelineType;\n  collection(\n    collectionOrOptions: string | CollectionReference | CollectionStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(collectionOrOptions) ||\n      isCollectionReference(collectionOrOptions)\n        ? {}\n        : collectionOrOptions;\n    const collectionRefOrString =\n      isString(collectionOrOptions) ||\n      isCollectionReference(collectionOrOptions)\n        ? collectionOrOptions\n        : collectionOrOptions.collection;\n\n    // Validate that a user provided reference is for the same Firestore DB\n    if (isCollectionReference(collectionRefOrString)) {\n      this._validateReference(collectionRefOrString);\n    }\n\n    // Convert user land convenience types to internal types\n    const normalizedCollection = isString(collectionRefOrString)\n      ? (collectionRefOrString as string)\n      : collectionRefOrString.path;\n\n    // Create stage object\n    const stage = new CollectionSource(normalizedCollection, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'collection'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Returns all documents from a collection ID regardless of the parent.\n   * @param collectionId - ID of the collection group to use as the Pipeline source.\n   */\n  collectionGroup(collectionId: string): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from a collection ID regardless of the parent.\n   * @param options - Options defining how this CollectionGroupStage is evaluated.\n   */\n  collectionGroup(options: CollectionGroupStageOptions): PipelineType;\n  collectionGroup(\n    collectionIdOrOptions: string | CollectionGroupStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    let collectionId: string;\n    let options: {};\n    if (isString(collectionIdOrOptions)) {\n      collectionId = collectionIdOrOptions;\n      options = {};\n    } else {\n      ({ collectionId, ...options } = collectionIdOrOptions);\n    }\n\n    // Create stage object\n    const stage = new CollectionGroupSource(collectionId, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'collectionGroup'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Returns all documents from the entire database.\n   */\n  database(): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from the entire database.\n   * @param options - Options defining how a DatabaseStage is evaluated.\n   */\n  database(options: DatabaseStageOptions): PipelineType;\n  database(options?: DatabaseStageOptions): PipelineType {\n    // Process argument union(s) from method overloads\n    options = options ?? {};\n\n    // Create stage object\n    const stage = new DatabaseSource(options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'database'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Set the pipeline's source to the documents specified by the given paths and DocumentReferences.\n   *\n   * @param docs - An array of paths and DocumentReferences specifying the individual documents that will be the source of this pipeline.\n   * The converters for these DocumentReferences will be ignored and not have an effect on this pipeline.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  documents(docs: Array<string | DocumentReference>): PipelineType;\n\n  /**\n   * @beta\n   * Set the pipeline's source to the documents specified by the given paths and DocumentReferences.\n   *\n   * @param options - Options defining how this DocumentsStage is evaluated.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  documents(options: DocumentsStageOptions): PipelineType;\n  documents(\n    docsOrOptions: Array<string | DocumentReference> | DocumentsStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let docs: Array<string | DocumentReference>;\n    if (Array.isArray(docsOrOptions)) {\n      docs = docsOrOptions;\n      options = {};\n    } else {\n      ({ docs, ...options } = docsOrOptions);\n    }\n\n    // Validate that all user provided references are for the same Firestore DB\n    docs\n      .filter(v => v instanceof DocumentReference)\n      .forEach(dr => this._validateReference(dr as DocumentReference));\n\n    // Convert user land convenience types to internal types\n    const normalizedDocs: string[] = docs.map(doc =>\n      isString(doc) ? doc : doc.path\n    );\n\n    // Create stage object\n    const stage = new DocumentsSource(normalizedDocs, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'documents'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Convert the given Query into an equivalent Pipeline.\n   *\n   * @param query - A Query to be converted into a Pipeline.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  createFrom(query: Query): Pipeline {\n    return toPipeline(query._query, query.firestore);\n  }\n\n  _validateReference(reference: CollectionReference | DocumentReference): void {\n    const refDbId = reference.firestore._databaseId;\n    if (!refDbId.isEqual(this.databaseId)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid ${\n          reference instanceof CollectionReference\n            ? 'CollectionReference'\n            : 'DocumentReference'\n        }. ` +\n          `The project ID (\"${refDbId.projectId}\") or the database (\"${refDbId.database}\") does not match ` +\n          `the project ID (\"${this.databaseId.projectId}\") and database (\"${this.databaseId.database}\") of the target database of this Pipeline.`\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ObjectValue } from '../model/object_value';\nimport { firestoreV1ApiClientInterfaces } from '../protos/firestore_proto_api';\nimport { isOptionalEqual } from '../util/misc';\n\nimport { Field, isField } from './expressions';\nimport { FieldPath } from './field_path';\nimport { Pipeline } from './pipeline';\nimport { DocumentData, DocumentReference, refEqual } from './reference';\nimport { Timestamp } from './timestamp';\nimport { fieldPathFromArgument } from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * @beta\n * Represents the results of a Firestore pipeline execution.\n *\n * A `PipelineSnapshot` contains zero or more {@link @firebase/firestore/pipelines#PipelineResult} objects\n * representing the documents returned by a pipeline query. It provides methods\n * to iterate over the documents and access metadata about the query results.\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await firestore\n *   .pipeline()\n *   .collection('myCollection')\n *   .where(field('value').greaterThan(10))\n *   .execute();\n *\n * snapshot.results.forEach(doc => {\n *   console.log(doc.id, '=>', doc.data());\n * });\n * ```\n */\nexport class PipelineSnapshot {\n  private readonly _pipeline: Pipeline;\n  private readonly _executionTime: Timestamp | undefined;\n  private readonly _results: PipelineResult[];\n  constructor(\n    pipeline: Pipeline,\n    results: PipelineResult[],\n    executionTime?: Timestamp\n  ) {\n    this._pipeline = pipeline;\n    this._executionTime = executionTime;\n    this._results = results;\n  }\n\n  /**\n   * @beta An array of all the results in the `PipelineSnapshot`.\n   */\n  get results(): PipelineResult[] {\n    return this._results;\n  }\n\n  /**\n   * @beta\n   * The time at which the pipeline producing this result is executed.\n   *\n   * @readonly\n   *\n   */\n  get executionTime(): Timestamp {\n    if (this._executionTime === undefined) {\n      throw new Error(\n        \"'executionTime' is expected to exist, but it is undefined\"\n      );\n    }\n    return this._executionTime;\n  }\n}\n\n/**\n * @beta\n *\n * A PipelineResult contains data read from a Firestore Pipeline. The data can be extracted with the\n * {@link @firebase/firestore/pipelines#PipelineResult.data} or {@link @firebase/firestore/pipelines#PipelineResult.(get:1)} methods.\n *\n * <p>If the PipelineResult represents a non-document result, `ref` will return a undefined\n * value.\n */\nexport class PipelineResult<AppModelType = DocumentData> {\n  private readonly _userDataWriter: AbstractUserDataWriter;\n\n  private readonly _createTime: Timestamp | undefined;\n  private readonly _updateTime: Timestamp | undefined;\n\n  /**\n   * @internal\n   * @private\n   */\n  readonly _ref: DocumentReference | undefined;\n\n  /**\n   * @internal\n   * @private\n   */\n  readonly _fields: ObjectValue;\n\n  /**\n   * @private\n   * @internal\n   *\n   * @param userDataWriter - The serializer used to encode/decode protobuf.\n   * @param ref - The reference to the document.\n   * @param fields - The fields of the Firestore `Document` Protobuf backing\n   * this document.\n   * @param createTime - The time when the document was created if the result is a document, undefined otherwise.\n   * @param updateTime - The time when the document was last updated if the result is a document, undefined otherwise.\n   */\n  constructor(\n    userDataWriter: AbstractUserDataWriter,\n    fields: ObjectValue,\n    ref?: DocumentReference,\n    createTime?: Timestamp,\n    updateTime?: Timestamp\n  ) {\n    this._ref = ref;\n    this._userDataWriter = userDataWriter;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n    this._fields = fields;\n  }\n\n  /**\n   * @beta\n   * The reference of the document, if it is a document; otherwise `undefined`.\n   */\n  get ref(): DocumentReference | undefined {\n    return this._ref;\n  }\n\n  /**\n   * @beta\n   * The ID of the document for which this PipelineResult contains data, if it is a document; otherwise `undefined`.\n   *\n   * @readonly\n   *\n   */\n  get id(): string | undefined {\n    return this._ref?.id;\n  }\n\n  /**\n   * @beta\n   * The time the document was created. Undefined if this result is not a document.\n   *\n   * @readonly\n   */\n  get createTime(): Timestamp | undefined {\n    return this._createTime;\n  }\n\n  /**\n   * @beta\n   * The time the document was last updated (at the time the snapshot was\n   * generated). Undefined if this result is not a document.\n   *\n   * @readonly\n   */\n  get updateTime(): Timestamp | undefined {\n    return this._updateTime;\n  }\n\n  /**\n   * @beta\n   * Retrieves all fields in the result as an object.\n   *\n   * @returns An object containing all fields in the document or\n   * 'undefined' if the document doesn't exist.\n   *\n   * @example\n   * ```\n   * let p = firestore.pipeline().collection('col');\n   *\n   * p.execute().then(results => {\n   *   let data = results[0].data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   * ```\n   */\n  data(): AppModelType {\n    return this._userDataWriter.convertValue(\n      this._fields.value\n    ) as AppModelType;\n  }\n\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the result as a proto value.\n   *\n   * @returns An `Object` containing all fields in the result.\n   */\n  _fieldsProto(): { [key: string]: firestoreV1ApiClientInterfaces.Value } {\n    // Return a cloned value to prevent manipulation of the Snapshot's data\n    return this._fields.clone().value.mapValue.fields!;\n  }\n\n  /**\n   * @beta\n   * Retrieves the field specified by `field`.\n   *\n   * @param field - The field path\n   * (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns The data at the specified field location or `undefined` if no\n   * such field exists.\n   *\n   * @example\n   * ```\n   * let p = firestore.pipeline().collection('col');\n   *\n   * p.execute().then(results => {\n   *   let field = results[0].get('a.b');\n   *   console.log(`Retrieved field value: ${field}`);\n   * });\n   * ```\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(fieldPath: string | FieldPath | Field): any {\n    if (this._fields === undefined) {\n      return undefined;\n    }\n    if (isField(fieldPath)) {\n      fieldPath = fieldPath.fieldName;\n    }\n\n    const value = this._fields.field(\n      fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n    );\n    if (value !== null) {\n      return this._userDataWriter.convertValue(value);\n    }\n  }\n}\n\n/**\n * @beta\n * Test equality of two PipelineResults.\n * @param left - First PipelineResult to compare.\n * @param right - Second PipelineResult to compare.\n */\nexport function pipelineResultEqual(\n  left: PipelineResult,\n  right: PipelineResult\n): boolean {\n  if (left === right) {\n    return true;\n  }\n\n  return (\n    isOptionalEqual(left._ref, right._ref, refEqual) &&\n    isOptionalEqual(left._fields, right._fields, (l, r) => l.isEqual(r))\n  );\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirestoreError, vector } from '../api';\nimport {\n  _constant,\n  AggregateFunction,\n  AliasedAggregate,\n  array,\n  constant,\n  Expression,\n  AliasedExpression,\n  field,\n  Field,\n  map,\n  Selectable\n} from '../lite-api/expressions';\nimport { VectorValue } from '../lite-api/vector_value';\n\nimport { fail } from './assert';\nimport { isPlainObject } from './input_validation';\nimport { isFirestoreValue } from './proto';\nimport { isString } from './types';\n\nexport function selectablesToMap(\n  selectables: Array<Selectable | string>\n): Map<string, Expression> {\n  const result = new Map<string, Expression>();\n  for (const selectable of selectables) {\n    let alias: string;\n    let expression: Expression;\n    if (typeof selectable === 'string') {\n      alias = selectable as string;\n      expression = field(selectable);\n    } else if (selectable instanceof Field) {\n      alias = selectable.alias;\n      expression = selectable.expr;\n    } else if (selectable instanceof AliasedExpression) {\n      alias = selectable.alias;\n      expression = selectable.expr;\n    } else {\n      fail(0x5319, '`selectable` has an unsupported type', { selectable });\n    }\n\n    if (result.get(alias) !== undefined) {\n      throw new FirestoreError(\n        'invalid-argument',\n        `Duplicate alias or field '${alias}'`\n      );\n    }\n\n    result.set(alias, expression);\n  }\n  return result;\n}\n\nexport function aliasedAggregateToMap(\n  aliasedAggregatees: AliasedAggregate[]\n): Map<string, AggregateFunction> {\n  return aliasedAggregatees.reduce(\n    (map: Map<string, AggregateFunction>, selectable: AliasedAggregate) => {\n      if (map.get(selectable.alias) !== undefined) {\n        throw new FirestoreError(\n          'invalid-argument',\n          `Duplicate alias or field '${selectable.alias}'`\n        );\n      }\n\n      map.set(selectable.alias, selectable.aggregate as AggregateFunction);\n      return map;\n    },\n    new Map() as Map<string, AggregateFunction>\n  );\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nexport function vectorToExpr(\n  value: VectorValue | number[] | Expression\n): Expression {\n  if (value instanceof Expression) {\n    return value;\n  } else if (value instanceof VectorValue) {\n    const result = constant(value);\n    return result;\n  } else if (Array.isArray(value)) {\n    const result = constant(vector(value));\n    return result;\n  } else {\n    throw new Error('Unsupported value: ' + typeof value);\n  }\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n * If the input is a string, it is assumed to be a field name, and a\n * field(value) is returned.\n *\n * @private\n * @internal\n * @param value\n */\nexport function fieldOrExpression(value: unknown): Expression {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return valueToDefaultExpr(value);\n  }\n}\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nexport function valueToDefaultExpr(value: unknown): Expression {\n  let result: Expression | undefined;\n  if (isFirestoreValue(value)) {\n    return constant(value);\n  }\n  if (value instanceof Expression) {\n    return value;\n  } else if (isPlainObject(value)) {\n    result = map(value as Record<string, unknown>);\n  } else if (value instanceof Array) {\n    result = array(value);\n  } else {\n    result = _constant(value, undefined);\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Pipeline as ProtoPipeline,\n  Stage as ProtoStage\n} from '../protos/firestore_proto_api';\nimport { JsonProtoSerializer, ProtoSerializable } from '../remote/serializer';\nimport { isPlainObject } from '../util/input_validation';\nimport {\n  aliasedAggregateToMap,\n  fieldOrExpression,\n  selectablesToMap,\n  vectorToExpr\n} from '../util/pipeline_util';\nimport { isNumber, isString } from '../util/types';\n\nimport { Firestore } from './database';\nimport {\n  _mapValue,\n  AggregateFunction,\n  AliasedAggregate,\n  BooleanExpression,\n  _constant,\n  Expression,\n  Field,\n  field,\n  Ordering,\n  Selectable,\n  _field,\n  isSelectable,\n  isField,\n  isBooleanExpr,\n  isAliasedAggregate,\n  toField,\n  isOrdering,\n  isExpr\n} from './expressions';\nimport {\n  AddFields,\n  Aggregate,\n  Distinct,\n  FindNearest,\n  RawStage,\n  Limit,\n  Offset,\n  RemoveFields,\n  Replace,\n  Sample,\n  Select,\n  Sort,\n  Stage,\n  Union,\n  Unnest,\n  Where\n} from './stage';\nimport {\n  AddFieldsStageOptions,\n  AggregateStageOptions,\n  DistinctStageOptions,\n  FindNearestStageOptions,\n  LimitStageOptions,\n  OffsetStageOptions,\n  RemoveFieldsStageOptions,\n  ReplaceWithStageOptions,\n  SampleStageOptions,\n  SelectStageOptions,\n  SortStageOptions,\n  StageOptions,\n  UnionStageOptions,\n  UnnestStageOptions,\n  WhereStageOptions\n} from './stage_options';\nimport { UserDataReader, UserDataSource } from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * @beta\n *\n * The Pipeline class provides a flexible and expressive framework for building complex data\n * transformation and query pipelines for Firestore.\n *\n * A pipeline takes data sources, such as Firestore collections or collection groups, and applies\n * a series of stages that are chained together. Each stage takes the output from the previous stage\n * (or the data source) and produces an output for the next stage (or as the final output of the\n * pipeline).\n *\n * Expressions can be used within each stage to filter and transform data through the stage.\n *\n * NOTE: The chained stages do not prescribe exactly how Firestore will execute the pipeline.\n * Instead, Firestore only guarantees that the result is the same as if the chained stages were\n * executed in order.\n *\n * Usage Examples:\n *\n * @example\n * ```typescript\n * const db: Firestore; // Assumes a valid firestore instance.\n *\n * // Example 1: Select specific fields and rename 'rating' to 'bookRating'\n * const results1 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .select(\"title\", \"author\", field(\"rating\").as(\"bookRating\")));\n *\n * // Example 2: Filter documents where 'genre' is \"Science Fiction\" and 'published' is after 1950\n * const results2 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .where(and(field(\"genre\").eq(\"Science Fiction\"), field(\"published\").gt(1950))));\n *\n * // Example 3: Calculate the average rating of books published after 1980\n * const results3 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .where(field(\"published\").gt(1980))\n *     .aggregate(avg(field(\"rating\")).as(\"averageRating\")));\n * ```\n */\nexport class Pipeline implements ProtoSerializable<ProtoPipeline> {\n  /**\n   * @internal\n   * @private\n   * @param _db\n   * @param userDataReader\n   * @param _userDataWriter\n   * @param stages\n   */\n  constructor(\n    /**\n     * @internal\n     * @private\n     */\n    public _db: Firestore,\n    /**\n     * @internal\n     * @private\n     */\n    private userDataReader: UserDataReader,\n    /**\n     * @internal\n     * @private\n     */\n    public _userDataWriter: AbstractUserDataWriter,\n    /**\n     * @internal\n     * @private\n     */\n    private stages: Stage[]\n  ) {}\n\n  /**\n   * @beta\n   * Adds new fields to outputs from previous stages.\n   *\n   * This stage allows you to compute values on-the-fly based on existing data from previous\n   * stages or constants. You can use this to create new fields or overwrite existing ones (if there\n   * is name overlaps).\n   *\n   * The added fields are defined using {@link @firebase/firestore/pipelines#Selectable}s, which can be:\n   *\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#Expression}: Either a literal value (see {@link @firebase/firestore/pipelines#(constant:1)}) or a computed value\n   *   with an assigned alias using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .addFields(\n   *     field(\"rating\").as(\"bookRating\"), // Rename 'rating' to 'bookRating'\n   *     add(5, field(\"quantity\")).as(\"totalCost\")  // Calculate 'totalCost'\n   *   );\n   * ```\n   *\n   * @param field - The first field to add to the documents, specified as a {@link @firebase/firestore/pipelines#Selectable}.\n   * @param additionalFields - Optional additional fields to add to the documents, specified as {@link @firebase/firestore/pipelines#Selectable}s.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  addFields(field: Selectable, ...additionalFields: Selectable[]): Pipeline;\n  /**\n   * @beta\n   * Adds new fields to outputs from previous stages.\n   *\n   * This stage allows you to compute values on-the-fly based on existing data from previous\n   * stages or constants. You can use this to create new fields or overwrite existing ones (if there\n   * is name overlaps).\n   *\n   * The added fields are defined using {@link @firebase/firestore/pipelines#Selectable}s, which can be:\n   *\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#Expression}: Either a literal value (see {@link @firebase/firestore/pipelines#(constant:1)}) or a computed value\n   *   with an assigned alias using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .addFields(\n   *     field(\"rating\").as(\"bookRating\"), // Rename 'rating' to 'bookRating'\n   *     add(5, field(\"quantity\")).as(\"totalCost\")  // Calculate 'totalCost'\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  addFields(options: AddFieldsStageOptions): Pipeline;\n  addFields(\n    fieldOrOptions: Selectable | AddFieldsStageOptions,\n    ...additionalFields: Selectable[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    let fields: Selectable[];\n    let options: {};\n    if (isSelectable(fieldOrOptions)) {\n      fields = [fieldOrOptions, ...additionalFields];\n      options = {};\n    } else {\n      ({ fields, ...options } = fieldOrOptions);\n    }\n\n    // Convert user land convenience types to internal types\n    const normalizedFields: Map<string, Expression> = selectablesToMap(fields);\n\n    // Create stage object\n    const stage = new AddFields(normalizedFields, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'addFields'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Remove fields from outputs of previous stages.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection('books')\n   *   // removes field 'rating' and 'cost' from the previous stage outputs.\n   *   .removeFields(\n   *     field('rating'),\n   *     'cost'\n   *   );\n   * ```\n   *\n   * @param fieldValue - The first field to remove.\n   * @param additionalFields - Optional additional fields to remove.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  removeFields(\n    fieldValue: Field | string,\n    ...additionalFields: Array<Field | string>\n  ): Pipeline;\n  /**\n   * @beta\n   * Remove fields from outputs of previous stages.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection('books')\n   *   // removes field 'rating' and 'cost' from the previous stage outputs.\n   *   .removeFields(\n   *     field('rating'),\n   *     'cost'\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  removeFields(options: RemoveFieldsStageOptions): Pipeline;\n  removeFields(\n    fieldValueOrOptions: Field | string | RemoveFieldsStageOptions,\n    ...additionalFields: Array<Field | string>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isField(fieldValueOrOptions) || isString(fieldValueOrOptions)\n        ? {}\n        : fieldValueOrOptions;\n    const fields: Array<Field | string> =\n      isField(fieldValueOrOptions) || isString(fieldValueOrOptions)\n        ? [fieldValueOrOptions, ...additionalFields]\n        : fieldValueOrOptions.fields;\n\n    // Convert user land convenience types to internal types\n    const convertedFields: Field[] = fields.map(f =>\n      isString(f) ? field(f) : (f as Field)\n    );\n\n    // Create stage object\n    const stage = new RemoveFields(convertedFields, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    stage._readUserData(\n      this.userDataReader.createContext(UserDataSource.Argument, 'removeFields')\n    );\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Selects or creates a set of fields from the outputs of previous stages.\n   *\n   * <p>The selected fields are defined using {@link @firebase/firestore/pipelines#Selectable} expressions, which can be:\n   *\n   * <ul>\n   *   <li>`string` : Name of an existing field</li>\n   *   <li>{@link @firebase/firestore/pipelines#Field}: References an existing field.</li>\n   *   <li>{@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name using\n   *       {@link @firebase/firestore/pipelines#Expression.(as:1)}</li>\n   * </ul>\n   *\n   * <p>If no selections are provided, the output of this stage is empty. Use {@link\n   * @firebase/firestore/pipelines#Pipeline.(addFields:1)} instead if only additions are\n   * desired.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * db.pipeline().collection(\"books\")\n   *   .select(\n   *     \"firstName\",\n   *     field(\"lastName\"),\n   *     field(\"address\").toUppercase().as(\"upperAddress\"),\n   *   );\n   * ```\n   *\n   * @param selection - The first field to include in the output documents, specified as {@link\n   *     @firebase/firestore/pipelines#Selectable} expression or string value representing the field name.\n   * @param additionalSelections - Optional additional fields to include in the output documents, specified as {@link\n   *     @firebase/firestore/pipelines#Selectable} expressions or `string` values representing field names.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  select(\n    selection: Selectable | string,\n    ...additionalSelections: Array<Selectable | string>\n  ): Pipeline;\n  /**\n   * @beta\n   * Selects or creates a set of fields from the outputs of previous stages.\n   *\n   * <p>The selected fields are defined using {@link @firebase/firestore/pipelines#Selectable} expressions, which can be:\n   *\n   * <ul>\n   *   <li>`string`: Name of an existing field</li>\n   *   <li>{@link @firebase/firestore/pipelines#Field}: References an existing field.</li>\n   *   <li>{@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name using\n   *       {@link @firebase/firestore/pipelines#Expression.(as:1)}</li>\n   * </ul>\n   *\n   * <p>If no selections are provided, the output of this stage is empty. Use {@link\n   * @firebase/firestore/pipelines#Pipeline.(addFields:1)} instead if only additions are\n   * desired.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * db.pipeline().collection(\"books\")\n   *   .select(\n   *     \"firstName\",\n   *     field(\"lastName\"),\n   *     field(\"address\").toUppercase().as(\"upperAddress\"),\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  select(options: SelectStageOptions): Pipeline;\n  select(\n    selectionOrOptions: Selectable | string | SelectStageOptions,\n    ...additionalSelections: Array<Selectable | string>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isSelectable(selectionOrOptions) || isString(selectionOrOptions)\n        ? {}\n        : selectionOrOptions;\n\n    const selections: Array<Selectable | string> =\n      isSelectable(selectionOrOptions) || isString(selectionOrOptions)\n        ? [selectionOrOptions, ...additionalSelections]\n        : selectionOrOptions.selections;\n\n    // Convert user land convenience types to internal types\n    const normalizedSelections: Map<string, Expression> =\n      selectablesToMap(selections);\n\n    // Create stage object\n    const stage = new Select(normalizedSelections, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'select'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Filters the documents from previous stages to only include those matching the specified {@link\n   * @firebase/firestore/pipelines#BooleanExpression}.\n   *\n   * <p>This stage allows you to apply conditions to the data, similar to a \"WHERE\" clause in SQL.\n   * You can filter documents based on their field values, using implementations of {@link\n   * @firebase/firestore/pipelines#BooleanExpression}, typically including but not limited to:\n   *\n   * <ul>\n   *   <li>field comparators: {@link @firebase/firestore/pipelines#Expression.(equal:1)}, {@link @firebase/firestore/pipelines#Expression.(lessThan:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(greaterThan:1)}, etc.</li>\n   *   <li>logical operators: {@link @firebase/firestore/pipelines#Expression.(and:1)}, {@link @firebase/firestore/pipelines#Expression.(or:1)}, {@link @firebase/firestore/pipelines#Expression.(not:1)}, etc.</li>\n   *   <li>advanced functions: {@link @firebase/firestore/pipelines#Expression.(regexMatch:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(arrayContains:1)}, etc.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .where(\n   *     and(\n   *         gt(field(\"rating\"), 4.0),   // Filter for ratings greater than 4.0\n   *         field(\"genre\").eq(\"Science Fiction\") // Equivalent to gt(\"genre\", \"Science Fiction\")\n   *     )\n   *   );\n   * ```\n   *\n   * @param condition - The {@link @firebase/firestore/pipelines#BooleanExpression} to apply.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  where(condition: BooleanExpression): Pipeline;\n  /**\n   * @beta\n   * Filters the documents from previous stages to only include those matching the specified {@link\n   * @firebase/firestore/pipelines#BooleanExpression}.\n   *\n   * <p>This stage allows you to apply conditions to the data, similar to a \"WHERE\" clause in SQL.\n   * You can filter documents based on their field values, using implementations of {@link\n   * @firebase/firestore/pipelines#BooleanExpression}, typically including but not limited to:\n   *\n   * <ul>\n   *   <li>field comparators: {@link @firebase/firestore/pipelines#Expression.(eq:1)}, {@link @firebase/firestore/pipelines#Expression.(lt:1)} (less than), {@link\n   *       @firebase/firestore/pipelines#Expression.(greaterThan:1)}, etc.</li>\n   *   <li>logical operators: {@link @firebase/firestore/pipelines#Expression.(and:1)}, {@link @firebase/firestore/pipelines#Expression.(or:1)}, {@link @firebase/firestore/pipelines#Expression.(not:1)}, etc.</li>\n   *   <li>advanced functions: {@link @firebase/firestore/pipelines#Expression.(regexMatch:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(arrayContains:1)}, etc.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .where(\n   *     and(\n   *         gt(field(\"rating\"), 4.0),   // Filter for ratings greater than 4.0\n   *         field(\"genre\").eq(\"Science Fiction\") // Equivalent to gt(\"genre\", \"Science Fiction\")\n   *     )\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  where(options: WhereStageOptions): Pipeline;\n  where(conditionOrOptions: BooleanExpression | WhereStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isBooleanExpr(conditionOrOptions) ? {} : conditionOrOptions;\n    const condition: BooleanExpression = isBooleanExpr(conditionOrOptions)\n      ? conditionOrOptions\n      : conditionOrOptions.condition;\n\n    // Create stage object\n    const stage = new Where(condition, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'where'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Skips the first `offset` number of documents from the results of previous stages.\n   *\n   * <p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve\n   * results in chunks. It is typically used in conjunction with {@link @firebase/firestore/pipelines#Pipeline.limit} to control the\n   * size of each page.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page of 20 results\n   * firestore.pipeline().collection('books')\n   *     .sort(field('published').descending())\n   *     .offset(20)  // Skip the first 20 results\n   *     .limit(20);   // Take the next 20 results\n   * ```\n   *\n   * @param offset - The number of documents to skip.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  offset(offset: number): Pipeline;\n  /**\n   * @beta\n   * Skips the first `offset` number of documents from the results of previous stages.\n   *\n   * <p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve\n   * results in chunks. It is typically used in conjunction with {@link @firebase/firestore/pipelines#Pipeline.limit} to control the\n   * size of each page.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page of 20 results\n   * firestore.pipeline().collection('books')\n   *     .sort(field('published').descending())\n   *     .offset(20)  // Skip the first 20 results\n   *     .limit(20);   // Take the next 20 results\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  offset(options: OffsetStageOptions): Pipeline;\n  offset(offsetOrOptions: number | OffsetStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let offset: number;\n    if (isNumber(offsetOrOptions)) {\n      options = {};\n      offset = offsetOrOptions;\n    } else {\n      options = offsetOrOptions;\n      offset = offsetOrOptions.offset;\n    }\n\n    // Create stage object\n    const stage = new Offset(offset, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'offset'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Limits the maximum number of documents returned by previous stages to `limit`.\n   *\n   * <p>This stage is particularly useful when you want to retrieve a controlled subset of data from\n   * a potentially large result set. It's often used for:\n   *\n   * <ul>\n   *   <li>**Pagination:** In combination with {@link @firebase/firestore/pipelines#Pipeline.offset} to retrieve specific pages of\n   *       results.</li>\n   *   <li>**Limiting Data Retrieval:** To prevent excessive data transfer and improve performance,\n   *       especially when dealing with large collections.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Limit the results to the top 10 highest-rated books\n   * firestore.pipeline().collection('books')\n   *     .sort(field('rating').descending())\n   *     .limit(10);\n   * ```\n   *\n   * @param limit - The maximum number of documents to return.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  limit(limit: number): Pipeline;\n  /**\n   * @beta\n   * Limits the maximum number of documents returned by previous stages to `limit`.\n   *\n   * <p>This stage is particularly useful when you want to retrieve a controlled subset of data from\n   * a potentially large result set. It's often used for:\n   *\n   * <ul>\n   *   <li>**Pagination:** In combination with {@link @firebase/firestore/pipelines#Pipeline.offset} to retrieve specific pages of\n   *       results.</li>\n   *   <li>**Limiting Data Retrieval:** To prevent excessive data transfer and improve performance,\n   *       especially when dealing with large collections.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Limit the results to the top 10 highest-rated books\n   * firestore.pipeline().collection('books')\n   *     .sort(field('rating').descending())\n   *     .limit(10);\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  limit(options: LimitStageOptions): Pipeline;\n  limit(limitOrOptions: number | LimitStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isNumber(limitOrOptions) ? {} : limitOrOptions;\n    const limit: number = isNumber(limitOrOptions)\n      ? limitOrOptions\n      : limitOrOptions.limit;\n\n    // Create stage object\n    const stage = new Limit(limit, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'limit'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Returns a set of distinct values from the inputs to this stage.\n   *\n   * This stage runs through the results from previous stages to include only results with\n   * unique combinations of {@link @firebase/firestore/pipelines#Expression} values ({@link @firebase/firestore/pipelines#Field}, {@link @firebase/firestore/pipelines#AliasedExpression}, etc).\n   *\n   * The parameters to this stage are defined using {@link @firebase/firestore/pipelines#Selectable} expressions or strings:\n   *\n   * - `string`: Name of an existing field\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name\n   *   using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Get a list of unique author names in uppercase and genre combinations.\n   * firestore.pipeline().collection(\"books\")\n   *     .distinct(toUppercase(field(\"author\")).as(\"authorName\"), field(\"genre\"), \"publishedAt\")\n   *     .select(\"authorName\");\n   * ```\n   *\n   * @param group - The {@link @firebase/firestore/pipelines#Selectable} expression or field name to consider when determining\n   *     distinct value combinations.\n   * @param additionalGroups - Optional additional {@link @firebase/firestore/pipelines#Selectable} expressions to consider when determining distinct\n   *     value combinations or strings representing field names.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  distinct(\n    group: string | Selectable,\n    ...additionalGroups: Array<string | Selectable>\n  ): Pipeline;\n  /**\n   * @beta\n   * Returns a set of distinct values from the inputs to this stage.\n   *\n   * This stage runs through the results from previous stages to include only results with\n   * unique combinations of {@link @firebase/firestore/pipelines#Expression} values ({@link @firebase/firestore/pipelines#Field}, {@link @firebase/firestore/pipelines#AliasedExpression}, etc).\n   *\n   * The parameters to this stage are defined using {@link @firebase/firestore/pipelines#Selectable} expressions or strings:\n   *\n   * - `string`: Name of an existing field\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name\n   *   using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Get a list of unique author names in uppercase and genre combinations.\n   * firestore.pipeline().collection(\"books\")\n   *     .distinct(toUppercase(field(\"author\")).as(\"authorName\"), field(\"genre\"), \"publishedAt\")\n   *     .select(\"authorName\");\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  distinct(options: DistinctStageOptions): Pipeline;\n  distinct(\n    groupOrOptions: string | Selectable | DistinctStageOptions,\n    ...additionalGroups: Array<string | Selectable>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(groupOrOptions) || isSelectable(groupOrOptions)\n        ? {}\n        : groupOrOptions;\n    const groups: Array<string | Selectable> =\n      isString(groupOrOptions) || isSelectable(groupOrOptions)\n        ? [groupOrOptions, ...additionalGroups]\n        : groupOrOptions.groups;\n\n    // Convert user land convenience types to internal types\n    const convertedGroups: Map<string, Expression> = selectablesToMap(groups);\n\n    // Create stage object\n    const stage = new Distinct(convertedGroups, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'distinct'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs aggregation operations on the documents from previous stages.\n   *\n   * <p>This stage allows you to calculate aggregate values over a set of documents. You define the\n   * aggregations to perform using {@link @firebase/firestore/pipelines#AliasedAggregate} expressions which are typically results of\n   * calling {@link @firebase/firestore/pipelines#Expression.(as:1)} on {@link @firebase/firestore/pipelines#AggregateFunction} instances.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average rating and the total number of books\n   * firestore.pipeline().collection(\"books\")\n   *     .aggregate(\n   *         field(\"rating\").avg().as(\"averageRating\"),\n   *         countAll().as(\"totalBooks\")\n   *     );\n   * ```\n   *\n   * @param accumulator - The first {@link @firebase/firestore/pipelines#AliasedAggregate}, wrapping an {@link @firebase/firestore/pipelines#AggregateFunction}\n   *     and providing a name for the accumulated results.\n   * @param additionalAccumulators - Optional additional {@link @firebase/firestore/pipelines#AliasedAggregate}, each wrapping an {@link @firebase/firestore/pipelines#AggregateFunction}\n   *     and providing a name for the accumulated results.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  aggregate(\n    accumulator: AliasedAggregate,\n    ...additionalAccumulators: AliasedAggregate[]\n  ): Pipeline;\n  /**\n   * @beta\n   * Performs optionally grouped aggregation operations on the documents from previous stages.\n   *\n   * <p>This stage allows you to calculate aggregate values over a set of documents, optionally\n   * grouped by one or more fields or functions. You can specify:\n   *\n   * <ul>\n   *   <li>**Grouping Fields or Functions:** One or more fields or functions to group the documents\n   *       by. For each distinct combination of values in these fields, a separate group is created.\n   *       If no grouping fields are provided, a single group containing all documents is used. Not\n   *       specifying groups is the same as putting the entire inputs into one group.</li>\n   *   <li>**Accumulators:** One or more accumulation operations to perform within each group. These\n   *       are defined using {@link @firebase/firestore/pipelines#AliasedAggregate} expressions, which are typically created by\n   *       calling {@link @firebase/firestore/pipelines#Expression.(as:1)} on {@link @firebase/firestore/pipelines#AggregateFunction} instances. Each aggregation\n   *       calculates a value (e.g., sum, average, count) based on the documents within its group.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average rating for each genre.\n   * firestore.pipeline().collection(\"books\")\n   *   .aggregate({\n   *       accumulators: [avg(field(\"rating\")).as(\"avg_rating\")]\n   *       groups: [\"genre\"]\n   *       });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage\n   * list.\n   */\n  aggregate(options: AggregateStageOptions): Pipeline;\n  aggregate(\n    targetOrOptions: AliasedAggregate | AggregateStageOptions,\n    ...rest: AliasedAggregate[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isAliasedAggregate(targetOrOptions) ? {} : targetOrOptions;\n    const accumulators: AliasedAggregate[] = isAliasedAggregate(targetOrOptions)\n      ? [targetOrOptions, ...rest]\n      : targetOrOptions.accumulators;\n    const groups: Array<Selectable | string> = isAliasedAggregate(\n      targetOrOptions\n    )\n      ? []\n      : targetOrOptions.groups ?? [];\n\n    // Convert user land convenience types to internal types\n    const convertedAccumulators: Map<string, AggregateFunction> =\n      aliasedAggregateToMap(accumulators);\n    const convertedGroups: Map<string, Expression> = selectablesToMap(groups);\n\n    // Create stage object\n    const stage = new Aggregate(\n      convertedGroups,\n      convertedAccumulators,\n      options\n    );\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'aggregate'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs a vector proximity search on the documents from the previous stage, returning the\n   * K-nearest documents based on the specified query `vectorValue` and `distanceMeasure`. The\n   * returned documents will be sorted in order from nearest to furthest from the query `vectorValue`.\n   *\n   * <p>Example:\n   *\n   * ```typescript\n   * // Find the 10 most similar books based on the book description.\n   * const bookDescription = \"Lorem ipsum...\";\n   * const queryVector: number[] = ...; // compute embedding of `bookDescription`\n   *\n   * firestore.pipeline().collection(\"books\")\n   *     .findNearest({\n   *       field: 'embedding',\n   *       vectorValue: queryVector,\n   *       distanceMeasure: 'euclidean',\n   *       limit: 10,                        // optional\n   *       distanceField: 'computedDistance' // optional\n   *     });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  findNearest(options: FindNearestStageOptions): Pipeline {\n    // Convert user land convenience types to internal types\n    const field = toField(options.field);\n    const vectorValue = vectorToExpr(options.vectorValue);\n    const distanceField = options.distanceField\n      ? toField(options.distanceField)\n      : undefined;\n    const internalOptions = {\n      distanceField,\n      limit: options.limit,\n      rawOptions: options.rawOptions\n    };\n\n    // Create stage object\n    const stage = new FindNearest(\n      vectorValue,\n      field,\n      options.distanceMeasure,\n      internalOptions\n    );\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'addFields'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Sorts the documents from previous stages based on one or more {@link @firebase/firestore/pipelines#Ordering} criteria.\n   *\n   * <p>This stage allows you to order the results of your pipeline. You can specify multiple {@link\n   * @firebase/firestore/pipelines#Ordering} instances to sort by multiple fields in ascending or descending order. If documents\n   * have the same value for a field used for sorting, the next specified ordering will be used. If\n   * all orderings result in equal comparison, the documents are considered equal and the order is\n   * unspecified.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Sort books by rating in descending order, and then by title in ascending order for books\n   * // with the same rating\n   * firestore.pipeline().collection(\"books\")\n   *     .sort(\n   *         Ordering.of(field(\"rating\")).descending(),\n   *         Ordering.of(field(\"title\"))  // Ascending order is the default\n   *     );\n   * ```\n   *\n   * @param ordering - The first {@link @firebase/firestore/pipelines#Ordering} instance specifying the sorting criteria.\n   * @param additionalOrderings - Optional additional {@link @firebase/firestore/pipelines#Ordering} instances specifying the additional sorting criteria.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sort(ordering: Ordering, ...additionalOrderings: Ordering[]): Pipeline;\n  /**\n   * @beta\n   * Sorts the documents from previous stages based on one or more {@link @firebase/firestore/pipelines#Ordering} criteria.\n   *\n   * <p>This stage allows you to order the results of your pipeline. You can specify multiple {@link\n   * @firebase/firestore/pipelines#Ordering} instances to sort by multiple fields in ascending or descending order. If documents\n   * have the same value for a field used for sorting, the next specified ordering will be used. If\n   * all orderings result in equal comparison, the documents are considered equal and the order is\n   * unspecified.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Sort books by rating in descending order, and then by title in ascending order for books\n   * // with the same rating\n   * firestore.pipeline().collection(\"books\")\n   *     .sort(\n   *         Ordering.of(field(\"rating\")).descending(),\n   *         Ordering.of(field(\"title\"))  // Ascending order is the default\n   *     );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sort(options: SortStageOptions): Pipeline;\n  sort(\n    orderingOrOptions: Ordering | SortStageOptions,\n    ...additionalOrderings: Ordering[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isOrdering(orderingOrOptions) ? {} : orderingOrOptions;\n    const orderings: Ordering[] = isOrdering(orderingOrOptions)\n      ? [orderingOrOptions, ...additionalOrderings]\n      : orderingOrOptions.orderings;\n\n    // Create stage object\n    const stage = new Sort(orderings, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'sort'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a nested map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith('parents');\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param fieldName - The {@link @firebase/firestore/pipelines#Field} field containing the nested map.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(fieldName: string): Pipeline;\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith(map({\n   *   foo: 'bar',\n   *   info: {\n   *     name: field('name')\n   *   }\n   * }));\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param expr - An {@link @firebase/firestore/pipelines#Expression} that when returned evaluates to a map.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(expr: Expression): Pipeline;\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith(map({\n   *   foo: 'bar',\n   *   info: {\n   *     name: field('name')\n   *   }\n   * }));\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(options: ReplaceWithStageOptions): Pipeline;\n  replaceWith(\n    valueOrOptions: Expression | string | ReplaceWithStageOptions\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(valueOrOptions) || isExpr(valueOrOptions) ? {} : valueOrOptions;\n    const fieldNameOrExpr: string | Expression =\n      isString(valueOrOptions) || isExpr(valueOrOptions)\n        ? valueOrOptions\n        : valueOrOptions.map;\n\n    // Convert user land convenience types to internal types\n    const mapExpr = fieldOrExpression(fieldNameOrExpr);\n\n    // Create stage object\n    const stage = new Replace(mapExpr, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'replaceWith'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs a pseudo-random sampling of the documents from the previous stage.\n   *\n   * <p>This stage will filter documents pseudo-randomly. The parameter specifies how number of\n   * documents to be returned.\n   *\n   * <p>Examples:\n   *\n   * @example\n   * ```typescript\n   * // Sample 25 books, if available.\n   * firestore.pipeline().collection('books')\n   *     .sample(25);\n   * ```\n   *\n   * @param documents - The number of documents to sample.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sample(documents: number): Pipeline;\n\n  /**\n   * @beta\n   * Performs a pseudo-random sampling of the documents from the previous stage.\n   *\n   * <p>This stage will filter documents pseudo-randomly. The 'options' parameter specifies how\n   * sampling will be performed. See {@link @firebase/firestore/pipelines#SampleStageOptions} for more information.\n   *\n   * @example\n   * ```typescript\n   * // Sample 10 books, if available.\n   * firestore.pipeline().collection(\"books\")\n   *     .sample({ documents: 10 });\n   *\n   * // Sample 50% of books.\n   * firestore.pipeline().collection(\"books\")\n   *     .sample({ percentage: 0.5 });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sample(options: SampleStageOptions): Pipeline;\n  sample(documentsOrOptions: number | SampleStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isNumber(documentsOrOptions) ? {} : documentsOrOptions;\n    let rate: number;\n    let mode: 'documents' | 'percent';\n    if (isNumber(documentsOrOptions)) {\n      rate = documentsOrOptions;\n      mode = 'documents';\n    } else if (isNumber(documentsOrOptions.documents)) {\n      rate = documentsOrOptions.documents;\n      mode = 'documents';\n    } else {\n      rate = documentsOrOptions.percentage!;\n      mode = 'percent';\n    }\n\n    // Create stage object\n    const stage = new Sample(rate, mode, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'sample'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs union of all documents from two pipelines, including duplicates.\n   *\n   * <p>This stage will pass through documents from previous stage, and also pass through documents\n   * from previous stage of the `other` {@link @firebase/firestore/pipelines#Pipeline} given in parameter. The order of documents\n   * emitted from this stage is undefined.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Emit documents from books collection and magazines collection.\n   * firestore.pipeline().collection('books')\n   *     .union(firestore.pipeline().collection('magazines'));\n   * ```\n   *\n   * @param other - The other {@link @firebase/firestore/pipelines#Pipeline} that is part of union.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  union(other: Pipeline): Pipeline;\n  /**\n   * @beta\n   * Performs union of all documents from two pipelines, including duplicates.\n   *\n   * <p>This stage will pass through documents from previous stage, and also pass through documents\n   * from previous stage of the `other` {@link @firebase/firestore/pipelines#Pipeline} given in parameter. The order of documents\n   * emitted from this stage is undefined.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Emit documents from books collection and magazines collection.\n   * firestore.pipeline().collection('books')\n   *     .union(firestore.pipeline().collection('magazines'));\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  union(options: UnionStageOptions): Pipeline;\n  union(otherOrOptions: Pipeline | UnionStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let otherPipeline: Pipeline;\n    if (isPipeline(otherOrOptions)) {\n      options = {};\n      otherPipeline = otherOrOptions;\n    } else {\n      ({ other: otherPipeline, ...options } = otherOrOptions);\n    }\n\n    // Create stage object\n    const stage = new Union(otherPipeline, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'union'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Produces a document for each element in an input array.\n   *\n   * For each previous stage document, this stage will emit zero or more augmented documents. The\n   * input array specified by the `selectable` parameter, will emit an augmented document for each input array element. The input array element will\n   * augment the previous stage document by setting the `alias` field  with the array element value.\n   *\n   * When `selectable` evaluates to a non-array value (ex: number, null, absent), then the stage becomes a no-op for\n   * the current input document, returning it as is with the `alias` field absent.\n   *\n   * No documents are emitted when `selectable` evaluates to an empty array.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Input:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tags\": [ \"comedy\", \"space\", \"adventure\" ], ... }\n   *\n   * // Emit a book document for each tag of the book.\n   * firestore.pipeline().collection(\"books\")\n   *     .unnest(field(\"tags\").as('tag'), 'tagIndex');\n   *\n   * // Output:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"comedy\", \"tagIndex\": 0, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"space\", \"tagIndex\": 1, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"adventure\", \"tagIndex\": 2, ... }\n   * ```\n   *\n   * @param selectable - A selectable expression defining the field to unnest and the alias to use for each un-nested element in the output documents.\n   * @param indexField - An optional string value specifying the field path to write the offset (starting at zero) into the array the un-nested element is from\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  unnest(selectable: Selectable, indexField?: string): Pipeline;\n  /**\n   * @beta\n   * Produces a document for each element in an input array.\n   *\n   * For each previous stage document, this stage will emit zero or more augmented documents. The\n   * input array specified by the `selectable` parameter, will emit an augmented document for each input array element. The input array element will\n   * augment the previous stage document by setting the `alias` field  with the array element value.\n   *\n   * When `selectable` evaluates to a non-array value (ex: number, null, absent), then the stage becomes a no-op for\n   * the current input document, returning it as is with the `alias` field absent.\n   *\n   * No documents are emitted when `selectable` evaluates to an empty array.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Input:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tags\": [ \"comedy\", \"space\", \"adventure\" ], ... }\n   *\n   * // Emit a book document for each tag of the book.\n   * firestore.pipeline().collection(\"books\")\n   *     .unnest(field(\"tags\").as('tag'), 'tagIndex');\n   *\n   * // Output:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"comedy\", \"tagIndex\": 0, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"space\", \"tagIndex\": 1, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"adventure\", \"tagIndex\": 2, ... }\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  unnest(options: UnnestStageOptions): Pipeline;\n  unnest(\n    selectableOrOptions: Selectable | UnnestStageOptions,\n    indexField?: string\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: { indexField?: Field } & StageOptions;\n    let selectable: Selectable;\n    let indexFieldName: string | undefined;\n    if (isSelectable(selectableOrOptions)) {\n      options = {};\n      selectable = selectableOrOptions;\n      indexFieldName = indexField;\n    } else {\n      ({\n        selectable,\n        indexField: indexFieldName,\n        ...options\n      } = selectableOrOptions);\n    }\n\n    // Convert user land convenience types to internal types\n    const alias = selectable.alias;\n    const expr = selectable.expr as Expression;\n    if (isString(indexFieldName)) {\n      options.indexField = _field(indexFieldName, 'unnest');\n    }\n\n    // Create stage object\n    const stage = new Unnest(alias, expr, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'unnest'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Adds a raw stage to the pipeline.\n   *\n   * <p>This method provides a flexible way to extend the pipeline's functionality by adding custom\n   * stages. Each raw stage is defined by a unique `name` and a set of `params` that control its\n   * behavior.\n   *\n   * <p>Example (Assuming there is no 'where' stage available in SDK):\n   *\n   * @example\n   * ```typescript\n   * // Assume we don't have a built-in 'where' stage\n   * firestore.pipeline().collection('books')\n   *     .rawStage('where', [field('published').lt(1900)]) // Custom 'where' stage\n   *     .select('title', 'author');\n   * ```\n   *\n   * @param name - The unique name of the raw stage to add.\n   * @param params - A list of parameters to configure the raw stage's behavior.\n   * @param options - An object of key value pairs that specifies optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  rawStage(\n    name: string,\n    params: unknown[],\n    options?: { [key: string]: Expression | unknown }\n  ): Pipeline {\n    // Convert user land convenience types to internal types\n    const expressionParams = params.map((value: unknown) => {\n      if (value instanceof Expression) {\n        return value;\n      } else if (value instanceof AggregateFunction) {\n        return value;\n      } else if (isPlainObject(value)) {\n        return _mapValue(value as Record<string, unknown>);\n      } else {\n        return _constant(value, 'rawStage');\n      }\n    });\n\n    // Create stage object\n    const stage = new RawStage(name, expressionParams, options ?? {});\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'rawStage'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(jsonProtoSerializer: JsonProtoSerializer): ProtoPipeline {\n    const stages: ProtoStage[] = this.stages.map(stage =>\n      stage._toProto(jsonProtoSerializer)\n    );\n    return { stages };\n  }\n\n  private _addStage(stage: Stage): Pipeline {\n    const copy = this.stages.map(s => s);\n    copy.push(stage);\n    return this.newPipeline(\n      this._db,\n      this.userDataReader,\n      this._userDataWriter,\n      copy\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   * @param db\n   * @param userDataReader\n   * @param userDataWriter\n   * @param stages\n   * @protected\n   */\n  protected newPipeline(\n    db: Firestore,\n    userDataReader: UserDataReader,\n    userDataWriter: AbstractUserDataWriter,\n    stages: Stage[]\n  ): Pipeline {\n    return new Pipeline(db, userDataReader, userDataWriter, stages);\n  }\n}\n\nexport function isPipeline(val: unknown): val is Pipeline {\n  return val instanceof Pipeline;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Pipeline as LitePipeline } from '../lite-api/pipeline';\nimport { Stage } from '../lite-api/stage';\nimport { UserDataReader } from '../lite-api/user_data_reader';\nimport { AbstractUserDataWriter } from '../lite-api/user_data_writer';\n\nimport { Firestore } from './database';\n\n/**\n * @beta\n */\nexport class Pipeline extends LitePipeline {\n  /**\n   * @internal\n   * @private\n   * @param db\n   * @param userDataReader\n   * @param userDataWriter\n   * @param stages\n   * @param converter\n   * @protected\n   */\n  protected newPipeline(\n    db: Firestore,\n    userDataReader: UserDataReader,\n    userDataWriter: AbstractUserDataWriter,\n    stages: Stage[]\n  ): Pipeline {\n    return new Pipeline(db, userDataReader, userDataWriter, stages);\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Pipeline } from '../api/pipeline';\nimport { firestoreClientExecutePipeline } from '../core/firestore_client';\nimport {\n  StructuredPipeline,\n  StructuredPipelineOptions\n} from '../core/structured_pipeline';\nimport { Pipeline as LitePipeline } from '../lite-api/pipeline';\nimport { PipelineResult, PipelineSnapshot } from '../lite-api/pipeline-result';\nimport { PipelineSource } from '../lite-api/pipeline-source';\nimport { PipelineExecuteOptions } from '../lite-api/pipeline_options';\nimport { Stage } from '../lite-api/stage';\nimport {\n  newUserDataReader,\n  UserDataReader,\n  UserDataSource\n} from '../lite-api/user_data_reader';\nimport { cast } from '../util/input_validation';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport { DocumentReference } from './reference';\nimport { ExpUserDataWriter } from './user_data_writer';\n\ndeclare module './database' {\n  /**\n   * @beta\n   * Creates and returns a new PipelineSource, which allows specifying the source stage of a {@link @firebase/firestore/pipelines#Pipeline}.\n   *\n   * @example\n   * ```\n   * let myPipeline: Pipeline = firestore.pipeline().collection('books');\n   * ```\n   */\n  interface Firestore {\n    pipeline(): PipelineSource<Pipeline>;\n  }\n}\n\n/**\n * @beta\n * Executes a pipeline and returns a Promise to represent the asynchronous operation.\n *\n * The returned Promise can be used to track the progress of the pipeline execution\n * and retrieve the results (or handle any errors) asynchronously.\n *\n * The pipeline results are returned as a {@link @firebase/firestore/pipelines#PipelineSnapshot} that contains\n * a list of {@link @firebase/firestore/pipelines#PipelineResult} objects. Each {@link @firebase/firestore/pipelines#PipelineResult} typically\n * represents a single key/value map that has passed through all the\n * stages of the pipeline, however this might differ depending on the stages involved in the\n * pipeline. For example:\n *\n * <ul>\n *   <li>If there are no stages or only transformation stages, each {@link @firebase/firestore/pipelines#PipelineResult}\n *       represents a single document.</li>\n *   <li>If there is an aggregation, only a single {@link @firebase/firestore/pipelines#PipelineResult} is returned,\n *       representing the aggregated results over the entire dataset .</li>\n *   <li>If there is an aggregation stage with grouping, each {@link @firebase/firestore/pipelines#PipelineResult} represents a\n *       distinct group and its associated aggregated values.</li>\n * </ul>\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await execute(firestore.pipeline().collection(\"books\")\n *     .where(gt(field(\"rating\"), 4.5))\n *     .select(\"title\", \"author\", \"rating\"));\n *\n * const results: PipelineResults = snapshot.results;\n * ```\n *\n * @param pipeline - The pipeline to execute.\n * @returns A Promise representing the asynchronous pipeline execution.\n */\nexport function execute(pipeline: LitePipeline): Promise<PipelineSnapshot>;\n/**\n * @beta\n * Executes a pipeline and returns a Promise to represent the asynchronous operation.\n *\n * The returned Promise can be used to track the progress of the pipeline execution\n * and retrieve the results (or handle any errors) asynchronously.\n *\n * The pipeline results are returned as a {@link @firebase/firestore/pipelines#PipelineSnapshot} that contains\n * a list of {@link @firebase/firestore/pipelines#PipelineResult} objects. Each {@link @firebase/firestore/pipelines#PipelineResult} typically\n * represents a single key/value map that has passed through all the\n * stages of the pipeline, however this might differ depending on the stages involved in the\n * pipeline. For example:\n *\n * <ul>\n *   <li>If there are no stages or only transformation stages, each {@link @firebase/firestore/pipelines#PipelineResult}\n *       represents a single document.</li>\n *   <li>If there is an aggregation, only a single {@link @firebase/firestore/pipelines#PipelineResult} is returned,\n *       representing the aggregated results over the entire dataset .</li>\n *   <li>If there is an aggregation stage with grouping, each {@link @firebase/firestore/pipelines#PipelineResult} represents a\n *       distinct group and its associated aggregated values.</li>\n * </ul>\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await execute(firestore.pipeline().collection(\"books\")\n *     .where(gt(field(\"rating\"), 4.5))\n *     .select(\"title\", \"author\", \"rating\"));\n *\n * const results: PipelineResults = snapshot.results;\n * ```\n *\n * @param options - Specifies the pipeline to execute and other options for execute.\n * @returns A Promise representing the asynchronous pipeline execution.\n */\nexport function execute(\n  options: PipelineExecuteOptions\n): Promise<PipelineSnapshot>;\nexport function execute(\n  pipelineOrOptions: LitePipeline | PipelineExecuteOptions\n): Promise<PipelineSnapshot> {\n  const options: PipelineExecuteOptions = !(\n    pipelineOrOptions instanceof LitePipeline\n  )\n    ? pipelineOrOptions\n    : {\n        pipeline: pipelineOrOptions\n      };\n\n  const { pipeline, rawOptions, ...rest } = options;\n\n  const firestore = cast(pipeline._db, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n\n  const udr = new UserDataReader(\n    firestore._databaseId,\n    /* ignoreUndefinedProperties */ true\n  );\n  const context = udr.createContext(UserDataSource.Argument, 'execute');\n\n  const structuredPipelineOptions = new StructuredPipelineOptions(\n    rest,\n    rawOptions\n  );\n  structuredPipelineOptions._readUserData(context);\n\n  const structuredPipeline: StructuredPipeline = new StructuredPipeline(\n    pipeline,\n    structuredPipelineOptions\n  );\n\n  return firestoreClientExecutePipeline(client, structuredPipeline).then(\n    result => {\n      // Get the execution time from the first result.\n      // firestoreClientExecutePipeline returns at least one PipelineStreamElement\n      // even if the returned document set is empty.\n      const executionTime =\n        result.length > 0 ? result[0].executionTime?.toTimestamp() : undefined;\n\n      const docs = result\n        // Currently ignore any response from ExecutePipeline that does\n        // not contain any document data in the `fields` property.\n        .filter(element => !!element.fields)\n        .map(\n          element =>\n            new PipelineResult(\n              pipeline._userDataWriter,\n              element.fields!,\n              element.key?.path\n                ? new DocumentReference(firestore, null, element.key)\n                : undefined,\n              element.createTime?.toTimestamp(),\n              element.updateTime?.toTimestamp()\n            )\n        );\n\n      return new PipelineSnapshot(pipeline, docs, executionTime);\n    }\n  );\n}\n\n/**\n * @beta\n * Creates and returns a new PipelineSource, which allows specifying the source stage of a {@link @firebase/firestore/pipelines#Pipeline}.\n *\n * @example\n * ```\n * let myPipeline: Pipeline = firestore.pipeline().collection('books');\n * ```\n */\n// Augment the Firestore class with the pipeline() factory method\nFirestore.prototype.pipeline = function (): PipelineSource<Pipeline> {\n  const userDataReader = newUserDataReader(this);\n  return new PipelineSource<Pipeline>(\n    this._databaseId,\n    userDataReader,\n    (stages: Stage[]) => {\n      return new Pipeline(\n        this,\n        userDataReader,\n        new ExpUserDataWriter(this),\n        stages\n      );\n    }\n  );\n};\n"],"names":["__PRIVATE_isFirestoreValue","obj","nullValue","booleanValue","integerValue","doubleValue","timestampValue","__PRIVATE_isITimestamp","seconds","nanos","stringValue","bytesValue","Uint8Array","referenceValue","geoPointValue","__PRIVATE_isILatLng","latitude","longitude","arrayValue","__PRIVATE_isIArrayValue","values","Array","isArray","mapValue","__PRIVATE_isIMapValue","fields","__PRIVATE_isPlainObject","fieldReferenceValue","functionValue","__PRIVATE_isIFunction","name","args","pipelineValue","__PRIVATE_isIPipeline","stages","__PRIVATE_valueToDefaultExpr","value","result","Expression","__PRIVATE__map","array","__PRIVATE__constant","undefined","__PRIVATE_vectorToExpr","VectorValue","constant","vector","Error","__PRIVATE_fieldOrExpression","__PRIVATE_isString","field","constructor","this","_protoValueType","add","second","FunctionExpression","asBoolean","BooleanExpression","Constant","__PRIVATE_BooleanConstant","Field","__PRIVATE_BooleanField","__PRIVATE_BooleanFunctionExpression","FirestoreError","subtract","subtrahend","multiply","divide","divisor","mod","other","equal","notEqual","lessThan","lessThanOrEqual","greaterThan","greaterThanOrEqual","arrayConcat","secondArray","otherArrays","__PRIVATE_exprValues","map","arrayContains","element","arrayContainsAll","__PRIVATE_normalizedExpr","__PRIVATE_ListOfExprs","arrayContainsAny","arrayReverse","arrayLength","equalAny","others","__PRIVATE_exprOthers","notEqualAny","exists","charLength","like","__PRIVATE_stringOrExpr","regexContains","regexMatch","stringContains","startsWith","endsWith","toLower","toUpper","trim","valueToTrim","push","stringConcat","secondString","otherStrings","__PRIVATE_exprs","concat","reverse","byteLength","ceil","floor","abs","exp","mapGet","subfield","count","AggregateFunction","_create","sum","average","minimum","maximum","countDistinct","logicalMaximum","logicalMinimum","vectorLength","cosineDistance","dotProduct","euclideanDistance","unixMicrosToTimestamp","timestampToUnixMicros","unixMillisToTimestamp","timestampToUnixMillis","unixSecondsToTimestamp","timestampToUnixSeconds","timestampAdd","unit","amount","timestampSubtract","documentId","substring","position","length","__PRIVATE_positionExpr","arrayGet","offset","isError","ifError","catchValue","isAbsent","mapRemove","__PRIVATE_stringExpr","mapMerge","secondMap","otherMaps","__PRIVATE_secondMapExpr","__PRIVATE_otherMapExprs","pow","exponent","round","decimalPlaces","collectionId","ln","sqrt","stringReverse","ifAbsent","__PRIVATE_elseValueOrExpression","join","__PRIVATE_delimeterValueOrExpression","log10","arraySum","split","delimiter","timestampTruncate","granularity","timezone","toLowerCase","type","ascending","descending","as","AliasedExpression","params","exprType","methodName","__PRIVATE_af","_methodName","AliasedAggregate","_toProto","serializer","p","_readUserData","context","contextWith","forEach","expr","aggregate","alias","selectable","super","expressionType","fieldPath","fieldName","canonicalString","nameOrPath","_field","__PRIVATE_DOCUMENT_KEY_NAME","__PRIVATE_documentIdFieldPath","_internalPath","__PRIVATE_fieldPathFromArgument","_fromProto","_protoValue","_","__PRIVATE_hardAssert","__PRIVATE_parseData","c","MapValue","__PRIVATE_plainObject","__PRIVATE_toMapValue","_expr","countIf","not","conditional","thenExpr","elseExpr","__PRIVATE_normalizedCatchValue","booleanExpr","tryExpr","mapExpr","firstMap","documentPath","__PRIVATE_fieldExpr","__PRIVATE_lengthExpr","first","left","right","__PRIVATE_normalizedLeft","__PRIVATE_normalizedRight","elements","key","Object","prototype","hasOwnProperty","call","__PRIVATE__array","__PRIVATE_leftExpr","__PRIVATE_rightExpr","firstArray","__PRIVATE_arrayExpr","__PRIVATE_elementExpr","xor","additionalConditions","condition","__PRIVATE_valueOrField","__PRIVATE_expressionOrFieldName","pattern","__PRIVATE_patternExpr","__PRIVATE_substringExpr","prefix","suffix","__PRIVATE_fieldOrExpr","subField","countAll","__PRIVATE_expr1","__PRIVATE_expr2","timestamp","__PRIVATE_normalizedTimestamp","__PRIVATE_normalizedUnit","__PRIVATE_normalizedAmount","currentTimestamp","and","more","or","base","log","__PRIVATE_fieldNameOrExpression","elseValue","__PRIVATE_delimiterValueOrExpression","__PRIVATE_internalGranularity","Ordering","direction","__PRIVATE_toStringValue","expression","__PRIVATE_isSelectable","val","candidate","__PRIVATE_isExpr","__PRIVATE_isOrdering","__PRIVATE_isAliasedAggregate","__PRIVATE_isBooleanExpr","__PRIVATE_isField","__PRIVATE_toField","__PRIVATE_toPipelineBooleanExpr","f","__PRIVATE_FieldFilterInternal","fieldValue","toString","op","fail","__PRIVATE_CompositeFilterInternal","__PRIVATE_conditions","getFilters","slice","__PRIVATE_toPipeline","query","db","pipeline","__PRIVATE_isCollectionGroupQuery","collectionGroup","__PRIVATE_isDocumentQuery","documents","doc","path","collection","filter","filters","where","__PRIVATE_orders","__PRIVATE_queryNormalizedOrderBy","__PRIVATE_existsConditions","order","orderings","dir","limitType","__PRIVATE_actualOrderings","__PRIVATE_reverseOrderings","o","sort","startAt","__PRIVATE_whereConditionsFromCursor","endAt","limit","bound","__PRIVATE_filterFunc","__PRIVATE_cursors","size","inclusive","__PRIVATE_i","Stage","options","optionsProto","rawOptions","knownOptions","_optionsUtil","getOptionsProto","_name","__PRIVATE_AddFields","OptionsUtil","__PRIVATE_readUserDataHelper","__PRIVATE_RemoveFields","__PRIVATE_Aggregate","groups","accumulators","__PRIVATE_Distinct","__PRIVATE_CollectionSource","forceIndex","serverName","__PRIVATE_formattedCollectionPath","__PRIVATE_CollectionGroupSource","__PRIVATE_DatabaseSource","__PRIVATE_DocumentsSource","__PRIVATE_docPaths","__PRIVATE_formattedPaths","__PRIVATE_Where","__PRIVATE_FindNearest","distanceField","vectorValue","distanceMeasure","__PRIVATE_Limit","isNaN","Infinity","toNumber","__PRIVATE_Offset","__PRIVATE_Select","selections","__PRIVATE_Sort","__PRIVATE_Sample","rate","mode","__PRIVATE_Union","__PRIVATE_toPipelineValue","__PRIVATE_Unnest","indexField","__PRIVATE_Replace","__PRIVATE_MODE","__PRIVATE_RawStage","__PRIVATE_expressionMap","__PRIVATE_isUserData","__PRIVATE_readableData","PipelineSource","databaseId","userDataReader","_createPipeline","__PRIVATE_collectionOrOptions","__PRIVATE_isCollectionReference","__PRIVATE_collectionRefOrString","_validateReference","__PRIVATE_normalizedCollection","__PRIVATE_stage","__PRIVATE_parseContext","createContext","__PRIVATE_collectionIdOrOptions","database","__PRIVATE_docsOrOptions","docs","v","DocumentReference","__PRIVATE_dr","__PRIVATE_normalizedDocs","createFrom","_query","firestore","reference","__PRIVATE_refDbId","_databaseId","isEqual","Code","INVALID_ARGUMENT","CollectionReference","projectId","PipelineSnapshot","results","executionTime","_pipeline","_executionTime","_results","PipelineResult","userDataWriter","ref","createTime","updateTime","_ref","_userDataWriter","_createTime","_updateTime","_fields","id","data","convertValue","_fieldsProto","clone","get","pipelineResultEqual","__PRIVATE_isOptionalEqual","refEqual","l","r","__PRIVATE_selectablesToMap","__PRIVATE_selectables","Map","set","Pipeline","_db","addFields","__PRIVATE_fieldOrOptions","additionalFields","__PRIVATE_normalizedFields","_addStage","removeFields","__PRIVATE_fieldValueOrOptions","__PRIVATE_convertedFields","select","__PRIVATE_selectionOrOptions","additionalSelections","__PRIVATE_normalizedSelections","__PRIVATE_conditionOrOptions","__PRIVATE_offsetOrOptions","__PRIVATE_isNumber","__PRIVATE_limitOrOptions","distinct","__PRIVATE_groupOrOptions","additionalGroups","__PRIVATE_convertedGroups","__PRIVATE_targetOrOptions","__PRIVATE_rest","__PRIVATE_convertedAccumulators","__PRIVATE_aliasedAggregateToMap","__PRIVATE_aliasedAggregatees","reduce","findNearest","__PRIVATE_internalOptions","__PRIVATE_orderingOrOptions","additionalOrderings","replaceWith","__PRIVATE_valueOrOptions","sample","__PRIVATE_documentsOrOptions","percentage","union","__PRIVATE_otherOrOptions","__PRIVATE_otherPipeline","__PRIVATE_isPipeline","unnest","__PRIVATE_selectableOrOptions","__PRIVATE_indexFieldName","rawStage","__PRIVATE_expressionParams","__PRIVATE__mapValue","jsonProtoSerializer","copy","s","newPipeline","__PRIVATE_LitePipeline","execute","__PRIVATE_pipelineOrOptions","__PRIVATE_cast","Firestore","__PRIVATE_client","ensureFirestoreConfigured","UserDataReader","__PRIVATE_structuredPipelineOptions","__PRIVATE_StructuredPipelineOptions","structuredPipeline","StructuredPipeline","__PRIVATE_firestoreClientExecutePipeline","then","toTimestamp","__PRIVATE_newUserDataReader","__PRIVATE_ExpUserDataWriter"],"mappings":"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"}