{"version":3,"file":"pipelines.rn.js","sources":["../src/util/proto.ts","../src/lite-api/expressions.ts","../src/core/pipeline-util.ts","../src/lite-api/stage.ts","../src/lite-api/pipeline-source.ts","../src/lite-api/pipeline-result.ts","../src/util/pipeline_util.ts","../src/lite-api/pipeline.ts","../src/api/pipeline.ts","../src/api/pipeline_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ArrayValue as ProtoArrayValue,\n  Function as ProtoFunction,\n  LatLng as ProtoLatLng,\n  MapValue as ProtoMapValue,\n  Pipeline as ProtoPipeline,\n  Timestamp as ProtoTimestamp,\n  Value as ProtoValue\n} from '../protos/firestore_proto_api';\n\nimport { isPlainObject } from './input_validation';\n\n/* eslint @typescript-eslint/no-explicit-any: 0 */\n\nfunction isITimestamp(obj: any): obj is ProtoTimestamp {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'seconds' in obj &&\n    (obj.seconds === null ||\n      typeof obj.seconds === 'number' ||\n      typeof obj.seconds === 'string') &&\n    'nanos' in obj &&\n    (obj.nanos === null || typeof obj.nanos === 'number')\n  ) {\n    return true;\n  }\n\n  return false;\n}\nfunction isILatLng(obj: any): obj is ProtoLatLng {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'latitude' in obj &&\n    (obj.latitude === null || typeof obj.latitude === 'number') &&\n    'longitude' in obj &&\n    (obj.longitude === null || typeof obj.longitude === 'number')\n  ) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIArrayValue(obj: any): obj is ProtoArrayValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('values' in obj && (obj.values === null || Array.isArray(obj.values))) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIMapValue(obj: any): obj is ProtoMapValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('fields' in obj && (obj.fields === null || isPlainObject(obj.fields))) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIFunction(obj: any): obj is ProtoFunction {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'name' in obj &&\n    (obj.name === null || typeof obj.name === 'string') &&\n    'args' in obj &&\n    (obj.args === null || Array.isArray(obj.args))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isIPipeline(obj: any): obj is ProtoPipeline {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('stages' in obj && (obj.stages === null || Array.isArray(obj.stages))) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isFirestoreValue(obj: any): obj is ProtoValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n\n  // Check optional properties and their types\n  if (\n    ('nullValue' in obj &&\n      (obj.nullValue === null || obj.nullValue === 'NULL_VALUE')) ||\n    ('booleanValue' in obj &&\n      (obj.booleanValue === null || typeof obj.booleanValue === 'boolean')) ||\n    ('integerValue' in obj &&\n      (obj.integerValue === null ||\n        typeof obj.integerValue === 'number' ||\n        typeof obj.integerValue === 'string')) ||\n    ('doubleValue' in obj &&\n      (obj.doubleValue === null || typeof obj.doubleValue === 'number')) ||\n    ('timestampValue' in obj &&\n      (obj.timestampValue === null || isITimestamp(obj.timestampValue))) ||\n    ('stringValue' in obj &&\n      (obj.stringValue === null || typeof obj.stringValue === 'string')) ||\n    ('bytesValue' in obj &&\n      (obj.bytesValue === null || obj.bytesValue instanceof Uint8Array)) ||\n    ('referenceValue' in obj &&\n      (obj.referenceValue === null ||\n        typeof obj.referenceValue === 'string')) ||\n    ('geoPointValue' in obj &&\n      (obj.geoPointValue === null || isILatLng(obj.geoPointValue))) ||\n    ('arrayValue' in obj &&\n      (obj.arrayValue === null || isIArrayValue(obj.arrayValue))) ||\n    ('mapValue' in obj &&\n      (obj.mapValue === null || isIMapValue(obj.mapValue))) ||\n    ('fieldReferenceValue' in obj &&\n      (obj.fieldReferenceValue === null ||\n        typeof obj.fieldReferenceValue === 'string')) ||\n    ('functionValue' in obj &&\n      (obj.functionValue === null || isIFunction(obj.functionValue))) ||\n    ('pipelineValue' in obj &&\n      (obj.pipelineValue === null || isIPipeline(obj.pipelineValue)))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirestoreError } from '../api';\nimport { ParseContext } from '../api/parse_context';\nimport {\n  DOCUMENT_KEY_NAME,\n  FieldPath as InternalFieldPath\n} from '../model/path';\nimport { Value as ProtoValue } from '../protos/firestore_proto_api';\nimport {\n  JsonProtoSerializer,\n  ProtoValueSerializable,\n  toMapValue,\n  toStringValue\n} from '../remote/serializer';\nimport { hardAssert } from '../util/assert';\nimport { isPlainObject } from '../util/input_validation';\nimport { isFirestoreValue } from '../util/proto';\nimport { isString } from '../util/types';\n\nimport { Bytes } from './bytes';\nimport { documentId as documentIdFieldPath, FieldPath } from './field_path';\nimport { vector } from './field_value_impl';\nimport { GeoPoint } from './geo_point';\nimport { DocumentReference } from './reference';\nimport { Timestamp } from './timestamp';\nimport { fieldPathFromArgument, parseData, UserData } from './user_data_reader';\nimport { VectorValue } from './vector_value';\n\n/**\n * @beta\n *\n * An enumeration of the different types of expressions.\n */\nexport type ExpressionType =\n  | 'Field'\n  | 'Constant'\n  | 'Function'\n  | 'AggregateFunction'\n  | 'ListOfExpressions'\n  | 'AliasedExpression';\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nfunction valueToDefaultExpr(value: unknown): Expression {\n  let result: Expression | undefined;\n  if (value instanceof Expression) {\n    return value;\n  } else if (isPlainObject(value)) {\n    result = _map(value as Record<string, unknown>, undefined);\n  } else if (value instanceof Array) {\n    result = array(value);\n  } else {\n    result = _constant(value, undefined);\n  }\n\n  return result;\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nfunction vectorToExpr(value: VectorValue | number[] | Expression): Expression {\n  if (value instanceof Expression) {\n    return value;\n  } else if (value instanceof VectorValue) {\n    return constant(value);\n  } else if (Array.isArray(value)) {\n    return constant(vector(value));\n  } else {\n    throw new Error('Unsupported value: ' + typeof value);\n  }\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n * If the input is a string, it is assumed to be a field name, and a\n * field(value) is returned.\n *\n * @private\n * @internal\n * @param value\n */\nfunction fieldOrExpression(value: unknown): Expression {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return valueToDefaultExpr(value);\n  }\n}\n\n/**\n * @beta\n *\n * Represents an expression that can be evaluated to a value within the execution of a {@link\n * @firebase/firestore/pipelines#Pipeline}.\n *\n * Expressions are the building blocks for creating complex queries and transformations in\n * Firestore pipelines. They can represent:\n *\n * - **Field references:** Access values from document fields.\n * - **Literals:** Represent constant values (strings, numbers, booleans).\n * - **Function calls:** Apply functions to one or more expressions.\n *\n * The `Expression` class provides a fluent API for building expressions. You can chain together\n * method calls to create complex expressions.\n */\nexport abstract class Expression implements ProtoValueSerializable, UserData {\n  abstract readonly expressionType: ExpressionType;\n\n  abstract readonly _methodName?: string;\n\n  /**\n   * @private\n   * @internal\n   */\n  abstract _toProto(serializer: JsonProtoSerializer): ProtoValue;\n  _protoValueType = 'ProtoValue' as const;\n\n  /**\n   * @private\n   * @internal\n   */\n  abstract _readUserData(context: ParseContext): void;\n\n  /**\n   * Creates an expression that adds this expression to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Add the value of the 'quantity' field and the 'reserve' field.\n   * field(\"quantity\").add(field(\"reserve\"));\n   * ```\n   *\n   * @param second - The expression or literal to add to this expression.\n   * @param others - Optional additional expressions or literals to add to this expression.\n   * @returns A new `Expression` representing the addition operation.\n   */\n  add(second: Expression | unknown): FunctionExpression {\n    return new FunctionExpression(\n      'add',\n      [this, valueToDefaultExpr(second)],\n      'add'\n    );\n  }\n\n  /**\n   * @beta\n   * Wraps the expression in a [BooleanExpression].\n   *\n   * @returns A [BooleanExpression] representing the same expression.\n   */\n  asBoolean(): BooleanExpression {\n    if (this instanceof BooleanExpression) {\n      return this;\n    } else if (this instanceof Constant) {\n      return new BooleanConstant(this);\n    } else if (this instanceof Field) {\n      return new BooleanField(this);\n    } else if (this instanceof FunctionExpression) {\n      return new BooleanFunctionExpression(this);\n    } else {\n      throw new FirestoreError(\n        'invalid-argument',\n        `Conversion of type ${typeof this} to BooleanExpression not supported.`\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that subtracts another expression from this expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract the 'discount' field from the 'price' field\n   * field(\"price\").subtract(field(\"discount\"));\n   * ```\n   *\n   * @param subtrahend - The expression to subtract from this expression.\n   * @returns A new `Expression` representing the subtraction operation.\n   */\n  subtract(subtrahend: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a constant value from this expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract 20 from the value of the 'total' field\n   * field(\"total\").subtract(20);\n   * ```\n   *\n   * @param subtrahend - The constant value to subtract.\n   * @returns A new `Expression` representing the subtraction operation.\n   */\n  subtract(subtrahend: number): FunctionExpression;\n  subtract(subtrahend: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'subtract',\n      [this, valueToDefaultExpr(subtrahend)],\n      'subtract'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that multiplies this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Multiply the 'quantity' field by the 'price' field\n   * field(\"quantity\").multiply(field(\"price\"));\n   * ```\n   *\n   * @param second - The second expression or literal to multiply by.\n   * @param others - Optional additional expressions or literals to multiply by.\n   * @returns A new `Expression` representing the multiplication operation.\n   */\n  multiply(second: Expression | number): FunctionExpression {\n    return new FunctionExpression(\n      'multiply',\n      [this, valueToDefaultExpr(second)],\n      'multiply'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that divides this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Divide the 'total' field by the 'count' field\n   * field(\"total\").divide(field(\"count\"));\n   * ```\n   *\n   * @param divisor - The expression to divide by.\n   * @returns A new `Expression` representing the division operation.\n   */\n  divide(divisor: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that divides this expression by a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Divide the 'value' field by 10\n   * field(\"value\").divide(10);\n   * ```\n   *\n   * @param divisor - The constant value to divide by.\n   * @returns A new `Expression` representing the division operation.\n   */\n  divide(divisor: number): FunctionExpression;\n  divide(divisor: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'divide',\n      [this, valueToDefaultExpr(divisor)],\n      'divide'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the modulo (remainder) of dividing this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the remainder of dividing the 'value' field by the 'divisor' field\n   * field(\"value\").mod(field(\"divisor\"));\n   * ```\n   *\n   * @param expression - The expression to divide by.\n   * @returns A new `Expression` representing the modulo operation.\n   */\n  mod(expression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that calculates the modulo (remainder) of dividing this expression by a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the remainder of dividing the 'value' field by 10\n   * field(\"value\").mod(10);\n   * ```\n   *\n   * @param value - The constant value to divide by.\n   * @returns A new `Expression` representing the modulo operation.\n   */\n  mod(value: number): FunctionExpression;\n  mod(other: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'mod',\n      [this, valueToDefaultExpr(other)],\n      'mod'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is equal to 21\n   * field(\"age\").equal(21);\n   * ```\n   *\n   * @param expression - The expression to compare for equality.\n   * @returns A new `Expression` representing the equality comparison.\n   */\n  equal(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'city' field is equal to \"London\"\n   * field(\"city\").equal(\"London\");\n   * ```\n   *\n   * @param value - The constant value to compare for equality.\n   * @returns A new `Expression` representing the equality comparison.\n   */\n  equal(value: unknown): BooleanExpression;\n  equal(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'equal',\n      [this, valueToDefaultExpr(other)],\n      'equal'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is not equal to \"completed\"\n   * field(\"status\").notEqual(\"completed\");\n   * ```\n   *\n   * @param expression - The expression to compare for inequality.\n   * @returns A new `Expression` representing the inequality comparison.\n   */\n  notEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'country' field is not equal to \"USA\"\n   * field(\"country\").notEqual(\"USA\");\n   * ```\n   *\n   * @param value - The constant value to compare for inequality.\n   * @returns A new `Expression` representing the inequality comparison.\n   */\n  notEqual(value: unknown): BooleanExpression;\n  notEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'not_equal',\n      [this, valueToDefaultExpr(other)],\n      'notEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is less than 'limit'\n   * field(\"age\").lessThan(field('limit'));\n   * ```\n   *\n   * @param experession - The expression to compare for less than.\n   * @returns A new `Expression` representing the less than comparison.\n   */\n  lessThan(experession: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is less than 50\n   * field(\"price\").lessThan(50);\n   * ```\n   *\n   * @param value - The constant value to compare for less than.\n   * @returns A new `Expression` representing the less than comparison.\n   */\n  lessThan(value: unknown): BooleanExpression;\n  lessThan(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'less_than',\n      [this, valueToDefaultExpr(other)],\n      'lessThan'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than or equal to another\n   * expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'quantity' field is less than or equal to 20\n   * field(\"quantity\").lessThan(constant(20));\n   * ```\n   *\n   * @param expression - The expression to compare for less than or equal to.\n   * @returns A new `Expression` representing the less than or equal to comparison.\n   */\n  lessThanOrEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than or equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'score' field is less than or equal to 70\n   * field(\"score\").lessThan(70);\n   * ```\n   *\n   * @param value - The constant value to compare for less than or equal to.\n   * @returns A new `Expression` representing the less than or equal to comparison.\n   */\n  lessThanOrEqual(value: unknown): BooleanExpression;\n  lessThanOrEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'less_than_or_equal',\n      [this, valueToDefaultExpr(other)],\n      'lessThanOrEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is greater than the 'limit' field\n   * field(\"age\").greaterThan(field(\"limit\"));\n   * ```\n   *\n   * @param expression - The expression to compare for greater than.\n   * @returns A new `Expression` representing the greater than comparison.\n   */\n  greaterThan(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is greater than 100\n   * field(\"price\").greaterThan(100);\n   * ```\n   *\n   * @param value - The constant value to compare for greater than.\n   * @returns A new `Expression` representing the greater than comparison.\n   */\n  greaterThan(value: unknown): BooleanExpression;\n  greaterThan(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'greater_than',\n      [this, valueToDefaultExpr(other)],\n      'greaterThan'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than or equal to another\n   * expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'quantity' field is greater than or equal to field 'requirement' plus 1\n   * field(\"quantity\").greaterThanOrEqual(field('requirement').add(1));\n   * ```\n   *\n   * @param expression - The expression to compare for greater than or equal to.\n   * @returns A new `Expression` representing the greater than or equal to comparison.\n   */\n  greaterThanOrEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than or equal to a constant\n   * value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'score' field is greater than or equal to 80\n   * field(\"score\").greaterThanOrEqual(80);\n   * ```\n   *\n   * @param value - The constant value to compare for greater than or equal to.\n   * @returns A new `Expression` representing the greater than or equal to comparison.\n   */\n  greaterThanOrEqual(value: unknown): BooleanExpression;\n  greaterThanOrEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'greater_than_or_equal',\n      [this, valueToDefaultExpr(other)],\n      'greaterThanOrEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates an array expression with one or more other arrays.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'items' array with another array field.\n   * field(\"items\").arrayConcat(field(\"otherItems\"));\n   * ```\n   * @param secondArray - Second array expression or array literal to concatenate.\n   * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n   * @returns A new `Expression` representing the concatenated array.\n   */\n  arrayConcat(\n    secondArray: Expression | unknown[],\n    ...otherArrays: Array<Expression | unknown[]>\n  ): FunctionExpression {\n    const elements = [secondArray, ...otherArrays];\n    const exprValues = elements.map(value => valueToDefaultExpr(value));\n    return new FunctionExpression(\n      'array_concat',\n      [this, ...exprValues],\n      'arrayConcat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains a specific element.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'sizes' array contains the value from the 'selectedSize' field\n   * field(\"sizes\").arrayContains(field(\"selectedSize\"));\n   * ```\n   *\n   * @param expression - The element to search for in the array.\n   * @returns A new `Expression` representing the 'array_contains' comparison.\n   */\n  arrayContains(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains a specific value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'colors' array contains \"red\"\n   * field(\"colors\").arrayContains(\"red\");\n   * ```\n   *\n   * @param value - The element to search for in the array.\n   * @returns A new `Expression` representing the 'array_contains' comparison.\n   */\n  arrayContains(value: unknown): BooleanExpression;\n  arrayContains(element: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'array_contains',\n      [this, valueToDefaultExpr(element)],\n      'arrayContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains all the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'tags' array contains both the value in field \"tag1\" and the literal value \"tag2\"\n   * field(\"tags\").arrayContainsAll([field(\"tag1\"), \"tag2\"]);\n   * ```\n   *\n   * @param values - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_all' comparison.\n   */\n  arrayContainsAll(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains all the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'tags' array contains both of the values from field \"tag1\" and the literal value \"tag2\"\n   * field(\"tags\").arrayContainsAll(array([field(\"tag1\"), \"tag2\"]));\n   * ```\n   *\n   * @param arrayExpression - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_all' comparison.\n   */\n  arrayContainsAll(arrayExpression: Expression): BooleanExpression;\n  arrayContainsAll(values: unknown[] | Expression): BooleanExpression {\n    const normalizedExpr = Array.isArray(values)\n      ? new ListOfExprs(values.map(valueToDefaultExpr), 'arrayContainsAll')\n      : values;\n    return new FunctionExpression(\n      'array_contains_all',\n      [this, normalizedExpr],\n      'arrayContainsAll'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains any of the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'categories' array contains either values from field \"cate1\" or \"cate2\"\n   * field(\"categories\").arrayContainsAny([field(\"cate1\"), field(\"cate2\")]);\n   * ```\n   *\n   * @param values - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_any' comparison.\n   */\n  arrayContainsAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains any of the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'groups' array contains either the value from the 'userGroup' field\n   * // or the value \"guest\"\n   * field(\"groups\").arrayContainsAny(array([field(\"userGroup\"), \"guest\"]));\n   * ```\n   *\n   * @param arrayExpression - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_any' comparison.\n   */\n  arrayContainsAny(arrayExpression: Expression): BooleanExpression;\n  arrayContainsAny(\n    values: Array<unknown | Expression> | Expression\n  ): BooleanExpression {\n    const normalizedExpr = Array.isArray(values)\n      ? new ListOfExprs(values.map(valueToDefaultExpr), 'arrayContainsAny')\n      : values;\n    return new FunctionExpression(\n      'array_contains_any',\n      [this, normalizedExpr],\n      'arrayContainsAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses an array.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myArray' field.\n   * field(\"myArray\").arrayReverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n   */\n  arrayReverse(): FunctionExpression {\n    return new FunctionExpression('array_reverse', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of an array.\n   *\n   * @example\n   * ```typescript\n   * // Get the number of items in the 'cart' array\n   * field(\"cart\").arrayLength();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the array.\n   */\n  arrayLength(): FunctionExpression {\n    return new FunctionExpression('array_length', [this], 'arrayLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n   * field(\"category\").equalAny(\"Electronics\", field(\"primaryType\"));\n   * ```\n   *\n   * @param values - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'IN' comparison.\n   */\n  equalAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n   * field(\"category\").equalAny(array([\"Electronics\", field(\"primaryType\")]));\n   * ```\n   *\n   * @param arrayExpression - An expression that evaluates to an array of values to check against.\n   * @returns A new `Expression` representing the 'IN' comparison.\n   */\n  equalAny(arrayExpression: Expression): BooleanExpression;\n  equalAny(others: unknown[] | Expression): BooleanExpression {\n    const exprOthers = Array.isArray(others)\n      ? new ListOfExprs(others.map(valueToDefaultExpr), 'equalAny')\n      : others;\n    return new FunctionExpression(\n      'equal_any',\n      [this, exprOthers],\n      'equalAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n   * field(\"status\").notEqualAny([\"pending\", field(\"rejectedStatus\")]);\n   * ```\n   *\n   * @param values - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'notEqualAny' comparison.\n   */\n  notEqualAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to any of the values in the evaluated expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is not equal to any value in the field 'rejectedStatuses'\n   * field(\"status\").notEqualAny(field('rejectedStatuses'));\n   * ```\n   *\n   * @param arrayExpression - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'notEqualAny' comparison.\n   */\n  notEqualAny(arrayExpression: Expression): BooleanExpression;\n  notEqualAny(others: unknown[] | Expression): BooleanExpression {\n    const exprOthers = Array.isArray(others)\n      ? new ListOfExprs(others.map(valueToDefaultExpr), 'notEqualAny')\n      : others;\n    return new FunctionExpression(\n      'not_equal_any',\n      [this, exprOthers],\n      'notEqualAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a field exists in the document.\n   *\n   * @example\n   * ```typescript\n   * // Check if the document has a field named \"phoneNumber\"\n   * field(\"phoneNumber\").exists();\n   * ```\n   *\n   * @returns A new `Expression` representing the 'exists' check.\n   */\n  exists(): BooleanExpression {\n    return new FunctionExpression('exists', [this], 'exists').asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the character length of a string in UTF-8.\n   *\n   * @example\n   * ```typescript\n   * // Get the character length of the 'name' field in its UTF-8 form.\n   * field(\"name\").charLength();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the string.\n   */\n  charLength(): FunctionExpression {\n    return new FunctionExpression('char_length', [this], 'charLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that performs a case-sensitive string comparison.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'title' field contains the word \"guide\" (case-sensitive)\n   * field(\"title\").like(\"%guide%\");\n   * ```\n   *\n   * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n   * @returns A new `Expression` representing the 'like' comparison.\n   */\n  like(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that performs a case-sensitive string comparison.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'title' field contains the word \"guide\" (case-sensitive)\n   * field(\"title\").like(\"%guide%\");\n   * ```\n   *\n   * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n   * @returns A new `Expression` representing the 'like' comparison.\n   */\n  like(pattern: Expression): BooleanExpression;\n  like(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'like',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'like'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified regular expression as a\n   * substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains \"example\" (case-insensitive)\n   * field(\"description\").regexContains(\"(?i)example\");\n   * ```\n   *\n   * @param pattern - The regular expression to use for the search.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  regexContains(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified regular expression as a\n   * substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains the regular expression stored in field 'regex'\n   * field(\"description\").regexContains(field(\"regex\"));\n   * ```\n   *\n   * @param pattern - The regular expression to use for the search.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  regexContains(pattern: Expression): BooleanExpression;\n  regexContains(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'regex_contains',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string matches a specified regular expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'email' field matches a valid email pattern\n   * field(\"email\").regexMatch(\"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n   * ```\n   *\n   * @param pattern - The regular expression to use for the match.\n   * @returns A new `Expression` representing the regular expression match.\n   */\n  regexMatch(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string matches a specified regular expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'email' field matches a regular expression stored in field 'regex'\n   * field(\"email\").regexMatch(field(\"regex\"));\n   * ```\n   *\n   * @param pattern - The regular expression to use for the match.\n   * @returns A new `Expression` representing the regular expression match.\n   */\n  regexMatch(pattern: Expression): BooleanExpression;\n  regexMatch(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'regex_match',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexMatch'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains \"example\".\n   * field(\"description\").stringContains(\"example\");\n   * ```\n   *\n   * @param substring - The substring to search for.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  stringContains(substring: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains the string represented by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains the value of the 'keyword' field.\n   * field(\"description\").stringContains(field(\"keyword\"));\n   * ```\n   *\n   * @param expr - The expression representing the substring to search for.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  stringContains(expr: Expression): BooleanExpression;\n  stringContains(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'string_contains',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'stringContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string starts with a given prefix.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'name' field starts with \"Mr.\"\n   * field(\"name\").startsWith(\"Mr.\");\n   * ```\n   *\n   * @param prefix - The prefix to check for.\n   * @returns A new `Expression` representing the 'starts with' comparison.\n   */\n  startsWith(prefix: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string starts with a given prefix (represented as an\n   * expression).\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'fullName' field starts with the value of the 'firstName' field\n   * field(\"fullName\").startsWith(field(\"firstName\"));\n   * ```\n   *\n   * @param prefix - The prefix expression to check for.\n   * @returns A new `Expression` representing the 'starts with' comparison.\n   */\n  startsWith(prefix: Expression): BooleanExpression;\n  startsWith(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'starts_with',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'startsWith'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string ends with a given postfix.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'filename' field ends with \".txt\"\n   * field(\"filename\").endsWith(\".txt\");\n   * ```\n   *\n   * @param suffix - The postfix to check for.\n   * @returns A new `Expression` representing the 'ends with' comparison.\n   */\n  endsWith(suffix: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string ends with a given postfix (represented as an\n   * expression).\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'url' field ends with the value of the 'extension' field\n   * field(\"url\").endsWith(field(\"extension\"));\n   * ```\n   *\n   * @param suffix - The postfix expression to check for.\n   * @returns A new `Expression` representing the 'ends with' comparison.\n   */\n  endsWith(suffix: Expression): BooleanExpression;\n  endsWith(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'ends_with',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'endsWith'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts a string to lowercase.\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'name' field to lowercase\n   * field(\"name\").toLower();\n   * ```\n   *\n   * @returns A new `Expression` representing the lowercase string.\n   */\n  toLower(): FunctionExpression {\n    return new FunctionExpression('to_lower', [this], 'toLower');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts a string to uppercase.\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'title' field to uppercase\n   * field(\"title\").toUpper();\n   * ```\n   *\n   * @returns A new `Expression` representing the uppercase string.\n   */\n  toUpper(): FunctionExpression {\n    return new FunctionExpression('to_upper', [this], 'toUpper');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that removes leading and trailing characters from a string or byte array.\n   *\n   * @example\n   * ```typescript\n   * // Trim whitespace from the 'userInput' field\n   * field(\"userInput\").trim();\n   *\n   * // Trim quotes from the 'userInput' field\n   * field(\"userInput\").trim('\"');\n   * ```\n   * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n   * trimmed from the input. If not specified, then whitespace will be trimmed.\n   * @returns A new `Expression` representing the trimmed string or byte array.\n   */\n  trim(valueToTrim?: string | Expression | Bytes): FunctionExpression {\n    const args: Expression[] = [this];\n    if (valueToTrim) {\n      args.push(valueToDefaultExpr(valueToTrim));\n    }\n    return new FunctionExpression('trim', args, 'trim');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates string expressions together.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n   * field(\"firstName\").stringConcat(constant(\" \"), field(\"lastName\"));\n   * ```\n   *\n   * @param secondString - The additional expression or string literal to concatenate.\n   * @param otherStrings - Optional additional expressions or string literals to concatenate.\n   * @returns A new `Expression` representing the concatenated string.\n   */\n  stringConcat(\n    secondString: Expression | string,\n    ...otherStrings: Array<Expression | string>\n  ): FunctionExpression {\n    const elements = [secondString, ...otherStrings];\n    const exprs = elements.map(valueToDefaultExpr);\n    return new FunctionExpression(\n      'string_concat',\n      [this, ...exprs],\n      'stringConcat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates expression results together.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'firstName', ' ', and 'lastName' fields into a single value.\n   * field(\"firstName\").concat(constant(\" \"), field(\"lastName\"));\n   * ```\n   *\n   * @param second - The additional expression or literal to concatenate.\n   * @param others - Optional additional expressions or literals to concatenate.\n   * @returns A new `Expression` representing the concatenated value.\n   */\n  concat(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const elements = [second, ...others];\n    const exprs = elements.map(valueToDefaultExpr);\n    return new FunctionExpression('concat', [this, ...exprs], 'concat');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses this string expression.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myString' field.\n   * field(\"myString\").reverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n   */\n  reverse(): FunctionExpression {\n    return new FunctionExpression('reverse', [this], 'reverse');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of this string expression in bytes.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the length of the 'myString' field in bytes.\n   * field(\"myString\").byteLength();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n   */\n  byteLength(): FunctionExpression {\n    return new FunctionExpression('byte_length', [this], 'byteLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the ceiling of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the ceiling of the 'price' field.\n   * field(\"price\").ceil();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n   */\n  ceil(): FunctionExpression {\n    return new FunctionExpression('ceil', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the floor of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the floor of the 'price' field.\n   * field(\"price\").floor();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n   */\n  floor(): FunctionExpression {\n    return new FunctionExpression('floor', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the absolute value of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the absolute value of the 'price' field.\n   * field(\"price\").abs();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n   */\n  abs(): FunctionExpression {\n    return new FunctionExpression('abs', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes e to the power of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Compute e to the power of the 'value' field.\n   * field(\"value\").exp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n   */\n  exp(): FunctionExpression {\n    return new FunctionExpression('exp', [this]);\n  }\n\n  /**\n   * @beta\n   * Accesses a value from a map (object) field using the provided key.\n   *\n   * @example\n   * ```typescript\n   * // Get the 'city' value from the 'address' map field\n   * field(\"address\").mapGet(\"city\");\n   * ```\n   *\n   * @param subfield - The key to access in the map.\n   * @returns A new `Expression` representing the value associated with the given key in the map.\n   */\n  mapGet(subfield: string): FunctionExpression {\n    return new FunctionExpression(\n      'map_get',\n      [this, constant(subfield)],\n      'mapGet'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that counts the number of stage inputs with valid evaluations of the\n   * expression or field.\n   *\n   * @example\n   * ```typescript\n   * // Count the total number of products\n   * field(\"productId\").count().as(\"totalProducts\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'count' aggregation.\n   */\n  count(): AggregateFunction {\n    return AggregateFunction._create('count', [this], 'count');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that calculates the sum of a numeric field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the total revenue from a set of orders\n   * field(\"orderAmount\").sum().as(\"totalRevenue\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'sum' aggregation.\n   */\n  sum(): AggregateFunction {\n    return AggregateFunction._create('sum', [this], 'sum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that calculates the average (mean) of a numeric field across multiple\n   * stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average age of users\n   * field(\"age\").average().as(\"averageAge\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'average' aggregation.\n   */\n  average(): AggregateFunction {\n    return AggregateFunction._create('average', [this], 'average');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the minimum value of a field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the lowest price of all products\n   * field(\"price\").minimum().as(\"lowestPrice\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'minimum' aggregation.\n   */\n  minimum(): AggregateFunction {\n    return AggregateFunction._create('minimum', [this], 'minimum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the maximum value of a field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the highest score in a leaderboard\n   * field(\"score\").maximum().as(\"highestScore\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'maximum' aggregation.\n   */\n  maximum(): AggregateFunction {\n    return AggregateFunction._create('maximum', [this], 'maximum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that counts the number of distinct values of the expression or field.\n   *\n   * @example\n   * ```typescript\n   * // Count the distinct number of products\n   * field(\"productId\").countDistinct().as(\"distinctProducts\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'count_distinct' aggregation.\n   */\n  countDistinct(): AggregateFunction {\n    return AggregateFunction._create('count_distinct', [this], 'countDistinct');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the larger value between this expression and another expression, based on Firestore's value type ordering.\n   *\n   * @example\n   * ```typescript\n   * // Returns the larger value between the 'timestamp' field and the current timestamp.\n   * field(\"timestamp\").logicalMaximum(Function.currentTimestamp());\n   * ```\n   *\n   * @param second - The second expression or literal to compare with.\n   * @param others - Optional additional expressions or literals to compare with.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n   */\n  logicalMaximum(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const values = [second, ...others];\n    return new FunctionExpression(\n      'maximum',\n      [this, ...values.map(valueToDefaultExpr)],\n      'logicalMaximum'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the smaller value between this expression and another expression, based on Firestore's value type ordering.\n   *\n   * @example\n   * ```typescript\n   * // Returns the smaller value between the 'timestamp' field and the current timestamp.\n   * field(\"timestamp\").logicalMinimum(Function.currentTimestamp());\n   * ```\n   *\n   * @param second - The second expression or literal to compare with.\n   * @param others - Optional additional expressions or literals to compare with.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n   */\n  logicalMinimum(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const values = [second, ...others];\n    return new FunctionExpression(\n      'minimum',\n      [this, ...values.map(valueToDefaultExpr)],\n      'minimum'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length (number of dimensions) of this Firestore Vector expression.\n   *\n   * @example\n   * ```typescript\n   * // Get the vector length (dimension) of the field 'embedding'.\n   * field(\"embedding\").vectorLength();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the vector.\n   */\n  vectorLength(): FunctionExpression {\n    return new FunctionExpression('vector_length', [this], 'vectorLength');\n  }\n\n  /**\n   * @beta\n   * Calculates the cosine distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n   * field(\"userVector\").cosineDistance(field(\"itemVector\"));\n   * ```\n   *\n   * @param vectorExpression - The other vector (represented as an Expression) to compare against.\n   * @returns A new `Expression` representing the cosine distance between the two vectors.\n   */\n  cosineDistance(vectorExpression: Expression): FunctionExpression;\n  /**\n   * @beta\n   * Calculates the Cosine distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Cosine distance between the 'location' field and a target location\n   * field(\"location\").cosineDistance(new VectorValue([37.7749, -122.4194]));\n   * ```\n   *\n   * @param vector - The other vector (as a VectorValue) to compare against.\n   * @returns A new `Expression` representing the Cosine* distance between the two vectors.\n   */\n  cosineDistance(vector: VectorValue | number[]): FunctionExpression;\n  cosineDistance(\n    other: Expression | VectorValue | number[]\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'cosine_distance',\n      [this, vectorToExpr(other)],\n      'cosineDistance'\n    );\n  }\n\n  /**\n   * @beta\n   * Calculates the dot product between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the dot product between a feature vector and a target vector\n   * field(\"features\").dotProduct([0.5, 0.8, 0.2]);\n   * ```\n   *\n   * @param vectorExpression - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the dot product between the two vectors.\n   */\n  dotProduct(vectorExpression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Calculates the dot product between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the dot product between a feature vector and a target vector\n   * field(\"features\").dotProduct(new VectorValue([0.5, 0.8, 0.2]));\n   * ```\n   *\n   * @param vector - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the dot product between the two vectors.\n   */\n  dotProduct(vector: VectorValue | number[]): FunctionExpression;\n  dotProduct(other: Expression | VectorValue | number[]): FunctionExpression {\n    return new FunctionExpression(\n      'dot_product',\n      [this, vectorToExpr(other)],\n      'dotProduct'\n    );\n  }\n\n  /**\n   * @beta\n   * Calculates the Euclidean distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Euclidean distance between the 'location' field and a target location\n   * field(\"location\").euclideanDistance([37.7749, -122.4194]);\n   * ```\n   *\n   * @param vectorExpression - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the Euclidean distance between the two vectors.\n   */\n  euclideanDistance(vectorExpression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Calculates the Euclidean distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Euclidean distance between the 'location' field and a target location\n   * field(\"location\").euclideanDistance(new VectorValue([37.7749, -122.4194]));\n   * ```\n   *\n   * @param vector - The other vector (as a VectorValue) to compare against.\n   * @returns A new `Expression` representing the Euclidean distance between the two vectors.\n   */\n  euclideanDistance(vector: VectorValue | number[]): FunctionExpression;\n  euclideanDistance(\n    other: Expression | VectorValue | number[]\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'euclidean_distance',\n      [this, vectorToExpr(other)],\n      'euclideanDistance'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'microseconds' field as microseconds since epoch.\n   * field(\"microseconds\").unixMicrosToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixMicrosToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_micros_to_timestamp',\n      [this],\n      'unixMicrosToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to microseconds since epoch.\n   * field(\"timestamp\").timestampToUnixMicros();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n   */\n  timestampToUnixMicros(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_micros',\n      [this],\n      'timestampToUnixMicros'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'milliseconds' field as milliseconds since epoch.\n   * field(\"milliseconds\").unixMillisToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixMillisToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_millis_to_timestamp',\n      [this],\n      'unixMillisToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to milliseconds since epoch.\n   * field(\"timestamp\").timestampToUnixMillis();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n   */\n  timestampToUnixMillis(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_millis',\n      [this],\n      'timestampToUnixMillis'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'seconds' field as seconds since epoch.\n   * field(\"seconds\").unixSecondsToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixSecondsToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_seconds_to_timestamp',\n      [this],\n      'unixSecondsToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to seconds since epoch.\n   * field(\"timestamp\").timestampToUnixSeconds();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n   */\n  timestampToUnixSeconds(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_seconds',\n      [this],\n      'timestampToUnixSeconds'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that adds a specified amount of time to this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Add some duration determined by field 'unit' and 'amount' to the 'timestamp' field.\n   * field(\"timestamp\").timestampAdd(field(\"unit\"), field(\"amount\"));\n   * ```\n   *\n   * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n   * @param amount - The expression evaluates to amount of the unit.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampAdd(unit: Expression, amount: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that adds a specified amount of time to this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Add 1 day to the 'timestamp' field.\n   * field(\"timestamp\").timestampAdd(\"day\", 1);\n   * ```\n   *\n   * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n   * @param amount - The amount of time to add.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampAdd(\n    unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n    amount: number\n  ): FunctionExpression;\n  timestampAdd(\n    unit:\n      | Expression\n      | 'microsecond'\n      | 'millisecond'\n      | 'second'\n      | 'minute'\n      | 'hour'\n      | 'day',\n    amount: Expression | number\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_add',\n      [this, valueToDefaultExpr(unit), valueToDefaultExpr(amount)],\n      'timestampAdd'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a specified amount of time from this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract some duration determined by field 'unit' and 'amount' from the 'timestamp' field.\n   * field(\"timestamp\").timestampSubtract(field(\"unit\"), field(\"amount\"));\n   * ```\n   *\n   * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n   * @param amount - The expression evaluates to amount of the unit.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampSubtract(unit: Expression, amount: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a specified amount of time from this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract 1 day from the 'timestamp' field.\n   * field(\"timestamp\").timestampSubtract(\"day\", 1);\n   * ```\n   *\n   * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n   * @param amount - The amount of time to subtract.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampSubtract(\n    unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n    amount: number\n  ): FunctionExpression;\n  timestampSubtract(\n    unit:\n      | Expression\n      | 'microsecond'\n      | 'millisecond'\n      | 'second'\n      | 'minute'\n      | 'hour'\n      | 'day',\n    amount: Expression | number\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_subtract',\n      [this, valueToDefaultExpr(unit), valueToDefaultExpr(amount)],\n      'timestampSubtract'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the document ID from a path.\n   *\n   * @example\n   * ```typescript\n   * // Get the document ID from a path.\n   * field(\"__path__\").documentId();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n   */\n  documentId(): FunctionExpression {\n    return new FunctionExpression('document_id', [this], 'documentId');\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns a substring of the results of this expression.\n   *\n   * @param position - Index of the first character of the substring.\n   * @param length - Length of the substring. If not provided, the substring will\n   * end at the end of the input.\n   */\n  substring(position: number, length?: number): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns a substring of the results of this expression.\n   *\n   * @param position - An expression returning the index of the first character of the substring.\n   * @param length - An expression returning the length of the substring. If not provided the\n   * substring will end at the end of the input.\n   */\n  substring(position: Expression, length?: Expression): FunctionExpression;\n  substring(\n    position: Expression | number,\n    length?: Expression | number\n  ): FunctionExpression {\n    const positionExpr = valueToDefaultExpr(position);\n    if (length === undefined) {\n      return new FunctionExpression(\n        'substring',\n        [this, positionExpr],\n        'substring'\n      );\n    } else {\n      return new FunctionExpression(\n        'substring',\n        [this, positionExpr, valueToDefaultExpr(length)],\n        'substring'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that indexes into an array from the beginning or end\n   * and returns the element. If the offset exceeds the array length, an error is\n   * returned. A negative offset, starts from the end.\n   *\n   * @example\n   * ```typescript\n   * // Return the value in the 'tags' field array at index `1`.\n   * field('tags').arrayGet(1);\n   * ```\n   *\n   * @param offset - The index of the element to return.\n   * @returns A new `Expression` representing the 'arrayGet' operation.\n   */\n  arrayGet(offset: number): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that indexes into an array from the beginning or end\n   * and returns the element. If the offset exceeds the array length, an error is\n   * returned. A negative offset, starts from the end.\n   *\n   * @example\n   * ```typescript\n   * // Return the value in the tags field array at index specified by field\n   * // 'favoriteTag'.\n   * field('tags').arrayGet(field('favoriteTag'));\n   * ```\n   *\n   * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n   * @returns A new `Expression` representing the 'arrayGet' operation.\n   */\n  arrayGet(offsetExpr: Expression): FunctionExpression;\n  arrayGet(offset: Expression | number): FunctionExpression {\n    return new FunctionExpression(\n      'array_get',\n      [this, valueToDefaultExpr(offset)],\n      'arrayGet'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that checks if a given expression produces an error.\n   *\n   * @example\n   * ```typescript\n   * // Check if the result of a calculation is an error\n   * field(\"title\").arrayContains(1).isError();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#BooleanExpression} representing the 'isError' check.\n   */\n  isError(): BooleanExpression {\n    return new FunctionExpression('is_error', [this], 'isError').asBoolean();\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the result of the `catchExpr` argument\n   * if there is an error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Returns the first item in the title field arrays, or returns\n   * // the entire title field if the array is empty or the field is another type.\n   * field(\"title\").arrayGet(0).ifError(field(\"title\"));\n   * ```\n   *\n   * @param catchExpr - The catch expression that will be evaluated and\n   * returned if this expression produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchExpr: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Returns the first item in the title field arrays, or returns\n   * // \"Default Title\"\n   * field(\"title\").arrayGet(0).ifError(\"Default Title\");\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: unknown): FunctionExpression;\n  ifError(catchValue: unknown): FunctionExpression | BooleanExpression {\n    const result = new FunctionExpression(\n      'if_error',\n      [this, valueToDefaultExpr(catchValue)],\n      'ifError'\n    );\n\n    return catchValue instanceof BooleanExpression\n      ? result.asBoolean()\n      : result;\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns `true` if the result of this expression\n   * is absent. Otherwise, returns `false` even if the value is `null`.\n   *\n   * @example\n   * ```typescript\n   * // Check if the field `value` is absent.\n   * field(\"value\").isAbsent();\n   * @example\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#BooleanExpression} representing the 'isAbsent' check.\n   */\n  isAbsent(): BooleanExpression {\n    return new FunctionExpression('is_absent', [this], 'isAbsent').asBoolean();\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that removes a key from the map produced by evaluating this expression.\n   *\n   * @example\n   * ```\n   * // Removes the key 'baz' from the input map.\n   * map({foo: 'bar', baz: true}).mapRemove('baz');\n   * ```\n   *\n   * @param key - The name of the key to remove from the input map.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapRemove' operation.\n   */\n  mapRemove(key: string): FunctionExpression;\n  /**\n   * @beta\n   *\n   * Creates an expression that removes a key from the map produced by evaluating this expression.\n   *\n   * @example\n   * ```\n   * // Removes the key 'baz' from the input map.\n   * map({foo: 'bar', baz: true}).mapRemove(constant('baz'));\n   * @example\n   * ```\n   *\n   * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapRemove' operation.\n   */\n  mapRemove(keyExpr: Expression): FunctionExpression;\n  mapRemove(stringExpr: Expression | string): FunctionExpression {\n    return new FunctionExpression(\n      'map_remove',\n      [this, valueToDefaultExpr(stringExpr)],\n      'mapRemove'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that merges multiple map values.\n   *\n   * @example\n   * ```\n   * // Merges the map in the settings field with, a map literal, and a map in\n   * // that is conditionally returned by another expression\n   * field('settings').mapMerge({ enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n   * ```\n   *\n   * @param secondMap - A required second map to merge. Represented as a literal or\n   * an expression that returns a map.\n   * @param otherMaps - Optional additional maps to merge. Each map is represented\n   * as a literal or an expression that returns a map.\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapMerge' operation.\n   */\n  mapMerge(\n    secondMap: Record<string, unknown> | Expression,\n    ...otherMaps: Array<Record<string, unknown> | Expression>\n  ): FunctionExpression {\n    const secondMapExpr = valueToDefaultExpr(secondMap);\n    const otherMapExprs = otherMaps.map(valueToDefaultExpr);\n    return new FunctionExpression(\n      'map_merge',\n      [this, secondMapExpr, ...otherMapExprs],\n      'mapMerge'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the value of this expression raised to the power of another expression.\n   *\n   * @example\n   * ```typescript\n   * // Raise the value of the 'base' field to the power of the 'exponent' field.\n   * field(\"base\").pow(field(\"exponent\"));\n   * ```\n   *\n   * @param exponent - The expression to raise this expression to the power of.\n   * @returns A new `Expression` representing the power operation.\n   */\n  pow(exponent: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the value of this expression raised to the power of a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Raise the value of the 'base' field to the power of 2.\n   * field(\"base\").pow(2);\n   * ```\n   *\n   * @param exponent - The constant value to raise this expression to the power of.\n   * @returns A new `Expression` representing the power operation.\n   */\n  pow(exponent: number): FunctionExpression;\n  pow(exponent: number | Expression): FunctionExpression {\n    return new FunctionExpression('pow', [this, valueToDefaultExpr(exponent)]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the nearest whole number.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field.\n   * field(\"price\").round();\n   * ```\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(): FunctionExpression;\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field to two decimal places.\n   * field(\"price\").round(2);\n   * ```\n   *\n   * @param decimalPlaces - A constant specifying the rounding precision in decimal places.\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(decimalPlaces: number): FunctionExpression;\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field to two decimal places.\n   * field(\"price\").round(constant(2));\n   * ```\n   *\n   * @param decimalPlaces - An expression specifying the rounding precision in decimal places.\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(decimalPlaces: Expression): FunctionExpression;\n  round(decimalPlaces?: number | Expression): FunctionExpression {\n    if (decimalPlaces === undefined) {\n      return new FunctionExpression('round', [this]);\n    } else {\n      return new FunctionExpression(\n        'round',\n        [this, valueToDefaultExpr(decimalPlaces)],\n        'round'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the collection ID from a path.\n   *\n   * @example\n   * ```typescript\n   * // Get the collection ID from a path.\n   * field(\"__path__\").collectionId();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n   */\n  collectionId(): FunctionExpression {\n    return new FunctionExpression('collection_id', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n   *\n   * @example\n   * ```typescript\n   * // Get the length of the 'name' field.\n   * field(\"name\").length();\n   *\n   * // Get the number of items in the 'cart' array.\n   * field(\"cart\").length();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n   */\n  length(): FunctionExpression {\n    return new FunctionExpression('length', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the natural logarithm of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the natural logarithm of the 'value' field.\n   * field(\"value\").ln();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the natural logarithm of the numeric value.\n   */\n  ln(): FunctionExpression {\n    return new FunctionExpression('ln', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the square root of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the square root of the 'value' field.\n   * field(\"value\").sqrt();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n   */\n  sqrt(): FunctionExpression {\n    return new FunctionExpression('sqrt', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses a string.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myString' field.\n   * field(\"myString\").stringReverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n   */\n  stringReverse(): FunctionExpression {\n    return new FunctionExpression('string_reverse', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the `elseValue` argument if this expression results in an absent value, else\n   * return the result of the this expression evaluation.\n   *\n   * @example\n   * ```typescript\n   * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n   * // if the field is absent.\n   * field(\"optional_field\").ifAbsent(\"default_value\")\n   * ```\n   *\n   * @param elseValue - The value that will be returned if this Expression evaluates to an absent value.\n   * @returns A new [Expression] representing the ifAbsent operation.\n   */\n  ifAbsent(elseValue: unknown): Expression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the `elseValue` argument if this expression results in an absent value, else\n   * return the result of this expression evaluation.\n   *\n   * ```typescript\n   * // Returns the value of the optional field 'optional_field', or if that is\n   * // absent, then returns the value of the field `\n   * field(\"optional_field\").ifAbsent(field('default_field'))\n   * ```\n   *\n   * @param elseExpression - The Expression that will be evaluated if this Expression evaluates to an absent value.\n   * @returns A new [Expression] representing the ifAbsent operation.\n   */\n  ifAbsent(elseExpression: unknown): Expression;\n\n  ifAbsent(elseValueOrExpression: Expression | unknown): Expression {\n    return new FunctionExpression(\n      'if_absent',\n      [this, valueToDefaultExpr(elseValueOrExpression)],\n      'ifAbsent'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that joins the elements of an array into a string.\n   *\n   * @example\n   * ```typescript\n   * // Join the elements of the 'tags' field with the delimiter from the 'separator' field.\n   * field(\"tags\").join(field(\"separator\"))\n   * ```\n   *\n   * @param delimiterExpression - The expression that evaluates to the delimiter string.\n   * @returns A new Expression representing the join operation.\n   */\n  join(delimiterExpression: Expression): Expression;\n\n  /**\n   * @beta\n   * Creates an expression that joins the elements of an array field into a string.\n   *\n   * @example\n   * ```typescript\n   * // Join the elements of the 'tags' field with a comma and space.\n   * field(\"tags\").join(\", \")\n   * ```\n   *\n   * @param delimiter - The string to use as a delimiter.\n   * @returns A new Expression representing the join operation.\n   */\n  join(delimiter: string): Expression;\n\n  join(delimeterValueOrExpression: string | Expression): Expression {\n    return new FunctionExpression(\n      'join',\n      [this, valueToDefaultExpr(delimeterValueOrExpression)],\n      'join'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the base-10 logarithm of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the base-10 logarithm of the 'value' field.\n   * field(\"value\").log10();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the base-10 logarithm of the numeric value.\n   */\n  log10(): FunctionExpression {\n    return new FunctionExpression('log10', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the sum of the elements in an array.\n   *\n   * @example\n   * ```typescript\n   * // Compute the sum of the elements in the 'scores' field.\n   * field(\"scores\").arraySum();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the sum of the elements in the array.\n   */\n  arraySum(): FunctionExpression {\n    return new FunctionExpression('sum', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that splits the result of this expression into an\n   * array of substrings based on the provided delimiter.\n   *\n   * @example\n   * ```typescript\n   * // Split the 'scoresCsv' field on delimiter ','\n   * field('scoresCsv').split(',')\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n   */\n  split(delimiter: string): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that splits the result of this expression into an\n   * array of substrings based on the provided delimiter.\n   *\n   * @example\n   * ```typescript\n   * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n   * field('scores').split(conditional(field('format').equal('csv'), constant(','), constant(':'))\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n   */\n  split(delimiter: Expression): FunctionExpression;\n  split(delimiter: string | Expression): FunctionExpression {\n    return new FunctionExpression('split', [\n      this,\n      valueToDefaultExpr(delimiter)\n    ]);\n  }\n\n  /**\n   * Creates an expression that truncates a timestamp to a specified granularity.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'createdAt' timestamp to the beginning of the day.\n   * field('createdAt').timestampTruncate('day')\n   * ```\n   *\n   * @param granularity - The granularity to truncate to.\n   * @param timezone - The timezone to use for truncation. Valid values are from\n   * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n   * @returns A new `Expression` representing the truncated timestamp.\n   */\n  timestampTruncate(\n    granularity: TimeGranularity,\n    timezone?: string | Expression\n  ): FunctionExpression;\n\n  /**\n   * Creates an expression that truncates a timestamp to a specified granularity.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n   * field('createdAt').timestampTruncate(field('granularity'))\n   * ```\n   *\n   * @param granularity - The granularity to truncate to.\n   * @param timezone - The timezone to use for truncation. Valid values are from\n   * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n   * @returns A new `Expression` representing the truncated timestamp.\n   */\n  timestampTruncate(\n    granularity: Expression,\n    timezone?: string | Expression\n  ): FunctionExpression;\n  timestampTruncate(\n    granularity: TimeGranularity | Expression,\n    timezone?: string | Expression\n  ): FunctionExpression {\n    const internalGranularity = isString(granularity)\n      ? granularity.toLowerCase()\n      : granularity;\n\n    const args = [this, valueToDefaultExpr(internalGranularity)];\n    if (timezone) {\n      args.push(valueToDefaultExpr(timezone));\n    }\n    return new FunctionExpression('timestamp_trunc', args);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the data type of this expression's result, as a string.\n   *\n   * @example\n   * ```typescript\n   * // Get the data type of the value in field 'title'\n   * field('title').type()\n   * ```\n   *\n   * @returns A new `Expression` representing the data type.\n   */\n  type(): FunctionExpression {\n    return new FunctionExpression('type', [this]);\n  }\n\n  // TODO(new-expression): Add new expression method definitions above this line\n\n  /**\n   * @beta\n   * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on this expression.\n   *\n   * @example\n   * ```typescript\n   * // Sort documents by the 'name' field in ascending order\n   * pipeline().collection(\"users\")\n   *   .sort(field(\"name\").ascending());\n   * ```\n   *\n   * @returns A new `Ordering` for ascending sorting.\n   */\n  ascending(): Ordering {\n    return ascending(this);\n  }\n\n  /**\n   * @beta\n   * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on this expression.\n   *\n   * @example\n   * ```typescript\n   * // Sort documents by the 'createdAt' field in descending order\n   * firestore.pipeline().collection(\"users\")\n   *   .sort(field(\"createdAt\").descending());\n   * ```\n   *\n   * @returns A new `Ordering` for descending sorting.\n   */\n  descending(): Ordering {\n    return descending(this);\n  }\n\n  /**\n   * @beta\n   * Assigns an alias to this expression.\n   *\n   * Aliases are useful for renaming fields in the output of a stage or for giving meaningful\n   * names to calculated values.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the total price and assign it the alias \"totalPrice\" and add it to the output.\n   * firestore.pipeline().collection(\"items\")\n   *   .addFields(field(\"price\").multiply(field(\"quantity\")).as(\"totalPrice\"));\n   * ```\n   *\n   * @param name - The alias to assign to this expression.\n   * @returns A new {@link @firebase/firestore/pipelines#AliasedExpression} that wraps this\n   *     expression and associates it with the provided alias.\n   */\n  as(name: string): AliasedExpression {\n    return new AliasedExpression(this, name, 'as');\n  }\n}\n\n/**\n * @beta\n * Specify time granularity for expressions.\n */\nexport type TimeGranularity =\n  | 'microsecond'\n  | 'millisecond'\n  | 'second'\n  | 'minute'\n  | 'hour'\n  | 'day'\n  | 'week'\n  | 'week(monday)'\n  | 'week(tuesday)'\n  | 'week(wednesday)'\n  | 'week(thursday)'\n  | 'week(friday)'\n  | 'week(saturday)'\n  | 'week(sunday)'\n  | 'isoWeek'\n  | 'month'\n  | 'quarter'\n  | 'year'\n  | 'isoYear';\n\n/**\n * @beta\n *\n * An interface that represents a selectable expression.\n */\nexport interface Selectable {\n  selectable: true;\n  /**\n   * @private\n   * @internal\n   */\n  readonly alias: string;\n  /**\n   * @private\n   * @internal\n   */\n  readonly expr: Expression;\n}\n\n/**\n * @beta\n *\n * A class that represents an aggregate function.\n */\nexport class AggregateFunction implements ProtoValueSerializable, UserData {\n  exprType: ExpressionType = 'AggregateFunction';\n\n  /**\n   * @internal\n   */\n  _methodName?: string;\n\n  constructor(private name: string, private params: Expression[]) {}\n\n  /**\n   * @internal\n   * @private\n   */\n  static _create(\n    name: string,\n    params: Expression[],\n    methodName: string\n  ): AggregateFunction {\n    const af = new AggregateFunction(name, params);\n    af._methodName = methodName;\n\n    return af;\n  }\n\n  /**\n   * @beta\n   * Assigns an alias to this AggregateFunction. The alias specifies the name that\n   * the aggregated value will have in the output document.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average price of all items and assign it the alias \"averagePrice\".\n   * firestore.pipeline().collection(\"items\")\n   *   .aggregate(field(\"price\").average().as(\"averagePrice\"));\n   * ```\n   *\n   * @param name - The alias to assign to this AggregateFunction.\n   * @returns A new {@link @firebase/firestore/pipelines#AliasedAggregate} that wraps this\n   *     AggregateFunction and associates it with the provided alias.\n   */\n  as(name: string): AliasedAggregate {\n    return new AliasedAggregate(this, name, 'as');\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      functionValue: {\n        name: this.name,\n        args: this.params.map(p => p._toProto(serializer))\n      }\n    };\n  }\n\n  _protoValueType = 'ProtoValue' as const;\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.params.forEach(expr => {\n      return expr._readUserData(context);\n    });\n  }\n}\n\n/**\n * @beta\n *\n * An AggregateFunction with alias.\n */\nexport class AliasedAggregate implements UserData {\n  constructor(\n    readonly aggregate: AggregateFunction,\n    readonly alias: string,\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.aggregate._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class AliasedExpression implements Selectable, UserData {\n  exprType: ExpressionType = 'AliasedExpression';\n  selectable = true as const;\n\n  constructor(\n    readonly expr: Expression,\n    readonly alias: string,\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.expr._readUserData(context);\n  }\n}\n\n/**\n * @internal\n */\nclass ListOfExprs extends Expression implements UserData {\n  expressionType: ExpressionType = 'ListOfExpressions';\n\n  constructor(\n    private exprs: Expression[],\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      arrayValue: {\n        values: this.exprs.map(p => p._toProto(serializer)!)\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.exprs.forEach((expr: Expression) => expr._readUserData(context));\n  }\n}\n\n/**\n * @beta\n *\n * Represents a reference to a field in a Firestore document, or outputs of a {@link @firebase/firestore/pipelines#Pipeline} stage.\n *\n * <p>Field references are used to access document field values in expressions and to specify fields\n * for sorting, filtering, and projecting data in Firestore pipelines.\n *\n * <p>You can create a `Field` instance using the static {@link @firebase/firestore/pipelines#field} method:\n *\n * @example\n * ```typescript\n * // Create a Field instance for the 'name' field\n * const nameField = field(\"name\");\n *\n * // Create a Field instance for a nested field 'address.city'\n * const cityField = field(\"address.city\");\n * ```\n */\nexport class Field extends Expression implements Selectable {\n  readonly expressionType: ExpressionType = 'Field';\n  selectable = true as const;\n\n  /**\n   * @internal\n   * @private\n   * @hideconstructor\n   * @param fieldPath\n   */\n  constructor(\n    private fieldPath: InternalFieldPath,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  get fieldName(): string {\n    return this.fieldPath.canonicalString();\n  }\n\n  get alias(): string {\n    return this.fieldName;\n  }\n\n  get expr(): Expression {\n    return this;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      fieldReferenceValue: this.fieldPath.canonicalString()\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {}\n}\n\n/**\n * @beta\n * Creates a {@link @firebase/firestore/pipelines#Field} instance representing the field at the given path.\n *\n * The path can be a simple field name (e.g., \"name\") or a dot-separated path to a nested field\n * (e.g., \"address.city\").\n *\n * @example\n * ```typescript\n * // Create a Field instance for the 'title' field\n * const titleField = field(\"title\");\n *\n * // Create a Field instance for a nested field 'author.firstName'\n * const authorFirstNameField = field(\"author.firstName\");\n * ```\n *\n * @param name - The path to the field.\n * @returns A new {@link @firebase/firestore/pipelines#Field} instance representing the specified field.\n */\nexport function field(name: string): Field;\n\n/**\n * @beta\n * Creates a {@link @firebase/firestore/pipelines#Field} instance representing the field at the given path.\n *\n * @param path - A FieldPath specifying the field.\n * @returns A new {@link @firebase/firestore/pipelines#Field} instance representing the specified field.\n */\nexport function field(path: FieldPath): Field;\nexport function field(nameOrPath: string | FieldPath): Field {\n  return _field(nameOrPath, 'field');\n}\n\nexport function _field(\n  nameOrPath: string | FieldPath,\n  methodName: string | undefined\n): Field {\n  if (typeof nameOrPath === 'string') {\n    if (DOCUMENT_KEY_NAME === nameOrPath) {\n      return new Field(documentIdFieldPath()._internalPath, methodName);\n    }\n    return new Field(fieldPathFromArgument('field', nameOrPath), methodName);\n  } else {\n    return new Field(nameOrPath._internalPath, methodName);\n  }\n}\n\n/**\n * @internal\n *\n * Represents a constant value that can be used in a Firestore pipeline expression.\n *\n * You can create a `Constant` instance using the static {@link @firebase/firestore/pipelines#field} method:\n *\n * @example\n * ```typescript\n * // Create a Constant instance for the number 10\n * const ten = constant(10);\n *\n * // Create a Constant instance for the string \"hello\"\n * const hello = constant(\"hello\");\n * ```\n */\nexport class Constant extends Expression {\n  readonly expressionType: ExpressionType = 'Constant';\n\n  private _protoValue?: ProtoValue;\n\n  /**\n   * @private\n   * @internal\n   * @hideconstructor\n   * @param value - The value of the constant.\n   */\n  constructor(\n    private value: unknown,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  static _fromProto(value: ProtoValue): Constant {\n    const result = new Constant(value, undefined);\n    result._protoValue = value;\n    return result;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(_: JsonProtoSerializer): ProtoValue {\n    hardAssert(\n      this._protoValue !== undefined,\n      0x00ed,\n      'Value of this constant has not been serialized to proto value'\n    );\n    return this._protoValue;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    if (isFirestoreValue(this._protoValue)) {\n      return;\n    } else {\n      this._protoValue = parseData(this.value, context)!;\n    }\n  }\n}\n\n/**\n * @beta\n * Creates a `Constant` instance for a number value.\n *\n * @param value - The number value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: number): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a string value.\n *\n * @param value - The string value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: string): Expression;\n\n/**\n * @beta\n * Creates a `BooleanExpression` instance for a boolean value.\n *\n * @param value - The boolean value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: boolean): BooleanExpression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a null value.\n *\n * @param value - The null value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: null): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a GeoPoint value.\n *\n * @param value - The GeoPoint value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: GeoPoint): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Timestamp value.\n *\n * @param value - The Timestamp value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Timestamp): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Date value.\n *\n * @param value - The Date value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Date): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Bytes value.\n *\n * @param value - The Bytes value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Bytes): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a DocumentReference value.\n *\n * @param value - The DocumentReference value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: DocumentReference): Expression;\n\n/**\n * Creates a `Constant` instance for a Firestore proto value.\n * For internal use only.\n * @private\n * @internal\n * @param value - The Firestore proto value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: ProtoValue): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a VectorValue value.\n *\n * @param value - The VectorValue value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: VectorValue): Expression;\n\nexport function constant(value: unknown): Expression | BooleanExpression {\n  return _constant(value, 'constant');\n}\n\n/**\n * @internal\n * @private\n * @param value\n * @param methodName\n */\nexport function _constant(\n  value: unknown,\n  methodName: string | undefined\n): Constant | BooleanExpression {\n  const c = new Constant(value, methodName);\n  if (typeof value === 'boolean') {\n    return new BooleanConstant(c);\n  } else {\n    return c;\n  }\n}\n\n/**\n * Internal only\n * @internal\n * @private\n */\nexport class MapValue extends Expression {\n  constructor(\n    private plainObject: Map<string, Expression>,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  expressionType: ExpressionType = 'Constant';\n\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.plainObject.forEach(expr => {\n      expr._readUserData(context);\n    });\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return toMapValue(serializer, this.plainObject);\n  }\n}\n\n/**\n * @beta\n *\n * This class defines the base class for Firestore {@link @firebase/firestore/pipelines#Pipeline} functions, which can be evaluated within pipeline\n * execution.\n *\n * Typically, you would not use this class or its children directly. Use either the functions like {@link @firebase/firestore/pipelines#and}, {@link @firebase/firestore/pipelines#(equal:1)},\n * or the methods on {@link @firebase/firestore/pipelines#Expression} ({@link @firebase/firestore/pipelines#Expression.(equal:1)}, {@link @firebase/firestore/pipelines#Expression.(lessThan:1)}, etc.) to construct new Function instances.\n */\nexport class FunctionExpression extends Expression {\n  readonly expressionType: ExpressionType = 'Function';\n\n  constructor(name: string, params: Expression[]);\n  constructor(\n    name: string,\n    params: Expression[],\n    _methodName: string | undefined\n  );\n  constructor(\n    private name: string,\n    private params: Expression[],\n    readonly _methodName?: string\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      functionValue: {\n        name: this.name,\n        args: this.params.map(p => p._toProto(serializer))\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.params.forEach(expr => {\n      return expr._readUserData(context);\n    });\n  }\n}\n\n/**\n * @beta\n *\n * An interface that represents a filter condition.\n */\nexport abstract class BooleanExpression extends Expression {\n  abstract get _expr(): Expression;\n\n  get _methodName(): string | undefined {\n    return this._expr._methodName;\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the count of input documents satisfying\n   * this boolean expression.\n   *\n   * @example\n   * ```typescript\n   * // Find the count of documents with a score greater than 90\n   * field(\"score\").greaterThan(90).countIf().as(\"highestScore\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'countIf' aggregation.\n   */\n  countIf(): AggregateFunction {\n    return AggregateFunction._create('count_if', [this], 'countIf');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that negates this boolean expression.\n   *\n   * @example\n   * ```typescript\n   * // Find documents where the 'tags' field does not contain 'completed'\n   * field(\"tags\").arrayContains(\"completed\").not();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the negated filter condition.\n   */\n  not(): BooleanExpression {\n    return new FunctionExpression('not', [this], 'not').asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates a conditional expression that evaluates to the 'then' expression\n   * if `this` expression evaluates to `true`,\n   * or evaluates to the 'else' expression if `this` expressions evaluates `false`.\n   *\n   * @example\n   * ```typescript\n   * // If 'age' is greater than 18, return \"Adult\"; otherwise, return \"Minor\".\n   * field(\"age\").greaterThanOrEqual(18).conditional(constant(\"Adult\"), constant(\"Minor\"));\n   * ```\n   *\n   * @param thenExpr - The expression to evaluate if the condition is true.\n   * @param elseExpr - The expression to evaluate if the condition is false.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the conditional expression.\n   */\n  conditional(thenExpr: Expression, elseExpr: Expression): FunctionExpression {\n    return new FunctionExpression(\n      'conditional',\n      [this, thenExpr, elseExpr],\n      'conditional'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error\n   * // but always returns a boolean expression.\n   * constant(50).divide('length').gt(1).ifError(constant(false));\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: BooleanExpression): BooleanExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error\n   * // but always returns a boolean expression.\n   * constant(50).divide('length').gt(1).ifError(false);\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: boolean): BooleanExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error.\n   * constant(50).divide('length').gt(1).ifError(constant(0));\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error.\n   * constant(50).divide('length').gt(1).ifError(0);\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: unknown): FunctionExpression;\n  ifError(catchValue: unknown): unknown {\n    const normalizedCatchValue = valueToDefaultExpr(catchValue);\n    const expr = new FunctionExpression(\n      'if_error',\n      [this, normalizedCatchValue],\n      'ifError'\n    );\n\n    return normalizedCatchValue instanceof BooleanExpression\n      ? expr.asBoolean()\n      : expr;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return this._expr._toProto(serializer);\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this._expr._readUserData(context);\n  }\n}\n\nexport class BooleanFunctionExpression extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Function';\n  constructor(readonly _expr: FunctionExpression) {\n    super();\n  }\n}\n\nexport class BooleanConstant extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Constant';\n  constructor(readonly _expr: Constant) {\n    super();\n  }\n}\n\nexport class BooleanField extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Field';\n  constructor(readonly _expr: Field) {\n    super();\n  }\n}\n\n/**\n * @beta\n * Creates an aggregation that counts the number of stage inputs where the provided\n * boolean expression evaluates to true.\n *\n * @example\n * ```typescript\n * // Count the number of documents where 'is_active' field equals true\n * countIf(field(\"is_active\").equal(true)).as(\"numActiveDocuments\");\n * ```\n *\n * @param booleanExpr - The boolean expression to evaluate on each input.\n * @returns A new `AggregateFunction` representing the 'countIf' aggregation.\n */\nexport function countIf(booleanExpr: BooleanExpression): AggregateFunction {\n  return booleanExpr.countIf();\n}\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index 1.\n * arrayGet('tags', 1);\n * ```\n *\n * @param arrayField - The name of the array field.\n * @param offset - The index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayField: string,\n  offset: number\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index specified by field\n * // 'favoriteTag'.\n * arrayGet('tags', field('favoriteTag'));\n * ```\n *\n * @param arrayField - The name of the array field.\n * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayField: string,\n  offsetExpr: Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index 1.\n * arrayGet(field('tags'), 1);\n * ```\n *\n * @param arrayExpression - An `Expression` evaluating to an array.\n * @param offset - The index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayExpression: Expression,\n  offset: number\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index specified by field\n * // 'favoriteTag'.\n * arrayGet(field('tags'), field('favoriteTag'));\n * ```\n *\n * @param arrayExpression - An `Expression` evaluating to an array.\n * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayExpression: Expression,\n  offsetExpr: Expression\n): FunctionExpression;\nexport function arrayGet(\n  array: Expression | string,\n  offset: Expression | number\n): FunctionExpression {\n  return fieldOrExpression(array).arrayGet(valueToDefaultExpr(offset));\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a given expression produces an error.\n *\n * @example\n * ```typescript\n * // Check if the result of a calculation is an error\n * isError(field(\"title\").arrayContains(1));\n * ```\n *\n * @param value - The expression to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isError' check.\n */\nexport function isError(value: Expression): BooleanExpression {\n  return value.isError().asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * This overload is useful when a BooleanExpression is required.\n *\n * @example\n * ```typescript\n * // Create an expression that protects against a divide by zero error\n * // but always returns a boolean expression.\n * ifError(constant(50).divide('length').gt(1), constant(false));\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchExpr - The catch expression that will be evaluated and\n * returned if the tryExpr produces an error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: BooleanExpression,\n  catchExpr: BooleanExpression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the first item in the title field arrays, or returns\n * // the entire title field if the array is empty or the field is another type.\n * ifError(field(\"title\").arrayGet(0), field(\"title\"));\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchExpr - The catch expression that will be evaluated and\n * returned if the tryExpr produces an error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: Expression,\n  catchExpr: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the first item in the title field arrays, or returns\n * // \"Default Title\"\n * ifError(field(\"title\").arrayGet(0), \"Default Title\");\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchValue - The value that will be returned if the tryExpr produces an\n * error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: Expression,\n  catchValue: unknown\n): FunctionExpression;\n\nexport function ifError(\n  tryExpr: Expression,\n  catchValue: unknown\n): FunctionExpression | BooleanExpression {\n  if (\n    tryExpr instanceof BooleanExpression &&\n    catchValue instanceof BooleanExpression\n  ) {\n    return tryExpr.ifError(catchValue).asBoolean();\n  } else {\n    return tryExpr.ifError(valueToDefaultExpr(catchValue));\n  }\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns `true` if a value is absent. Otherwise,\n * returns `false` even if the value is `null`.\n *\n * @example\n * ```typescript\n * // Check if the field `value` is absent.\n * isAbsent(field(\"value\"));\n * ```\n *\n * @param value - The expression to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isAbsent' check.\n */\nexport function isAbsent(value: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns `true` if a field is absent. Otherwise,\n * returns `false` even if the field value is `null`.\n *\n * @example\n * ```typescript\n * // Check if the field `value` is absent.\n * isAbsent(\"value\");\n * ```\n *\n * @param field - The field to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isAbsent' check.\n */\nexport function isAbsent(field: string): BooleanExpression;\nexport function isAbsent(value: Expression | string): BooleanExpression {\n  return fieldOrExpression(value).isAbsent();\n}\n\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map at the specified field name.\n *\n * @example\n * ```\n * // Removes the key 'city' field from the map in the address field of the input document.\n * mapRemove('address', 'city');\n * ```\n *\n * @param mapField - The name of a field containing a map value.\n * @param key - The name of the key to remove from the input map.\n */\nexport function mapRemove(mapField: string, key: string): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map produced by evaluating an expression.\n *\n * @example\n * ```\n * // Removes the key 'baz' from the input map.\n * mapRemove(map({foo: 'bar', baz: true}), 'baz');\n * @example\n * ```\n *\n * @param mapExpr - An expression return a map value.\n * @param key - The name of the key to remove from the input map.\n */\nexport function mapRemove(mapExpr: Expression, key: string): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map at the specified field name.\n *\n * @example\n * ```\n * // Removes the key 'city' field from the map in the address field of the input document.\n * mapRemove('address', constant('city'));\n * ```\n *\n * @param mapField - The name of a field containing a map value.\n * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n */\nexport function mapRemove(\n  mapField: string,\n  keyExpr: Expression\n): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map produced by evaluating an expression.\n *\n * @example\n * ```\n * // Removes the key 'baz' from the input map.\n * mapRemove(map({foo: 'bar', baz: true}), constant('baz'));\n * @example\n * ```\n *\n * @param mapExpr - An expression return a map value.\n * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n */\nexport function mapRemove(\n  mapExpr: Expression,\n  keyExpr: Expression\n): FunctionExpression;\n\nexport function mapRemove(\n  mapExpr: Expression | string,\n  stringExpr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(mapExpr).mapRemove(valueToDefaultExpr(stringExpr));\n}\n\n/**\n * @beta\n *\n * Creates an expression that merges multiple map values.\n *\n * @example\n * ```\n * // Merges the map in the settings field with, a map literal, and a map in\n * // that is conditionally returned by another expression\n * mapMerge('settings', { enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n * ```\n *\n * @param mapField - Name of a field containing a map value that will be merged.\n * @param secondMap - A required second map to merge. Represented as a literal or\n * an expression that returns a map.\n * @param otherMaps - Optional additional maps to merge. Each map is represented\n * as a literal or an expression that returns a map.\n */\nexport function mapMerge(\n  mapField: string,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that merges multiple map values.\n *\n * @example\n * ```\n * // Merges the map in the settings field with, a map literal, and a map in\n * // that is conditionally returned by another expression\n * mapMerge(field('settings'), { enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n * ```\n *\n * @param firstMap - An expression or literal map value that will be merged.\n * @param secondMap - A required second map to merge. Represented as a literal or\n * an expression that returns a map.\n * @param otherMaps - Optional additional maps to merge. Each map is represented\n * as a literal or an expression that returns a map.\n */\nexport function mapMerge(\n  firstMap: Record<string, unknown> | Expression,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression;\n\nexport function mapMerge(\n  firstMap: string | Record<string, unknown> | Expression,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression {\n  const secondMapExpr = valueToDefaultExpr(secondMap);\n  const otherMapExprs = otherMaps.map(valueToDefaultExpr);\n  return fieldOrExpression(firstMap).mapMerge(secondMapExpr, ...otherMapExprs);\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the document ID from a path.\n *\n * @example\n * ```typescript\n * // Get the document ID from a path.\n * documentId(myDocumentReference);\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n */\nexport function documentId(\n  documentPath: string | DocumentReference\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the document ID from a path.\n *\n * @example\n * ```typescript\n * // Get the document ID from a path.\n * documentId(field(\"__path__\"));\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n */\nexport function documentId(documentPathExpr: Expression): FunctionExpression;\n\nexport function documentId(\n  documentPath: Expression | string | DocumentReference\n): FunctionExpression {\n  // @ts-ignore\n  const documentPathExpr = valueToDefaultExpr(documentPath);\n  return documentPathExpr.documentId();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param field - The name of a field containing a string or byte array to compute the substring from.\n * @param position - Index of the first character of the substring.\n * @param length - Length of the substring.\n */\nexport function substring(\n  field: string,\n  position: number,\n  length?: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param input - An expression returning a string or byte array to compute the substring from.\n * @param position - Index of the first character of the substring.\n * @param length - Length of the substring.\n */\nexport function substring(\n  input: Expression,\n  position: number,\n  length?: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param field - The name of a field containing a string or byte array to compute the substring from.\n * @param position - An expression that returns the index of the first character of the substring.\n * @param length - An expression that returns the length of the substring.\n */\nexport function substring(\n  field: string,\n  position: Expression,\n  length?: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param input - An expression returning a string or byte array to compute the substring from.\n * @param position - An expression that returns the index of the first character of the substring.\n * @param length - An expression that returns the length of the substring.\n */\nexport function substring(\n  input: Expression,\n  position: Expression,\n  length?: Expression\n): FunctionExpression;\n\nexport function substring(\n  field: Expression | string,\n  position: Expression | number,\n  length?: Expression | number\n): FunctionExpression {\n  const fieldExpr = fieldOrExpression(field);\n  const positionExpr = valueToDefaultExpr(position);\n  const lengthExpr =\n    length === undefined ? undefined : valueToDefaultExpr(length);\n  return fieldExpr.substring(positionExpr, lengthExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that adds two expressions together.\n *\n * @example\n * ```typescript\n * // Add the value of the 'quantity' field and the 'reserve' field.\n * add(field(\"quantity\"), field(\"reserve\"));\n * ```\n *\n * @param first - The first expression to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the addition operation.\n */\nexport function add(\n  first: Expression,\n  second: Expression | unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a field's value to an expression.\n *\n * @example\n * ```typescript\n * // Add the value of the 'quantity' field and the 'reserve' field.\n * add(\"quantity\", field(\"reserve\"));\n * ```\n *\n * @param fieldName - The name of the field containing the value to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the addition operation.\n */\nexport function add(\n  fieldName: string,\n  second: Expression | unknown\n): FunctionExpression;\n\nexport function add(\n  first: Expression | string,\n  second: Expression | unknown\n): FunctionExpression {\n  return fieldOrExpression(first).add(valueToDefaultExpr(second));\n}\n\n/**\n * @beta\n *\n * Creates an expression that subtracts two expressions.\n *\n * @example\n * ```typescript\n * // Subtract the 'discount' field from the 'price' field\n * subtract(field(\"price\"), field(\"discount\"));\n * ```\n *\n * @param left - The expression to subtract from.\n * @param right - The expression to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  left: Expression,\n  right: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a constant value from an expression.\n *\n * @example\n * ```typescript\n * // Subtract the constant value 2 from the 'value' field\n * subtract(field(\"value\"), 2);\n * ```\n *\n * @param expression - The expression to subtract from.\n * @param value - The constant value to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  expression: Expression,\n  value: unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts an expression from a field's value.\n *\n * @example\n * ```typescript\n * // Subtract the 'discount' field from the 'price' field\n * subtract(\"price\", field(\"discount\"));\n * ```\n *\n * @param fieldName - The field name to subtract from.\n * @param expression - The expression to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  fieldName: string,\n  expression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a constant value from a field's value.\n *\n * @example\n * ```typescript\n * // Subtract 20 from the value of the 'total' field\n * subtract(\"total\", 20);\n * ```\n *\n * @param fieldName - The field name to subtract from.\n * @param value - The constant value to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(fieldName: string, value: unknown): FunctionExpression;\nexport function subtract(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.subtract(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that multiplies two expressions together.\n *\n * @example\n * ```typescript\n * // Multiply the 'quantity' field by the 'price' field\n * multiply(field(\"quantity\"), field(\"price\"));\n * ```\n *\n * @param first - The first expression to multiply.\n * @param second - The second expression or literal to multiply.\n * @param others - Optional additional expressions or literals to multiply.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the multiplication operation.\n */\nexport function multiply(\n  first: Expression,\n  second: Expression | unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that multiplies a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Multiply the 'quantity' field by the 'price' field\n * multiply(\"quantity\", field(\"price\"));\n * ```\n *\n * @param fieldName - The name of the field containing the value to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the multiplication operation.\n */\nexport function multiply(\n  fieldName: string,\n  second: Expression | unknown\n): FunctionExpression;\n\nexport function multiply(\n  first: Expression | string,\n  second: Expression | unknown\n): FunctionExpression {\n  return fieldOrExpression(first).multiply(valueToDefaultExpr(second));\n}\n\n/**\n * @beta\n *\n * Creates an expression that divides two expressions.\n *\n * @example\n * ```typescript\n * // Divide the 'total' field by the 'count' field\n * divide(field(\"total\"), field(\"count\"));\n * ```\n *\n * @param left - The expression to be divided.\n * @param right - The expression to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(left: Expression, right: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides an expression by a constant value.\n *\n * @example\n * ```typescript\n * // Divide the 'value' field by 10\n * divide(field(\"value\"), 10);\n * ```\n *\n * @param expression - The expression to be divided.\n * @param value - The constant value to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(\n  expression: Expression,\n  value: unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Divide the 'total' field by the 'count' field\n * divide(\"total\", field(\"count\"));\n * ```\n *\n * @param fieldName - The field name to be divided.\n * @param expressions - The expression to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(\n  fieldName: string,\n  expressions: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides a field's value by a constant value.\n *\n * @example\n * ```typescript\n * // Divide the 'value' field by 10\n * divide(\"value\", 10);\n * ```\n *\n * @param fieldName - The field name to be divided.\n * @param value - The constant value to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(fieldName: string, value: unknown): FunctionExpression;\nexport function divide(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.divide(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing two expressions.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 'field2'.\n * mod(field(\"field1\"), field(\"field2\"));\n * ```\n *\n * @param left - The dividend expression.\n * @param right - The divisor expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(left: Expression, right: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing an expression by a constant.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 5.\n * mod(field(\"field1\"), 5);\n * ```\n *\n * @param expression - The dividend expression.\n * @param value - The divisor constant.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(expression: Expression, value: unknown): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 'field2'.\n * mod(\"field1\", field(\"field2\"));\n * ```\n *\n * @param fieldName - The dividend field name.\n * @param expression - The divisor expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(\n  fieldName: string,\n  expression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing a field's value by a constant.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 5.\n * mod(\"field1\", 5);\n * ```\n *\n * @param fieldName - The dividend field name.\n * @param value - The divisor constant.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(fieldName: string, value: unknown): FunctionExpression;\nexport function mod(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.mod(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that creates a Firestore map value from an input object.\n *\n * @example\n * ```typescript\n * // Create a map from the input object and reference the 'baz' field value from the input document.\n * map({foo: 'bar', baz: Field.of('baz')}).as('data');\n * ```\n *\n * @param elements - The input map to evaluate in the expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the map function.\n */\nexport function map(elements: Record<string, unknown>): FunctionExpression {\n  return _map(elements, 'map');\n}\nexport function _map(\n  elements: Record<string, unknown>,\n  methodName: string | undefined\n): FunctionExpression {\n  const result: Expression[] = [];\n  for (const key in elements) {\n    if (Object.prototype.hasOwnProperty.call(elements, key)) {\n      const value = elements[key];\n      result.push(constant(key));\n      result.push(valueToDefaultExpr(value));\n    }\n  }\n  return new FunctionExpression('map', result, 'map');\n}\n\n/**\n * Internal use only\n * Converts a plainObject to a mapValue in the proto representation,\n * rather than a functionValue+map that is the result of the map(...) function.\n * This behaves different from constant(plainObject) because it\n * traverses the input object, converts values in the object to expressions,\n * and calls _readUserData on each of these expressions.\n * @private\n * @internal\n * @param plainObject\n */\nexport function _mapValue(plainObject: Record<string, unknown>): MapValue {\n  const result: Map<string, Expression> = new Map<string, Expression>();\n  for (const key in plainObject) {\n    if (Object.prototype.hasOwnProperty.call(plainObject, key)) {\n      const value = plainObject[key];\n      result.set(key, valueToDefaultExpr(value));\n    }\n  }\n  return new MapValue(result, undefined);\n}\n\n/**\n * @beta\n *\n * Creates an expression that creates a Firestore array value from an input array.\n *\n * @example\n * ```typescript\n * // Create an array value from the input array and reference the 'baz' field value from the input document.\n * array(['bar', Field.of('baz')]).as('foo');\n * ```\n *\n * @param elements - The input array to evaluate in the expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the array function.\n */\nexport function array(elements: unknown[]): FunctionExpression {\n  return _array(elements, 'array');\n}\nexport function _array(\n  elements: unknown[],\n  methodName: string | undefined\n): FunctionExpression {\n  return new FunctionExpression(\n    'array',\n    elements.map(element => valueToDefaultExpr(element)),\n    methodName\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if two expressions are equal.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to an expression\n * equal(field(\"age\"), field(\"minAge\").add(10));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(left: Expression, right: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to 21\n * equal(field(\"age\"), 21);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to the 'limit' field\n * equal(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'city' field is equal to string constant \"London\"\n * equal(\"city\", \"London\");\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(fieldName: string, value: unknown): BooleanExpression;\nexport function equal(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.equal(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if two expressions are not equal.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to field 'finalState'\n * notEqual(field(\"status\"), field(\"finalState\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to \"completed\"\n * notEqual(field(\"status\"), \"completed\");\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to the value of 'expectedStatus'\n * notEqual(\"status\", field(\"expectedStatus\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'country' field is not equal to \"USA\"\n * notEqual(\"country\", \"USA\");\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(fieldName: string, value: unknown): BooleanExpression;\nexport function notEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.notEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is less than the second expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than 30\n * lessThan(field(\"age\"), field(\"limit\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is less than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than 30\n * lessThan(field(\"age\"), 30);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than the 'limit' field\n * lessThan(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is less than 50\n * lessThan(\"price\", 50);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(fieldName: string, value: unknown): BooleanExpression;\nexport function lessThan(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.lessThan(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is less than or equal to the second\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to 20\n * lessThan(field(\"quantity\"), field(\"limit\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is less than or equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to 20\n * lessThan(field(\"quantity\"), 20);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n * Creates an expression that checks if a field's value is less than or equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to the 'limit' field\n * lessThan(\"quantity\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than or equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'score' field is less than or equal to 70\n * lessThan(\"score\", 70);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function lessThanOrEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.lessThanOrEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is greater than the second\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18\n * greaterThan(field(\"age\"), Constant(9).add(9));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is greater than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18\n * greaterThan(field(\"age\"), 18);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than an expression.\n *\n * @example\n * ```typescript\n * // Check if the value of field 'age' is greater than the value of field 'limit'\n * greaterThan(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is greater than 100\n * greaterThan(\"price\", 100);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function greaterThan(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.greaterThan(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is greater than or equal to the\n * second expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is greater than or equal to the field \"threshold\"\n * greaterThanOrEqual(field(\"quantity\"), field(\"threshold\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is greater than or equal to a constant\n * value.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is greater than or equal to 10\n * greaterThanOrEqual(field(\"quantity\"), 10);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than or equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the value of field 'age' is greater than or equal to the value of field 'limit'\n * greaterThanOrEqual(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The expression to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  fieldName: string,\n  value: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than or equal to a constant\n * value.\n *\n * @example\n * ```typescript\n * // Check if the 'score' field is greater than or equal to 80\n * greaterThanOrEqual(\"score\", 80);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function greaterThanOrEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.greaterThanOrEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that concatenates an array expression with other arrays.\n *\n * @example\n * ```typescript\n * // Combine the 'items' array with two new item arrays\n * arrayConcat(field(\"items\"), [field(\"newItems\"), field(\"otherItems\")]);\n * ```\n *\n * @param firstArray - The first array expression to concatenate to.\n * @param secondArray - The second array expression or array literal to concatenate to.\n * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated array.\n */\nexport function arrayConcat(\n  firstArray: Expression,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that concatenates a field's array value with other arrays.\n *\n * @example\n * ```typescript\n * // Combine the 'items' array with two new item arrays\n * arrayConcat(\"items\", [field(\"newItems\"), field(\"otherItems\")]);\n * ```\n *\n * @param firstArrayField - The first array to concatenate to.\n * @param secondArray - The second array expression or array literal to concatenate to.\n * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated array.\n */\nexport function arrayConcat(\n  firstArrayField: string,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression;\n\nexport function arrayConcat(\n  firstArray: Expression | string,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression {\n  const exprValues = otherArrays.map(element => valueToDefaultExpr(element));\n  return fieldOrExpression(firstArray).arrayConcat(\n    fieldOrExpression(secondArray),\n    ...exprValues\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains the value of field 'selectedColor'\n * arrayContains(field(\"colors\"), field(\"selectedColor\"));\n * ```\n *\n * @param array - The array expression to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  array: Expression,\n  element: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains \"red\"\n * arrayContains(field(\"colors\"), \"red\");\n * ```\n *\n * @param array - The array expression to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  array: Expression,\n  element: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains the value of field 'selectedColor'\n * arrayContains(\"colors\", field(\"selectedColor\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  fieldName: string,\n  element: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains a specific value.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains \"red\"\n * arrayContains(\"colors\", \"red\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  fieldName: string,\n  element: unknown\n): BooleanExpression;\nexport function arrayContains(\n  array: Expression | string,\n  element: unknown\n): BooleanExpression {\n  const arrayExpr = fieldOrExpression(array);\n  const elementExpr = valueToDefaultExpr(element);\n  return arrayExpr.arrayContains(elementExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'categories' array contains either values from field \"cate1\" or \"Science\"\n * arrayContainsAny(field(\"categories\"), [field(\"cate1\"), \"Science\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  array: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'groups' array contains either the value from the 'userGroup' field\n * // or the value \"guest\"\n * arrayContainsAny(\"categories\", [field(\"cate1\"), \"Science\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'categories' array contains either values from field \"cate1\" or \"Science\"\n * arrayContainsAny(field(\"categories\"), array([field(\"cate1\"), \"Science\"]));\n * ```\n *\n * @param array - The array expression to check.\n * @param values - An expression that evaluates to an array, whose elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  array: Expression,\n  values: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'groups' array contains either the value from the 'userGroup' field\n * // or the value \"guest\"\n * arrayContainsAny(\"categories\", array([field(\"cate1\"), \"Science\"]));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - An expression that evaluates to an array, whose elements to check for in the array field.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  fieldName: string,\n  values: Expression\n): BooleanExpression;\nexport function arrayContainsAny(\n  array: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(array).arrayContainsAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains all the specified elements.\n *\n * @example\n * ```typescript\n * // Check if the \"tags\" array contains all of the values: \"SciFi\", \"Adventure\", and the value from field \"tag1\"\n * arrayContainsAll(field(\"tags\"), [field(\"tag1\"), constant(\"SciFi\"), \"Adventure\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  array: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains all the specified values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'tags' array contains both of the values from field 'tag1', the value \"SciFi\", and \"Adventure\"\n * arrayContainsAll(\"tags\", [field(\"tag1\"), \"SciFi\", \"Adventure\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains all the specified elements.\n *\n * @example\n * ```typescript\n * // Check if the \"tags\" array contains all of the values: \"SciFi\", \"Adventure\", and the value from field \"tag1\"\n * arrayContainsAll(field(\"tags\"), [field(\"tag1\"), constant(\"SciFi\"), \"Adventure\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param arrayExpression - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  array: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains all the specified values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'tags' array contains both of the values from field 'tag1', the value \"SciFi\", and \"Adventure\"\n * arrayContainsAll(\"tags\", [field(\"tag1\"), \"SciFi\", \"Adventure\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param arrayExpression - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\nexport function arrayContainsAll(\n  array: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(array).arrayContainsAll(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of an array in a specified field.\n *\n * @example\n * ```typescript\n * // Get the number of items in field 'cart'\n * arrayLength('cart');\n * ```\n *\n * @param fieldName - The name of the field containing an array to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function arrayLength(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of an array expression.\n *\n * @example\n * ```typescript\n * // Get the number of items in the 'cart' array\n * arrayLength(field(\"cart\"));\n * ```\n *\n * @param array - The array expression to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function arrayLength(array: Expression): FunctionExpression;\nexport function arrayLength(array: Expression | string): FunctionExpression {\n  return fieldOrExpression(array).arrayLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression, when evaluated, is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(field(\"category\"), [constant(\"Electronics\"), field(\"primaryType\")]);\n * ```\n *\n * @param expression - The expression whose results to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  expression: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is equal to any of the provided values.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is set to a value in the disabledCategories field\n * equalAny(field(\"category\"), field('disabledCategories'));\n * ```\n *\n * @param expression - The expression whose results to compare.\n * @param arrayExpression - An expression that evaluates to an array, whose elements to check for equality to the input.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  expression: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(\"category\", [constant(\"Electronics\"), field(\"primaryType\")]);\n * ```\n *\n * @param fieldName - The field to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(\"category\", [\"Electronics\", field(\"primaryType\")]);\n * ```\n *\n * @param fieldName - The field to compare.\n * @param arrayExpression - An expression that evaluates to an array, whose elements to check for equality to the input field.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\nexport function equalAny(\n  element: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(element).equalAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n * notEqualAny(field(\"status\"), [\"pending\", field(\"rejectedStatus\")]);\n * ```\n *\n * @param element - The expression to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  element: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n * notEqualAny(\"status\", [constant(\"pending\"), field(\"rejectedStatus\")]);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of the field 'rejectedStatus'\n * notEqualAny(field(\"status\"), [\"pending\", field(\"rejectedStatus\")]);\n * ```\n *\n * @param element - The expression to compare.\n * @param arrayExpression - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  element: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to any of the values in the evaluated expression.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to any value in the field 'rejectedStatuses'\n * notEqualAny(\"status\", field(\"rejectedStatuses\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param arrayExpression - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\n\nexport function notEqualAny(\n  element: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(element).notEqualAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'XOR' (exclusive OR) operation on multiple BooleanExpressions.\n *\n * @example\n * ```typescript\n * // Check if only one of the conditions is true: 'age' greater than 18, 'city' is \"London\",\n * // or 'status' is \"active\".\n * const condition = xor(\n *     greaterThan(\"age\", 18),\n *     equal(\"city\", \"London\"),\n *     equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first condition.\n * @param second - The second condition.\n * @param additionalConditions - Additional conditions to 'XOR' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'XOR' operation.\n */\nexport function xor(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...additionalConditions: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'xor',\n    [first, second, ...additionalConditions],\n    'xor'\n  ).asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates a conditional expression that evaluates to a 'then' expression if a condition is true\n * and an 'else' expression if the condition is false.\n *\n * @example\n * ```typescript\n * // If 'age' is greater than 18, return \"Adult\"; otherwise, return \"Minor\".\n * conditional(\n *     greaterThan(\"age\", 18), constant(\"Adult\"), constant(\"Minor\"));\n * ```\n *\n * @param condition - The condition to evaluate.\n * @param thenExpr - The expression to evaluate if the condition is true.\n * @param elseExpr - The expression to evaluate if the condition is false.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the conditional expression.\n */\nexport function conditional(\n  condition: BooleanExpression,\n  thenExpr: Expression,\n  elseExpr: Expression\n): FunctionExpression {\n  return new FunctionExpression(\n    'conditional',\n    [condition, thenExpr, elseExpr],\n    'conditional'\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that negates a filter condition.\n *\n * @example\n * ```typescript\n * // Find documents where the 'completed' field is NOT true\n * not(equal(\"completed\", true));\n * ```\n *\n * @param booleanExpr - The filter condition to negate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the negated filter condition.\n */\nexport function not(booleanExpr: BooleanExpression): BooleanExpression {\n  return booleanExpr.not();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the largest value between multiple input\n * expressions or literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the largest value between the 'field1' field, the 'field2' field,\n * // and 1000\n * logicalMaximum(field(\"field1\"), field(\"field2\"), 1000);\n * ```\n *\n * @param first - The first operand expression.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n */\nexport function logicalMaximum(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the largest value between multiple input\n * expressions or literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the largest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMaximum(\"field1\", field(\"field2\"), 1000);\n * ```\n *\n * @param fieldName - The first operand field name.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n */\nexport function logicalMaximum(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function logicalMaximum(\n  first: Expression | string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return fieldOrExpression(first).logicalMaximum(\n    valueToDefaultExpr(second),\n    ...others.map(value => valueToDefaultExpr(value))\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the smallest value between multiple input\n * expressions and literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the smallest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMinimum(field(\"field1\"), field(\"field2\"), 1000);\n * ```\n *\n * @param first - The first operand expression.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n */\nexport function logicalMinimum(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the smallest value between a field's value\n * and other input expressions or literal values.\n * Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the smallest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMinimum(\"field1\", field(\"field2\"), 1000);\n * ```\n *\n * @param fieldName - The first operand field name.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n */\nexport function logicalMinimum(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function logicalMinimum(\n  first: Expression | string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return fieldOrExpression(first).logicalMinimum(\n    valueToDefaultExpr(second),\n    ...others.map(value => valueToDefaultExpr(value))\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field exists.\n *\n * @example\n * ```typescript\n * // Check if the document has a field named \"phoneNumber\"\n * exists(field(\"phoneNumber\"));\n * ```\n *\n * @param value - An expression evaluates to the name of the field to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'exists' check.\n */\nexport function exists(value: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field exists.\n *\n * @example\n * ```typescript\n * // Check if the document has a field named \"phoneNumber\"\n * exists(\"phoneNumber\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'exists' check.\n */\nexport function exists(fieldName: string): BooleanExpression;\nexport function exists(valueOrField: Expression | string): BooleanExpression {\n  return fieldOrExpression(valueOrField).exists();\n}\n\n/**\n * @beta\n *\n * Creates an expression that reverses a string.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * reverse(field(\"myString\"));\n * ```\n *\n * @param stringExpression - An expression evaluating to a string value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function reverse(stringExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that reverses a string value in the specified field.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * reverse(\"myString\");\n * ```\n *\n * @param field - The name of the field representing the string to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function reverse(field: string): FunctionExpression;\nexport function reverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).reverse();\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the byte length of a string in UTF-8, or just the length of a Blob.\n *\n * @example\n * ```typescript\n * // Calculate the length of the 'myString' field in bytes.\n * byteLength(field(\"myString\"));\n * ```\n *\n * @param expr - The expression representing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n */\nexport function byteLength(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a string represented by a field in UTF-8 bytes, or just the length of a Blob.\n *\n * @example\n * ```typescript\n * // Calculate the length of the 'myString' field in bytes.\n * byteLength(\"myString\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n */\nexport function byteLength(fieldName: string): FunctionExpression;\nexport function byteLength(expr: Expression | string): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.byteLength();\n}\n\n/**\n * @beta\n * Creates an expression that reverses an array.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myArray' field.\n * arrayReverse(\"myArray\");\n * ```\n *\n * @param fieldName - The name of the field to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n */\nexport function arrayReverse(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that reverses an array.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myArray' field.\n * arrayReverse(field(\"myArray\"));\n * ```\n *\n * @param arrayExpression - An expression evaluating to an array value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n */\nexport function arrayReverse(arrayExpression: Expression): FunctionExpression;\nexport function arrayReverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).arrayReverse();\n}\n\n/**\n * @beta\n * Creates an expression that computes e to the power of the expression's result.\n *\n * @example\n * ```typescript\n * // Compute e to the power of 2.\n * exp(constant(2));\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n */\nexport function exp(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes e to the power of the expression's result.\n *\n * @example\n * ```typescript\n * // Compute e to the power of the 'value' field.\n * exp('value');\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n */\nexport function exp(fieldName: string): FunctionExpression;\n\nexport function exp(\n  expressionOrFieldName: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expressionOrFieldName).exp();\n}\n\n/**\n * @beta\n * Creates an expression that computes the ceiling of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the ceiling of the 'price' field.\n * ceil(\"price\");\n * ```\n *\n * @param fieldName - The name of the field to compute the ceiling of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n */\nexport function ceil(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the ceiling of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the ceiling of the 'price' field.\n * ceil(field(\"price\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the ceiling will be computed for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n */\nexport function ceil(expression: Expression): FunctionExpression;\nexport function ceil(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).ceil();\n}\n\n/**\n * @beta\n * Creates an expression that computes the floor of a numeric value.\n *\n * @param expr - The expression to compute the floor of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n */\nexport function floor(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the floor of a numeric value.\n *\n * @param fieldName - The name of the field to compute the floor of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n */\nexport function floor(fieldName: string): FunctionExpression;\nexport function floor(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).floor();\n}\n\n/**\n * @beta\n * Creates an aggregation that counts the number of distinct values of a field.\n *\n * @param expr - The expression or field to count distinct values of.\n * @returns A new `AggregateFunction` representing the 'count_distinct' aggregation.\n */\nexport function countDistinct(expr: Expression | string): AggregateFunction {\n  return fieldOrExpression(expr).countDistinct();\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the character length of a string field in UTF8.\n *\n * @example\n * ```typescript\n * // Get the character length of the 'name' field in UTF-8.\n * strLength(\"name\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string.\n */\nexport function charLength(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the character length of a string expression in UTF-8.\n *\n * @example\n * ```typescript\n * // Get the character length of the 'name' field in UTF-8.\n * strLength(field(\"name\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string.\n */\nexport function charLength(stringExpression: Expression): FunctionExpression;\nexport function charLength(value: Expression | string): FunctionExpression {\n  const valueExpr = fieldOrExpression(value);\n  return valueExpr.charLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison against a\n * field.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(\"title\", \"%guide%\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(fieldName: string, pattern: string): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison against a\n * field.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(\"title\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(fieldName: string, pattern: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(field(\"title\"), \"%guide%\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(field(\"title\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function like(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.like(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified regular expression as\n * a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(\"description\", \"(?i)example\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  fieldName: string,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified regular expression as\n * a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(\"description\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  fieldName: string,\n  pattern: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified regular\n * expression as a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(field(\"description\"), \"(?i)example\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified regular\n * expression as a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(field(\"description\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function regexContains(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexContains(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field matches a specified regular expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(\"email\", \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  fieldName: string,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field matches a specified regular expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(\"email\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  fieldName: string,\n  pattern: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression matches a specified regular\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(field(\"email\"), \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n * ```\n *\n * @param stringExpression - The expression representing the string to match against.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression matches a specified regular\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(field(\"email\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to match against.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function regexMatch(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexMatch(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\".\n * stringContains(\"description\", \"example\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param substring - The substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  fieldName: string,\n  substring: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a substring specified by an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains the value of the 'keyword' field.\n * stringContains(\"description\", field(\"keyword\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param substring - The expression representing the substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  fieldName: string,\n  substring: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\".\n * stringContains(field(\"description\"), \"example\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param substring - The substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  stringExpression: Expression,\n  substring: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a substring specified by another expression.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains the value of the 'keyword' field.\n * stringContains(field(\"description\"), field(\"keyword\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param substring - The expression representing the substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  stringExpression: Expression,\n  substring: Expression\n): BooleanExpression;\nexport function stringContains(\n  left: Expression | string,\n  substring: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const substringExpr = valueToDefaultExpr(substring);\n  return leftExpr.stringContains(substringExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the 'name' field starts with \"Mr.\"\n * startsWith(\"name\", \"Mr.\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  fieldName: string,\n  prefix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the 'fullName' field starts with the value of the 'firstName' field\n * startsWith(\"fullName\", field(\"firstName\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param prefix - The expression representing the prefix.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  fieldName: string,\n  prefix: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields starts with \"Mr.\"\n * startsWith(field(\"fullName\"), \"Mr.\");\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  stringExpression: Expression,\n  prefix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields starts with \"Mr.\"\n * startsWith(field(\"fullName\"), field(\"prefix\"));\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  stringExpression: Expression,\n  prefix: Expression\n): BooleanExpression;\nexport function startsWith(\n  expr: Expression | string,\n  prefix: Expression | string\n): BooleanExpression {\n  return fieldOrExpression(expr).startsWith(valueToDefaultExpr(prefix));\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the 'filename' field ends with \".txt\"\n * endsWith(\"filename\", \".txt\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(fieldName: string, suffix: string): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the 'url' field ends with the value of the 'extension' field\n * endsWith(\"url\", field(\"extension\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param suffix - The expression representing the postfix.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  fieldName: string,\n  suffix: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields ends with \"Jr.\"\n * endsWith(field(\"fullName\"), \"Jr.\");\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  stringExpression: Expression,\n  suffix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields ends with \"Jr.\"\n * endsWith(field(\"fullName\"), constant(\"Jr.\"));\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  stringExpression: Expression,\n  suffix: Expression\n): BooleanExpression;\nexport function endsWith(\n  expr: Expression | string,\n  suffix: Expression | string\n): BooleanExpression {\n  return fieldOrExpression(expr).endsWith(valueToDefaultExpr(suffix));\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a string field to lowercase.\n *\n * @example\n * ```typescript\n * // Convert the 'name' field to lowercase\n * toLower(\"name\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the lowercase string.\n */\nexport function toLower(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a string expression to lowercase.\n *\n * @example\n * ```typescript\n * // Convert the 'name' field to lowercase\n * toLower(field(\"name\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to convert to lowercase.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the lowercase string.\n */\nexport function toLower(stringExpression: Expression): FunctionExpression;\nexport function toLower(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).toLower();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a string field to uppercase.\n *\n * @example\n * ```typescript\n * // Convert the 'title' field to uppercase\n * toUpper(\"title\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the uppercase string.\n */\nexport function toUpper(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a string expression to uppercase.\n *\n * @example\n * ```typescript\n * // Convert the 'title' field to uppercase\n * toUppercase(field(\"title\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to convert to uppercase.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the uppercase string.\n */\nexport function toUpper(stringExpression: Expression): FunctionExpression;\nexport function toUpper(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).toUpper();\n}\n\n/**\n * @beta\n *\n * Creates an expression that removes leading and trailing whitespace from a string or byte array.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the 'userInput' field\n * trim(\"userInput\");\n *\n * // Trim quotes from the 'userInput' field\n * trim(\"userInput\", '\"');\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n * trimmed from the input. If not specified, then whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string.\n */\nexport function trim(\n  fieldName: string,\n  valueToTrim?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that removes leading and trailing characters from a string or byte array expression.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the 'userInput' field\n * trim(field(\"userInput\"));\n *\n * // Trim quotes from the 'userInput' field\n * trim(field(\"userInput\"), '\"');\n * ```\n *\n * @param stringExpression - The expression representing the string or byte array to trim.\n * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n * trimmed from the input. If not specified, then whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string or byte array.\n */\nexport function trim(\n  stringExpression: Expression,\n  valueToTrim?: string | Expression\n): FunctionExpression;\nexport function trim(\n  expr: Expression | string,\n  valueToTrim?: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(expr).trim(valueToTrim);\n}\n\n/**\n * @beta\n *\n * Creates an expression that concatenates string functions, fields or constants together.\n *\n * @example\n * ```typescript\n * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n * stringConcat(\"firstName\", \" \", field(\"lastName\"));\n * ```\n *\n * @param fieldName - The field name containing the initial string value.\n * @param secondString - An expression or string literal to concatenate.\n * @param otherStrings - Optional additional expressions or literals (typically strings) to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated string.\n */\nexport function stringConcat(\n  fieldName: string,\n  secondString: Expression | string,\n  ...otherStrings: Array<Expression | string>\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that concatenates string expressions together.\n *\n * @example\n * ```typescript\n * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n * stringConcat(field(\"firstName\"), \" \", field(\"lastName\"));\n * ```\n *\n * @param firstString - The initial string expression to concatenate to.\n * @param secondString - An expression or string literal to concatenate.\n * @param otherStrings - Optional additional expressions or literals (typically strings) to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated string.\n */\nexport function stringConcat(\n  firstString: Expression,\n  secondString: Expression | string,\n  ...otherStrings: Array<Expression | string>\n): FunctionExpression;\nexport function stringConcat(\n  first: string | Expression,\n  second: string | Expression,\n  ...elements: Array<string | Expression>\n): FunctionExpression {\n  return fieldOrExpression(first).stringConcat(\n    valueToDefaultExpr(second),\n    ...elements.map(valueToDefaultExpr)\n  );\n}\n\n/**\n * @beta\n *\n * Accesses a value from a map (object) field using the provided key.\n *\n * @example\n * ```typescript\n * // Get the 'city' value from the 'address' map field\n * mapGet(\"address\", \"city\");\n * ```\n *\n * @param fieldName - The field name of the map field.\n * @param subField - The key to access in the map.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the value associated with the given key in the map.\n */\nexport function mapGet(fieldName: string, subField: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Accesses a value from a map (object) expression using the provided key.\n *\n * @example\n * ```typescript\n * // Get the 'city' value from the 'address' map field\n * mapGet(field(\"address\"), \"city\");\n * ```\n *\n * @param mapExpression - The expression representing the map.\n * @param subField - The key to access in the map.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the value associated with the given key in the map.\n */\nexport function mapGet(\n  mapExpression: Expression,\n  subField: string\n): FunctionExpression;\nexport function mapGet(\n  fieldOrExpr: string | Expression,\n  subField: string\n): FunctionExpression {\n  return fieldOrExpression(fieldOrExpr).mapGet(subField);\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that counts the total number of stage inputs.\n *\n * @example\n * ```typescript\n * // Count the total number of input documents\n * countAll().as(\"totalDocument\");\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'countAll' aggregation.\n */\nexport function countAll(): AggregateFunction {\n  return AggregateFunction._create('count', [], 'count');\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that counts the number of stage inputs with valid evaluations of the\n * provided expression.\n *\n * @example\n * ```typescript\n * // Count the number of items where the price is greater than 10\n * count(field(\"price\").greaterThan(10)).as(\"expensiveItemCount\");\n * ```\n *\n * @param expression - The expression to count.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'count' aggregation.\n */\nexport function count(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n * Creates an aggregation that counts the number of stage inputs where the input field exists.\n *\n * @example\n * ```typescript\n * // Count the total number of products\n * count(\"productId\").as(\"totalProducts\");\n * ```\n *\n * @param fieldName - The name of the field to count.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'count' aggregation.\n */\nexport function count(fieldName: string): AggregateFunction;\nexport function count(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).count();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the sum of values from an expression across multiple\n * stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the total revenue from a set of orders\n * sum(field(\"orderAmount\")).as(\"totalRevenue\");\n * ```\n *\n * @param expression - The expression to sum up.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'sum' aggregation.\n */\nexport function sum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the sum of a field's values across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Calculate the total revenue from a set of orders\n * sum(\"orderAmount\").as(\"totalRevenue\");\n * ```\n *\n * @param fieldName - The name of the field containing numeric values to sum up.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'sum' aggregation.\n */\nexport function sum(fieldName: string): AggregateFunction;\nexport function sum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).sum();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the average (mean) of values from an expression across\n * multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the average age of users\n * average(field(\"age\")).as(\"averageAge\");\n * ```\n *\n * @param expression - The expression representing the values to average.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'average' aggregation.\n */\nexport function average(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the average (mean) of a field's values across multiple\n * stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the average age of users\n * average(\"age\").as(\"averageAge\");\n * ```\n *\n * @param fieldName - The name of the field containing numeric values to average.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'average' aggregation.\n */\nexport function average(fieldName: string): AggregateFunction;\nexport function average(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).average();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the minimum value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the lowest price of all products\n * minimum(field(\"price\")).as(\"lowestPrice\");\n * ```\n *\n * @param expression - The expression to find the minimum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'minimum' aggregation.\n */\nexport function minimum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the minimum value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the lowest price of all products\n * minimum(\"price\").as(\"lowestPrice\");\n * ```\n *\n * @param fieldName - The name of the field to find the minimum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'minimum' aggregation.\n */\nexport function minimum(fieldName: string): AggregateFunction;\nexport function minimum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).minimum();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the maximum value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the highest score in a leaderboard\n * maximum(field(\"score\")).as(\"highestScore\");\n * ```\n *\n * @param expression - The expression to find the maximum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'maximum' aggregation.\n */\nexport function maximum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the maximum value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the highest score in a leaderboard\n * maximum(\"score\").as(\"highestScore\");\n * ```\n *\n * @param fieldName - The name of the field to find the maximum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'maximum' aggregation.\n */\nexport function maximum(fieldName: string): AggregateFunction;\nexport function maximum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).maximum();\n}\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a field's vector value and a literal vector value.\n *\n * @example\n * ```typescript\n * // Calculate the Cosine distance between the 'location' field and a target location\n * cosineDistance(\"location\", [37.7749, -122.4194]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles) or {@link VectorValue} to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n * cosineDistance(\"userVector\", field(\"itemVector\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a vector expression and a vector literal.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'location' field and a target location\n * cosineDistance(field(\"location\"), [37.7749, -122.4194]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n * cosineDistance(field(\"userVector\"), field(\"itemVector\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function cosineDistance(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.cosineDistance(expr2);\n}\n\n/**\n * @beta\n *\n * Calculates the dot product between a field's vector value and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the dot product distance between a feature vector and a target vector\n * dotProduct(\"features\", [0.5, 0.8, 0.2]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles or VectorValue) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the dot product distance between two document vectors: 'docVector1' and 'docVector2'\n * dotProduct(\"docVector1\", field(\"docVector2\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between a vector expression and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the dot product between a feature vector and a target vector\n * dotProduct(field(\"features\"), [0.5, 0.8, 0.2]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to calculate with.\n * @param vector - The other vector (as an array of doubles or VectorValue) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the dot product between two document vectors: 'docVector1' and 'docVector2'\n * dotProduct(field(\"docVector1\"), field(\"docVector2\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to calculate with.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function dotProduct(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.dotProduct(expr2);\n}\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a field's vector value and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between the 'location' field and a target location\n * euclideanDistance(\"location\", [37.7749, -122.4194]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between two vector fields: 'pointA' and 'pointB'\n * euclideanDistance(\"pointA\", field(\"pointB\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a vector expression and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between the 'location' field and a target location\n *\n * euclideanDistance(field(\"location\"), [37.7749, -122.4194]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between two vector fields: 'pointA' and 'pointB'\n * euclideanDistance(field(\"pointA\"), field(\"pointB\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function euclideanDistance(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.euclideanDistance(expr2);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a Firestore Vector.\n *\n * @example\n * ```typescript\n * // Get the vector length (dimension) of the field 'embedding'.\n * vectorLength(field(\"embedding\"));\n * ```\n *\n * @param vectorExpression - The expression representing the Firestore Vector.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function vectorLength(vectorExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a Firestore Vector represented by a field.\n *\n * @example\n * ```typescript\n * // Get the vector length (dimension) of the field 'embedding'.\n * vectorLength(\"embedding\");\n * ```\n *\n * @param fieldName - The name of the field representing the Firestore Vector.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function vectorLength(fieldName: string): FunctionExpression;\nexport function vectorLength(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).vectorLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'microseconds' field as microseconds since epoch.\n * unixMicrosToTimestamp(field(\"microseconds\"));\n * ```\n *\n * @param expr - The expression representing the number of microseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMicrosToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'microseconds' field as microseconds since epoch.\n * unixMicrosToTimestamp(\"microseconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of microseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMicrosToTimestamp(fieldName: string): FunctionExpression;\nexport function unixMicrosToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expr).unixMicrosToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to microseconds since epoch.\n * timestampToUnixMicros(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n */\nexport function timestampToUnixMicros(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to microseconds since epoch.\n * timestampToUnixMicros(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n */\nexport function timestampToUnixMicros(fieldName: string): FunctionExpression;\nexport function timestampToUnixMicros(\n  expr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expr).timestampToUnixMicros();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'milliseconds' field as milliseconds since epoch.\n * unixMillisToTimestamp(field(\"milliseconds\"));\n * ```\n *\n * @param expr - The expression representing the number of milliseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMillisToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'milliseconds' field as milliseconds since epoch.\n * unixMillisToTimestamp(\"milliseconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of milliseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMillisToTimestamp(fieldName: string): FunctionExpression;\nexport function unixMillisToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.unixMillisToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to milliseconds since epoch.\n * timestampToUnixMillis(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n */\nexport function timestampToUnixMillis(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to milliseconds since epoch.\n * timestampToUnixMillis(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n */\nexport function timestampToUnixMillis(fieldName: string): FunctionExpression;\nexport function timestampToUnixMillis(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.timestampToUnixMillis();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'seconds' field as seconds since epoch.\n * unixSecondsToTimestamp(field(\"seconds\"));\n * ```\n *\n * @param expr - The expression representing the number of seconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixSecondsToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'seconds' field as seconds since epoch.\n * unixSecondsToTimestamp(\"seconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of seconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixSecondsToTimestamp(fieldName: string): FunctionExpression;\nexport function unixSecondsToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.unixSecondsToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to seconds since epoch.\n * timestampToUnixSeconds(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n */\nexport function timestampToUnixSeconds(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to seconds since epoch.\n * timestampToUnixSeconds(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n */\nexport function timestampToUnixSeconds(fieldName: string): FunctionExpression;\nexport function timestampToUnixSeconds(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.timestampToUnixSeconds();\n}\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp.\n *\n * @example\n * ```typescript\n * // Add some duration determined by field 'unit' and 'amount' to the 'timestamp' field.\n * timestampAdd(field(\"timestamp\"), field(\"unit\"), field(\"amount\"));\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n * @param amount - The expression evaluates to amount of the unit.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  timestamp: Expression,\n  unit: Expression,\n  amount: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp.\n *\n * @example\n * ```typescript\n * // Add 1 day to the 'timestamp' field.\n * timestampAdd(field(\"timestamp\"), \"day\", 1);\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  timestamp: Expression,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp represented by a field.\n *\n * @example\n * ```typescript\n * // Add 1 day to the 'timestamp' field.\n * timestampAdd(\"timestamp\", \"day\", 1);\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  fieldName: string,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\nexport function timestampAdd(\n  timestamp: Expression | string,\n  unit:\n    | Expression\n    | 'microsecond'\n    | 'millisecond'\n    | 'second'\n    | 'minute'\n    | 'hour'\n    | 'day',\n  amount: Expression | number\n): FunctionExpression {\n  const normalizedTimestamp = fieldOrExpression(timestamp);\n  const normalizedUnit = valueToDefaultExpr(unit);\n  const normalizedAmount = valueToDefaultExpr(amount);\n  return normalizedTimestamp.timestampAdd(normalizedUnit, normalizedAmount);\n}\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp.\n *\n * @example\n * ```typescript\n * // Subtract some duration determined by field 'unit' and 'amount' from the 'timestamp' field.\n * timestampSubtract(field(\"timestamp\"), field(\"unit\"), field(\"amount\"));\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n * @param amount - The expression evaluates to amount of the unit.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  timestamp: Expression,\n  unit: Expression,\n  amount: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp.\n *\n * @example\n * ```typescript\n * // Subtract 1 day from the 'timestamp' field.\n * timestampSubtract(field(\"timestamp\"), \"day\", 1);\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  timestamp: Expression,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp represented by a field.\n *\n * @example\n * ```typescript\n * // Subtract 1 day from the 'timestamp' field.\n * timestampSubtract(\"timestamp\", \"day\", 1);\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  fieldName: string,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\nexport function timestampSubtract(\n  timestamp: Expression | string,\n  unit:\n    | Expression\n    | 'microsecond'\n    | 'millisecond'\n    | 'second'\n    | 'minute'\n    | 'hour'\n    | 'day',\n  amount: Expression | number\n): FunctionExpression {\n  const normalizedTimestamp = fieldOrExpression(timestamp);\n  const normalizedUnit = valueToDefaultExpr(unit);\n  const normalizedAmount = valueToDefaultExpr(amount);\n  return normalizedTimestamp.timestampSubtract(\n    normalizedUnit,\n    normalizedAmount\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that evaluates to the current server timestamp.\n *\n * @example\n * ```typescript\n * // Get the current server timestamp\n * currentTimestamp()\n * ```\n *\n * @returns A new Expression representing the current server timestamp.\n */\nexport function currentTimestamp(): FunctionExpression {\n  return new FunctionExpression('current_timestamp', [], 'currentTimestamp');\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'AND' operation on multiple filter conditions.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18 AND the 'city' field is \"London\" AND\n * // the 'status' field is \"active\"\n * const condition = and(greaterThan(\"age\", 18), equal(\"city\", \"London\"), equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first filter condition.\n * @param second - The second filter condition.\n * @param more - Additional filter conditions to 'AND' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'AND' operation.\n */\nexport function and(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...more: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'and',\n    [first, second, ...more],\n    'and'\n  ).asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'OR' operation on multiple filter conditions.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18 OR the 'city' field is \"London\" OR\n * // the 'status' field is \"active\"\n * const condition = or(greaterThan(\"age\", 18), equal(\"city\", \"London\"), equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first filter condition.\n * @param second - The second filter condition.\n * @param more - Additional filter conditions to 'OR' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'OR' operation.\n */\nexport function or(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...more: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'or',\n    [first, second, ...more],\n    'xor'\n  ).asBoolean();\n}\n\n/**\n * @beta\n * Creates an expression that returns the value of the base expression raised to the power of the exponent expression.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of the 'exponent' field.\n * pow(field(\"base\"), field(\"exponent\"));\n * ```\n *\n * @param base - The expression to raise to the power of the exponent.\n * @param exponent - The expression to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: Expression, exponent: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base expression raised to the power of the exponent.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of 2.\n * pow(field(\"base\"), 2);\n * ```\n *\n * @param base - The expression to raise to the power of the exponent.\n * @param exponent - The constant value to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: Expression, exponent: number): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base field raised to the power of the exponent expression.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of the 'exponent' field.\n * pow(\"base\", field(\"exponent\"));\n * ```\n *\n * @param base - The name of the field to raise to the power of the exponent.\n * @param exponent - The expression to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: string, exponent: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base field raised to the power of the exponent.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of 2.\n * pow(\"base\", 2);\n * ```\n *\n * @param base - The name of the field to raise to the power of the exponent.\n * @param exponent - The constant value to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: string, exponent: number): FunctionExpression;\nexport function pow(\n  base: Expression | string,\n  exponent: Expression | number\n): FunctionExpression {\n  return fieldOrExpression(base).pow(exponent as number);\n}\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the nearest whole number.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field.\n * round(\"price\");\n * ```\n *\n * @param fieldName - The name of the field to round.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the nearest whole number.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field.\n * round(field(\"price\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be rounded.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field to two decimal places.\n * round(\"price\", 2);\n * ```\n *\n * @param fieldName - The name of the field to round.\n * @param decimalPlaces - A constant or expression specifying the rounding precision in decimal places.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(\n  fieldName: string,\n  decimalPlaces: number | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field to two decimal places.\n * round(field(\"price\"), constant(2));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be rounded.\n * @param decimalPlaces - A constant or expression specifying the rounding precision in decimal places.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(\n  expression: Expression,\n  decimalPlaces: number | Expression\n): FunctionExpression;\nexport function round(\n  expr: Expression | string,\n  decimalPlaces?: number | Expression\n): FunctionExpression {\n  if (decimalPlaces === undefined) {\n    return fieldOrExpression(expr).round();\n  } else {\n    return fieldOrExpression(expr).round(valueToDefaultExpr(decimalPlaces));\n  }\n}\n\n/**\n * @beta\n * Creates an expression that returns the collection ID from a path.\n *\n * @example\n * ```typescript\n * // Get the collection ID from a path.\n * collectionId(\"__name__\");\n * ```\n *\n * @param fieldName - The name of the field to get the collection ID from.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n */\nexport function collectionId(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the collection ID from a path.\n *\n * @example\n * ```typescript\n * // Get the collection ID from a path.\n * collectionId(field(\"__name__\"));\n * ```\n *\n * @param expression - An expression evaluating to a path, which the collection ID will be extracted from.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n */\nexport function collectionId(expression: Expression): FunctionExpression;\nexport function collectionId(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).collectionId();\n}\n\n/**\n * @beta\n * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n *\n * @example\n * ```typescript\n * // Get the length of the 'name' field.\n * length(\"name\");\n *\n * // Get the number of items in the 'cart' array.\n * length(\"cart\");\n * ```\n *\n * @param fieldName - The name of the field to calculate the length of.\n * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n */\nexport function length(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n *\n * @example\n * ```typescript\n * // Get the length of the 'name' field.\n * length(field(\"name\"));\n *\n * // Get the number of items in the 'cart' array.\n * length(field(\"cart\"));\n * ```\n *\n * @param expression - An expression evaluating to a string, array, map, vector, or bytes, which the length will be calculated for.\n * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n */\nexport function length(expression: Expression): FunctionExpression;\nexport function length(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).length();\n}\n\n/**\n * @beta\n * Creates an expression that computes the natural logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the natural logarithm of the 'value' field.\n * ln(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the natural logarithm of.\n * @returns A new `Expression` representing the natural logarithm of the numeric value.\n */\nexport function ln(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the natural logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the natural logarithm of the 'value' field.\n * ln(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the natural logarithm will be computed for.\n * @returns A new `Expression` representing the natural logarithm of the numeric value.\n */\nexport function ln(expression: Expression): FunctionExpression;\nexport function ln(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).ln();\n}\n\n/**\n * @beta\n * Creates an expression that computes the logarithm of an expression to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with base 10.\n * log(field(\"value\"), 10);\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the logarithm will be computed for.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(expression: Expression, base: number): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of an expression to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with the base in the 'base' field.\n * log(field(\"value\"), field(\"base\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the logarithm will be computed for.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(\n  expression: Expression,\n  base: Expression\n): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of a field to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with base 10.\n * log(\"value\", 10);\n * ```\n *\n * @param fieldName - The name of the field to compute the logarithm of.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(fieldName: string, base: number): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of a field to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with the base in the 'base' field.\n * log(\"value\", field(\"base\"));\n * ```\n *\n * @param fieldName - The name of the field to compute the logarithm of.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(fieldName: string, base: Expression): FunctionExpression;\nexport function log(\n  expr: Expression | string,\n  base: number | Expression\n): FunctionExpression {\n  return new FunctionExpression('log', [\n    fieldOrExpression(expr),\n    valueToDefaultExpr(base)\n  ]);\n}\n\n/**\n * @beta\n * Creates an expression that computes the square root of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the square root of the 'value' field.\n * sqrt(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the square root will be computed for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n */\nexport function sqrt(expression: Expression): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the square root of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the square root of the 'value' field.\n * sqrt(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the square root of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n */\nexport function sqrt(fieldName: string): FunctionExpression;\nexport function sqrt(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).sqrt();\n}\n\n/**\n * @beta\n * Creates an expression that reverses a string.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * strReverse(field(\"myString\"));\n * ```\n *\n * @param stringExpression - An expression evaluating to a string value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function stringReverse(stringExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that reverses a string value in the specified field.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * strReverse(\"myString\");\n * ```\n *\n * @param field - The name of the field representing the string to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function stringReverse(field: string): FunctionExpression;\nexport function stringReverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).stringReverse();\n}\n\n/**\n * @beta\n * Creates an expression that concatenates strings, arrays, or blobs. Types cannot be mixed.\n *\n * @example\n * ```typescript\n * // Concatenate the 'firstName' and 'lastName' fields with a space in between.\n * concat(field(\"firstName\"), \" \", field(\"lastName\"))\n * ```\n *\n * @param first - The first expressions to concatenate.\n * @param second - The second literal or expression to concatenate.\n * @param others - Additional literals or expressions to concatenate.\n * @returns A new `Expression` representing the concatenation.\n */\nexport function concat(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that concatenates strings, arrays, or blobs. Types cannot be mixed.\n *\n * @example\n * ```typescript\n * // Concatenate a field with a literal string.\n * concat(field(\"firstName\"), \"Doe\")\n * ```\n *\n * @param fieldName - The name of a field to concatenate.\n * @param second - The second literal or expression to concatenate.\n * @param others - Additional literal or expressions to concatenate.\n * @returns A new `Expression` representing the concatenation.\n */\nexport function concat(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function concat(\n  fieldNameOrExpression: string | Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return new FunctionExpression('concat', [\n    fieldOrExpression(fieldNameOrExpression),\n    valueToDefaultExpr(second),\n    ...others.map(valueToDefaultExpr)\n  ]);\n}\n\n/**\n * @beta\n * Creates an expression that computes the absolute value of a numeric value.\n *\n * @param expr - The expression to compute the absolute value of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n */\nexport function abs(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the absolute value of a numeric value.\n *\n * @param fieldName - The field to compute the absolute value of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n */\nexport function abs(fieldName: string): FunctionExpression;\nexport function abs(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).abs();\n}\n\n/**\n * @beta\n * Creates an expression that returns the `elseExpr` argument if `ifExpr` is absent, else return\n * the result of the `ifExpr` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(field(\"optional_field\"), constant(\"default_value\"))\n * ```\n *\n * @param ifExpr - The expression to check for absence.\n * @param elseExpr - The expression that will be evaluated and returned if [ifExpr] is absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(ifExpr: Expression, elseExpr: Expression): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseValue` argument if `ifExpr` is absent, else\n * return the result of the `ifExpr` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(field(\"optional_field\"), \"default_value\")\n * ```\n *\n * @param ifExpr - The expression to check for absence.\n * @param elseValue - The value that will be returned if `ifExpr` evaluates to an absent value.\n * @returns A new [Expression] representing the ifAbsent operation.\n */\nexport function ifAbsent(ifExpr: Expression, elseValue: unknown): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseExpr` argument if `ifFieldName` is absent, else\n * return the value of the field.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns the value of\n * // 'default_field' if 'optional_field' is absent.\n * ifAbsent(\"optional_field\", field(\"default_field\"))\n * ```\n *\n * @param ifFieldName - The field to check for absence.\n * @param elseExpr - The expression that will be evaluated and returned if `ifFieldName` is\n * absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(ifFieldName: string, elseExpr: Expression): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseValue` argument if `ifFieldName` is absent, else\n * return the value of the field.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(\"optional_field\", \"default_value\")\n * ```\n *\n * @param ifFieldName - The field to check for absence.\n * @param elseValue - The value that will be returned if [ifFieldName] is absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(\n  ifFieldName: string | Expression,\n  elseValue: Expression | unknown\n): Expression;\nexport function ifAbsent(\n  fieldNameOrExpression: string | Expression,\n  elseValue: Expression | unknown\n): Expression {\n  return fieldOrExpression(fieldNameOrExpression).ifAbsent(\n    valueToDefaultExpr(elseValue)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with a comma and space.\n * join(\"tags\", \", \")\n * ```\n *\n * @param arrayFieldName - The name of the field containing the array.\n * @param delimiter - The string to use as a delimiter.\n * @returns A new Expression representing the join operation.\n */\nexport function join(arrayFieldName: string, delimiter: string): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join an array of string using the delimiter from the 'separator' field.\n * join(array(['foo', 'bar']), field(\"separator\"))\n * ```\n *\n * @param arrayExpression - An expression that evaluates to an array.\n * @param delimiterExpression - The expression that evaluates to the delimiter string.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayExpression: Expression,\n  delimiterExpression: Expression\n): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with a comma and space.\n * join(field(\"tags\"), \", \")\n * ```\n *\n * @param arrayExpression - An expression that evaluates to an array.\n * @param delimiter - The string to use as a delimiter.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayExpression: Expression,\n  delimiter: string\n): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with the delimiter from the 'separator' field.\n * join('tags', field(\"separator\"))\n * ```\n *\n * @param arrayFieldName - The name of the field containing the array.\n * @param delimiterExpression - The expression that evaluates to the delimiter string.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayFieldName: string,\n  delimiterExpression: Expression\n): Expression;\nexport function join(\n  fieldNameOrExpression: string | Expression,\n  delimiterValueOrExpression: Expression | string\n): Expression {\n  return fieldOrExpression(fieldNameOrExpression).join(\n    valueToDefaultExpr(delimiterValueOrExpression)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that computes the base-10 logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the base-10 logarithm of the 'value' field.\n * log10(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the base-10 logarithm of.\n * @returns A new `Expression` representing the base-10 logarithm of the numeric value.\n */\nexport function log10(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the base-10 logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the base-10 logarithm of the 'value' field.\n * log10(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the base-10 logarithm will be computed for.\n * @returns A new `Expression` representing the base-10 logarithm of the numeric value.\n */\nexport function log10(expression: Expression): FunctionExpression;\nexport function log10(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).log10();\n}\n\n/**\n * @beta\n * Creates an expression that computes the sum of the elements in an array.\n *\n * @example\n * ```typescript\n * // Compute the sum of the elements in the 'scores' field.\n * arraySum(\"scores\");\n * ```\n *\n * @param fieldName - The name of the field to compute the sum of.\n * @returns A new `Expression` representing the sum of the elements in the array.\n */\nexport function arraySum(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the sum of the elements in an array.\n *\n * @example\n * ```typescript\n * // Compute the sum of the elements in the 'scores' field.\n * arraySum(field(\"scores\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric array, which the sum will be computed for.\n * @returns A new `Expression` representing the sum of the elements in the array.\n */\nexport function arraySum(expression: Expression): FunctionExpression;\nexport function arraySum(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).arraySum();\n}\n\n/**\n * @beta\n * Creates an expression that splits the value of a field on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scoresCsv' field on delimiter ','\n * split('scoresCsv', ',')\n * ```\n *\n * @param fieldName - Split the value in this field.\n * @param delimiter - Split on this delimiter.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(fieldName: string, delimiter: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits the value of a field on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n * split('scores', conditional(field('format').equal('csv'), constant(','), constant(':'))\n * ```\n *\n * @param fieldName - Split the value in this field.\n * @param delimiter - Split on this delimiter returned by evaluating this expression.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  fieldName: string,\n  delimiter: Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits a string into an array of substrings based on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scoresCsv' field on delimiter ','\n * split(field('scoresCsv'), ',')\n * ```\n *\n * @param expression - Split the result of this expression.\n * @param delimiter - Split on this delimiter.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  expression: Expression,\n  delimiter: string\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits a string into an array of substrings based on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n * split(field('scores'), conditional(field('format').equal('csv'), constant(','), constant(':'))\n * ```\n *\n * @param expression - Split the result of this expression.\n * @param delimiter - Split on this delimiter returned by evaluating this expression.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  expression: Expression,\n  delimiter: Expression\n): FunctionExpression;\nexport function split(\n  fieldNameOrExpression: string | Expression,\n  delimiter: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldNameOrExpression).split(\n    valueToDefaultExpr(delimiter)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the beginning of the day.\n * field('createdAt').timestampTruncate('day')\n * ```\n *\n * @param fieldName - Truncate the timestamp value contained in this field.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  fieldName: string,\n  granularity: TimeGranularity,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n * field('createdAt').timestampTruncate(field('granularity'))\n * ```\n *\n * @param fieldName - Truncate the timestamp value contained in this field.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  fieldName: string,\n  granularity: Expression,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the beginning of the day.\n * field('createdAt').timestampTruncate('day')\n * ```\n *\n * @param timestampExpression - Truncate the timestamp value that is returned by this expression.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  timestampExpression: Expression,\n  granularity: TimeGranularity,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n * field('createdAt').timestampTruncate(field('granularity'))\n * ```\n *\n * @param timestampExpression - Truncate the timestamp value that is returned by this expression.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  timestampExpression: Expression,\n  granularity: Expression,\n  timezone?: string | Expression\n): FunctionExpression;\nexport function timestampTruncate(\n  fieldNameOrExpression: string | Expression,\n  granularity: TimeGranularity | Expression,\n  timezone?: string | Expression\n): FunctionExpression {\n  const internalGranularity = isString(granularity)\n    ? valueToDefaultExpr(granularity.toLowerCase())\n    : granularity;\n  return fieldOrExpression(fieldNameOrExpression).timestampTruncate(\n    internalGranularity,\n    timezone\n  );\n}\n\n/**\n * @beta\n * Creates an expression that returns the data type of the data in the specified field.\n *\n * @example\n * ```typescript\n * // Get the data type of the value in field 'title'\n * type('title')\n * ```\n *\n * @returns A new `Expression` representing the data type.\n */\nexport function type(fieldName: string): FunctionExpression;\n/**\n * @beta\n * Creates an expression that returns the data type of an expression's result.\n *\n * @example\n * ```typescript\n * // Get the data type of a conditional expression\n * type(conditional(exists('foo'), constant(1), constant(true)))\n * ```\n *\n * @returns A new `Expression` representing the data type.\n */\nexport function type(expression: Expression): FunctionExpression;\nexport function type(\n  fieldNameOrExpression: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldNameOrExpression).type();\n}\n\n// TODO(new-expression): Add new top-level expression function definitions above this line\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on an expression.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in lowercase in ascending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(ascending(field(\"name\").toLower()));\n * ```\n *\n * @param expr - The expression to create an ascending ordering for.\n * @returns A new `Ordering` for ascending sorting.\n */\nexport function ascending(expr: Expression): Ordering;\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on a field.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in ascending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(ascending(\"name\"));\n * ```\n *\n * @param fieldName - The field to create an ascending ordering for.\n * @returns A new `Ordering` for ascending sorting.\n */\nexport function ascending(fieldName: string): Ordering;\nexport function ascending(field: Expression | string): Ordering {\n  return new Ordering(fieldOrExpression(field), 'ascending', 'ascending');\n}\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on an expression.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in lowercase in descending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(descending(field(\"name\").toLower()));\n * ```\n *\n * @param expr - The expression to create a descending ordering for.\n * @returns A new `Ordering` for descending sorting.\n */\nexport function descending(expr: Expression): Ordering;\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on a field.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in descending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(descending(\"name\"));\n * ```\n *\n * @param fieldName - The field to create a descending ordering for.\n * @returns A new `Ordering` for descending sorting.\n */\nexport function descending(fieldName: string): Ordering;\nexport function descending(field: Expression | string): Ordering {\n  return new Ordering(fieldOrExpression(field), 'descending', 'descending');\n}\n\n/**\n * @beta\n *\n * Represents an ordering criterion for sorting documents in a Firestore pipeline.\n *\n * You create `Ordering` instances using the `ascending` and `descending` helper functions.\n */\nexport class Ordering implements ProtoValueSerializable, UserData {\n  constructor(\n    public readonly expr: Expression,\n    public readonly direction: 'ascending' | 'descending',\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      mapValue: {\n        fields: {\n          direction: toStringValue(this.direction),\n          expression: this.expr._toProto(serializer)\n        }\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.expr._readUserData(context);\n  }\n\n  _protoValueType: 'ProtoValue' = 'ProtoValue';\n}\n\nexport function isSelectable(val: unknown): val is Selectable {\n  const candidate = val as Selectable;\n  return (\n    candidate.selectable && isString(candidate.alias) && isExpr(candidate.expr)\n  );\n}\n\nexport function isOrdering(val: unknown): val is Ordering {\n  const candidate = val as Ordering;\n  return (\n    isExpr(candidate.expr) &&\n    (candidate.direction === 'ascending' ||\n      candidate.direction === 'descending')\n  );\n}\n\nexport function isAliasedAggregate(val: unknown): val is AliasedAggregate {\n  const candidate = val as AliasedAggregate;\n  return (\n    isString(candidate.alias) &&\n    candidate.aggregate instanceof AggregateFunction\n  );\n}\n\nexport function isExpr(val: unknown): val is Expression {\n  return val instanceof Expression;\n}\n\nexport function isBooleanExpr(val: unknown): val is BooleanExpression {\n  return val instanceof BooleanExpression;\n}\n\nexport function isField(val: unknown): val is Field {\n  return val instanceof Field;\n}\n\nexport function toField(value: string | Field): Field {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return value as Field;\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Firestore } from '../lite-api/database';\nimport {\n  Constant,\n  BooleanExpression,\n  and,\n  or,\n  Ordering,\n  lessThan,\n  greaterThan,\n  field\n} from '../lite-api/expressions';\nimport { Pipeline } from '../lite-api/pipeline';\nimport { doc } from '../lite-api/reference';\nimport { fail } from '../util/assert';\n\nimport { Bound } from './bound';\nimport {\n  CompositeFilter as CompositeFilterInternal,\n  CompositeOperator,\n  FieldFilter as FieldFilterInternal,\n  Filter as FilterInternal,\n  Operator\n} from './filter';\nimport { Direction } from './order_by';\nimport {\n  isCollectionGroupQuery,\n  isDocumentQuery,\n  LimitType,\n  Query,\n  queryNormalizedOrderBy\n} from './query';\n\n/* eslint @typescript-eslint/no-explicit-any: 0 */\n\nexport function toPipelineBooleanExpr(f: FilterInternal): BooleanExpression {\n  if (f instanceof FieldFilterInternal) {\n    const fieldValue = field(f.field.toString());\n    // Comparison filters\n    const value = f.value;\n    switch (f.op) {\n      case Operator.LESS_THAN:\n        return and(\n          fieldValue.exists(),\n          fieldValue.lessThan(Constant._fromProto(value))\n        );\n      case Operator.LESS_THAN_OR_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.lessThanOrEqual(Constant._fromProto(value))\n        );\n      case Operator.GREATER_THAN:\n        return and(\n          fieldValue.exists(),\n          fieldValue.greaterThan(Constant._fromProto(value))\n        );\n      case Operator.GREATER_THAN_OR_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.greaterThanOrEqual(Constant._fromProto(value))\n        );\n      case Operator.EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.equal(Constant._fromProto(value))\n        );\n      case Operator.NOT_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.notEqual(Constant._fromProto(value))\n        );\n      case Operator.ARRAY_CONTAINS:\n        return and(\n          fieldValue.exists(),\n          fieldValue.arrayContains(Constant._fromProto(value))\n        );\n      case Operator.IN: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        if (!values) {\n          return and(fieldValue.exists(), fieldValue.equalAny([]));\n        } else if (values.length === 1) {\n          return and(fieldValue.exists(), fieldValue.equal(values[0]));\n        } else {\n          return and(fieldValue.exists(), fieldValue.equalAny(values));\n        }\n      }\n      case Operator.ARRAY_CONTAINS_ANY: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        return and(fieldValue.exists(), fieldValue.arrayContainsAny(values!));\n      }\n      case Operator.NOT_IN: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        if (!values) {\n          return and(fieldValue.exists(), fieldValue.notEqualAny([]));\n        } else if (values.length === 1) {\n          return and(fieldValue.exists(), fieldValue.notEqual(values[0]));\n        } else {\n          return and(fieldValue.exists(), fieldValue.notEqualAny(values));\n        }\n      }\n      default:\n        fail(0x9047, 'Unexpected operator');\n    }\n  } else if (f instanceof CompositeFilterInternal) {\n    switch (f.op) {\n      case CompositeOperator.AND: {\n        const conditions = f.getFilters().map(f => toPipelineBooleanExpr(f));\n        return and(conditions[0], conditions[1], ...conditions.slice(2));\n      }\n      case CompositeOperator.OR: {\n        const conditions = f.getFilters().map(f => toPipelineBooleanExpr(f));\n        return or(conditions[0], conditions[1], ...conditions.slice(2));\n      }\n      default:\n        fail(0x89ea, 'Unexpected operator');\n    }\n  }\n\n  throw new Error(`Failed to convert filter to pipeline conditions: ${f}`);\n}\n\nfunction reverseOrderings(orderings: Ordering[]): Ordering[] {\n  return orderings.map(\n    o =>\n      new Ordering(\n        o.expr,\n        o.direction === 'ascending' ? 'descending' : 'ascending',\n        undefined\n      )\n  );\n}\n\nexport function toPipeline(query: Query, db: Firestore): Pipeline {\n  let pipeline: Pipeline;\n  if (isCollectionGroupQuery(query)) {\n    pipeline = db.pipeline().collectionGroup(query.collectionGroup!);\n  } else if (isDocumentQuery(query)) {\n    pipeline = db.pipeline().documents([doc(db, query.path.canonicalString())]);\n  } else {\n    pipeline = db.pipeline().collection(query.path.canonicalString());\n  }\n\n  // filters\n  for (const filter of query.filters) {\n    pipeline = pipeline.where(toPipelineBooleanExpr(filter));\n  }\n\n  // orders\n  const orders = queryNormalizedOrderBy(query);\n  const existsConditions = orders.map(order =>\n    field(order.field.canonicalString()).exists()\n  );\n  if (existsConditions.length > 1) {\n    pipeline = pipeline.where(\n      and(\n        existsConditions[0],\n        existsConditions[1],\n        ...existsConditions.slice(2)\n      )\n    );\n  } else {\n    pipeline = pipeline.where(existsConditions[0]);\n  }\n\n  const orderings = orders.map(order =>\n    order.dir === Direction.ASCENDING\n      ? field(order.field.canonicalString()).ascending()\n      : field(order.field.canonicalString()).descending()\n  );\n\n  if (orderings.length > 0) {\n    if (query.limitType === LimitType.Last) {\n      const actualOrderings = reverseOrderings(orderings);\n      pipeline = pipeline.sort(actualOrderings[0], ...actualOrderings.slice(1));\n      // cursors\n      if (query.startAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.startAt, orderings, 'after')\n        );\n      }\n\n      if (query.endAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.endAt, orderings, 'before')\n        );\n      }\n\n      pipeline = pipeline.limit(query.limit!);\n      pipeline = pipeline.sort(orderings[0], ...orderings.slice(1));\n    } else {\n      pipeline = pipeline.sort(orderings[0], ...orderings.slice(1));\n      if (query.startAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.startAt, orderings, 'after')\n        );\n      }\n      if (query.endAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.endAt, orderings, 'before')\n        );\n      }\n\n      if (query.limit !== null) {\n        pipeline = pipeline.limit(query.limit);\n      }\n    }\n  }\n\n  return pipeline;\n}\n\nfunction whereConditionsFromCursor(\n  bound: Bound,\n  orderings: Ordering[],\n  position: 'before' | 'after'\n): BooleanExpression {\n  // The filterFunc is either greater than or less than\n  const filterFunc = position === 'before' ? lessThan : greaterThan;\n  const cursors = bound.position.map(value => Constant._fromProto(value));\n  const size = cursors.length;\n\n  let field = orderings[size - 1].expr;\n  let value = cursors[size - 1];\n\n  // Add condition for last bound\n  let condition: BooleanExpression = filterFunc(field, value);\n  if (bound.inclusive) {\n    // When the cursor bound is inclusive, then the last bound\n    // can be equal to the value, otherwise it's not equal\n    condition = or(condition, field.equal(value));\n  }\n\n  // Iterate backwards over the remaining bounds, adding\n  // a condition for each one\n  for (let i = size - 2; i >= 0; i--) {\n    field = orderings[i].expr;\n    value = cursors[i];\n\n    // For each field in the orderings, the condition is either\n    // a) lt|gt the cursor value,\n    // b) or equal the cursor value and lt|gt the cursor values for other fields\n    condition = or(\n      filterFunc(field, value),\n      and(field.equal(value), condition)\n    );\n  }\n\n  return condition;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParseContext } from '../api/parse_context';\nimport { OptionsUtil } from '../core/options_util';\nimport {\n  ApiClientObjectMap,\n  firestoreV1ApiClientInterfaces,\n  Stage as ProtoStage\n} from '../protos/firestore_proto_api';\nimport { toNumber } from '../remote/number_serializer';\nimport {\n  JsonProtoSerializer,\n  ProtoSerializable,\n  toMapValue,\n  toPipelineValue,\n  toStringValue\n} from '../remote/serializer';\nimport { hardAssert } from '../util/assert';\n\nimport {\n  AggregateFunction,\n  BooleanExpression,\n  Expression,\n  Field,\n  field,\n  Ordering\n} from './expressions';\nimport { Pipeline } from './pipeline';\nimport { StageOptions } from './stage_options';\nimport { isUserData, UserData } from './user_data_reader';\n\n/**\n * @beta\n */\nexport abstract class Stage implements ProtoSerializable<ProtoStage>, UserData {\n  /**\n   * Store optionsProto parsed by _readUserData.\n   * @private\n   * @internal\n   * @protected\n   */\n  protected optionsProto:\n    | ApiClientObjectMap<firestoreV1ApiClientInterfaces.Value>\n    | undefined = undefined;\n  protected knownOptions: Record<string, unknown>;\n  protected rawOptions?: Record<string, unknown>;\n\n  constructor(options: StageOptions) {\n    ({ rawOptions: this.rawOptions, ...this.knownOptions } = options);\n  }\n\n  _readUserData(context: ParseContext): void {\n    this.optionsProto = this._optionsUtil.getOptionsProto(\n      context,\n      this.knownOptions,\n      this.rawOptions\n    );\n  }\n\n  _toProto(_: JsonProtoSerializer): ProtoStage {\n    return {\n      name: this._name,\n      options: this.optionsProto\n    };\n  }\n\n  abstract get _optionsUtil(): OptionsUtil;\n  abstract get _name(): string;\n}\n\n/**\n * @beta\n */\nexport class AddFields extends Stage {\n  get _name(): string {\n    return 'add_fields';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private fields: Map<string, Expression>, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.fields)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.fields, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class RemoveFields extends Stage {\n  get _name(): string {\n    return 'remove_fields';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private fields: Field[], options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.fields.map(f => f._toProto(serializer))\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.fields, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Aggregate extends Stage {\n  get _name(): string {\n    return 'aggregate';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private groups: Map<string, Expression>,\n    private accumulators: Map<string, AggregateFunction>,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        toMapValue(serializer, this.accumulators),\n        toMapValue(serializer, this.groups)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.groups, context);\n    readUserDataHelper(this.accumulators, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Distinct extends Stage {\n  get _name(): string {\n    return 'distinct';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private groups: Map<string, Expression>, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.groups)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.groups, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class CollectionSource extends Stage {\n  get _name(): string {\n    return 'collection';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      forceIndex: {\n        serverName: 'force_index'\n      }\n    });\n  }\n\n  private formattedCollectionPath: string;\n\n  constructor(collection: string, options: StageOptions) {\n    super(options);\n\n    // prepend slash to collection string\n    this.formattedCollectionPath = collection.startsWith('/')\n      ? collection\n      : '/' + collection;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [{ referenceValue: this.formattedCollectionPath }]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class CollectionGroupSource extends Stage {\n  get _name(): string {\n    return 'collection_group';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      forceIndex: {\n        serverName: 'force_index'\n      }\n    });\n  }\n\n  constructor(private collectionId: string, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [{ referenceValue: '' }, { stringValue: this.collectionId }]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class DatabaseSource extends Stage {\n  get _name(): string {\n    return 'database';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer)\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class DocumentsSource extends Stage {\n  get _name(): string {\n    return 'documents';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  private formattedPaths: string[];\n\n  constructor(docPaths: string[], options: StageOptions) {\n    super(options);\n    this.formattedPaths = docPaths.map(path =>\n      path.startsWith('/') ? path : '/' + path\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.formattedPaths.map(p => {\n        return { referenceValue: p };\n      })\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Where extends Stage {\n  get _name(): string {\n    return 'where';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private condition: BooleanExpression, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [this.condition._toProto(serializer)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.condition, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class FindNearest extends Stage {\n  get _name(): string {\n    return 'find_nearest';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      limit: {\n        serverName: 'limit'\n      },\n      distanceField: {\n        serverName: 'distance_field'\n      }\n    });\n  }\n\n  constructor(\n    private vectorValue: Expression,\n    private field: Field,\n    private distanceMeasure: 'euclidean' | 'cosine' | 'dot_product',\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        this.field._toProto(serializer),\n        this.vectorValue._toProto(serializer),\n        toStringValue(this.distanceMeasure)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.vectorValue, context);\n    readUserDataHelper(this.field, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Limit extends Stage {\n  get _name(): string {\n    return 'limit';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private limit: number, options: StageOptions) {\n    hardAssert(\n      !isNaN(limit) && limit !== Infinity && limit !== -Infinity,\n      0x882c,\n      'Invalid limit value'\n    );\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.limit)]\n    };\n  }\n}\n\n/**\n * @beta\n */\nexport class Offset extends Stage {\n  get _name(): string {\n    return 'offset';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private offset: number, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.offset)]\n    };\n  }\n}\n\n/**\n * @beta\n */\nexport class Select extends Stage {\n  get _name(): string {\n    return 'select';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private selections: Map<string, Expression>,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.selections)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.selections, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Sort extends Stage {\n  get _name(): string {\n    return 'sort';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private orderings: Ordering[], options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.orderings.map(o => o._toProto(serializer))\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.orderings, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Sample extends Stage {\n  get _name(): string {\n    return 'sample';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private rate: number,\n    private mode: 'percent' | 'documents',\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.rate)!, toStringValue(this.mode)!]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Union extends Stage {\n  get _name(): string {\n    return 'union';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private other: Pipeline, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toPipelineValue(this.other._toProto(serializer))]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Unnest extends Stage {\n  get _name(): string {\n    return 'unnest';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      indexField: {\n        serverName: 'index_field'\n      }\n    });\n  }\n\n  constructor(\n    private alias: string,\n    private expr: Expression,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        this.expr._toProto(serializer),\n        field(this.alias)._toProto(serializer)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.expr, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Replace extends Stage {\n  static readonly MODE = 'full_replace';\n\n  get _name(): string {\n    return 'replace_with';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private map: Expression, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [this.map._toProto(serializer), toStringValue(Replace.MODE)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.map, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class RawStage extends Stage {\n  /**\n   * @private\n   * @internal\n   */\n  constructor(\n    private name: string,\n    private params: Array<AggregateFunction | Expression>,\n    rawOptions: Record<string, unknown>\n  ) {\n    super({ rawOptions });\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      name: this.name,\n      args: this.params.map(o => o._toProto(serializer)),\n      options: this.optionsProto\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.params, context);\n  }\n\n  get _name(): string {\n    return this.name;\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n}\n\n/**\n * Helper to read user data across a number of different formats.\n * @param name - Name of the calling function. Used for error messages when invalid user data is encountered.\n * @param expressionMap\n * @returns the expressionMap argument.\n * @private\n */\nfunction readUserDataHelper<\n  T extends Map<string, UserData> | UserData[] | UserData\n>(expressionMap: T, context: ParseContext): T {\n  if (isUserData(expressionMap)) {\n    expressionMap._readUserData(context);\n  } else if (Array.isArray(expressionMap)) {\n    expressionMap.forEach(readableData => readableData._readUserData(context));\n  } else {\n    expressionMap.forEach(expr => expr._readUserData(context));\n  }\n  return expressionMap;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DatabaseId } from '../core/database_info';\nimport { toPipeline } from '../core/pipeline-util';\nimport { Code, FirestoreError } from '../util/error';\nimport { isString } from '../util/types';\n\nimport { Pipeline } from './pipeline';\nimport {\n  CollectionReference,\n  DocumentReference,\n  isCollectionReference,\n  Query\n} from './reference';\nimport {\n  CollectionGroupSource,\n  CollectionSource,\n  DatabaseSource,\n  DocumentsSource,\n  Stage\n} from './stage';\nimport {\n  CollectionGroupStageOptions,\n  CollectionStageOptions,\n  DatabaseStageOptions,\n  DocumentsStageOptions\n} from './stage_options';\nimport { UserDataReader, UserDataSource } from './user_data_reader';\n\n/**\n * @beta\n * Provides the entry point for defining the data source of a Firestore {@link @firebase/firestore/pipelines#Pipeline}.\n *\n * Use the methods of this class (e.g., {@link @firebase/firestore/pipelines#PipelineSource.(collection:1)}, {@link @firebase/firestore/pipelines#PipelineSource.(collectionGroup:1)},\n * {@link @firebase/firestore/pipelines#PipelineSource.(database:1)}, or {@link @firebase/firestore/pipelines#PipelineSource.(documents:1)}) to specify the initial data\n * for your pipeline, such as a collection, a collection group, the entire database, or a set of specific documents.\n */\nexport class PipelineSource<PipelineType> {\n  /**\n   * @internal\n   * @private\n   * @param databaseId\n   * @param userDataReader\n   * @param _createPipeline\n   */\n  constructor(\n    private databaseId: DatabaseId,\n    private userDataReader: UserDataReader,\n    /**\n     * @internal\n     * @private\n     */\n    public _createPipeline: (stages: Stage[]) => PipelineType\n  ) {}\n\n  /**\n   * @beta\n   * Returns all documents from the entire collection. The collection can be nested.\n   * @param collection - Name or reference to the collection that will be used as the Pipeline source.\n   */\n  collection(collection: string | CollectionReference): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from the entire collection. The collection can be nested.\n   * @param options - Options defining how this CollectionStage is evaluated.\n   */\n  collection(options: CollectionStageOptions): PipelineType;\n  collection(\n    collectionOrOptions: string | CollectionReference | CollectionStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(collectionOrOptions) ||\n      isCollectionReference(collectionOrOptions)\n        ? {}\n        : collectionOrOptions;\n    const collectionRefOrString =\n      isString(collectionOrOptions) ||\n      isCollectionReference(collectionOrOptions)\n        ? collectionOrOptions\n        : collectionOrOptions.collection;\n\n    // Validate that a user provided reference is for the same Firestore DB\n    if (isCollectionReference(collectionRefOrString)) {\n      this._validateReference(collectionRefOrString);\n    }\n\n    // Convert user land convenience types to internal types\n    const normalizedCollection = isString(collectionRefOrString)\n      ? (collectionRefOrString as string)\n      : collectionRefOrString.path;\n\n    // Create stage object\n    const stage = new CollectionSource(normalizedCollection, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'collection'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Returns all documents from a collection ID regardless of the parent.\n   * @param collectionId - ID of the collection group to use as the Pipeline source.\n   */\n  collectionGroup(collectionId: string): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from a collection ID regardless of the parent.\n   * @param options - Options defining how this CollectionGroupStage is evaluated.\n   */\n  collectionGroup(options: CollectionGroupStageOptions): PipelineType;\n  collectionGroup(\n    collectionIdOrOptions: string | CollectionGroupStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    let collectionId: string;\n    let options: {};\n    if (isString(collectionIdOrOptions)) {\n      collectionId = collectionIdOrOptions;\n      options = {};\n    } else {\n      ({ collectionId, ...options } = collectionIdOrOptions);\n    }\n\n    // Create stage object\n    const stage = new CollectionGroupSource(collectionId, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'collectionGroup'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Returns all documents from the entire database.\n   */\n  database(): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from the entire database.\n   * @param options - Options defining how a DatabaseStage is evaluated.\n   */\n  database(options: DatabaseStageOptions): PipelineType;\n  database(options?: DatabaseStageOptions): PipelineType {\n    // Process argument union(s) from method overloads\n    options = options ?? {};\n\n    // Create stage object\n    const stage = new DatabaseSource(options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'database'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Set the pipeline's source to the documents specified by the given paths and DocumentReferences.\n   *\n   * @param docs - An array of paths and DocumentReferences specifying the individual documents that will be the source of this pipeline.\n   * The converters for these DocumentReferences will be ignored and not have an effect on this pipeline.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  documents(docs: Array<string | DocumentReference>): PipelineType;\n\n  /**\n   * @beta\n   * Set the pipeline's source to the documents specified by the given paths and DocumentReferences.\n   *\n   * @param options - Options defining how this DocumentsStage is evaluated.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  documents(options: DocumentsStageOptions): PipelineType;\n  documents(\n    docsOrOptions: Array<string | DocumentReference> | DocumentsStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let docs: Array<string | DocumentReference>;\n    if (Array.isArray(docsOrOptions)) {\n      docs = docsOrOptions;\n      options = {};\n    } else {\n      ({ docs, ...options } = docsOrOptions);\n    }\n\n    // Validate that all user provided references are for the same Firestore DB\n    docs\n      .filter(v => v instanceof DocumentReference)\n      .forEach(dr => this._validateReference(dr as DocumentReference));\n\n    // Convert user land convenience types to internal types\n    const normalizedDocs: string[] = docs.map(doc =>\n      isString(doc) ? doc : doc.path\n    );\n\n    // Create stage object\n    const stage = new DocumentsSource(normalizedDocs, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'documents'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Convert the given Query into an equivalent Pipeline.\n   *\n   * @param query - A Query to be converted into a Pipeline.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  createFrom(query: Query): Pipeline {\n    return toPipeline(query._query, query.firestore);\n  }\n\n  _validateReference(reference: CollectionReference | DocumentReference): void {\n    const refDbId = reference.firestore._databaseId;\n    if (!refDbId.isEqual(this.databaseId)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid ${\n          reference instanceof CollectionReference\n            ? 'CollectionReference'\n            : 'DocumentReference'\n        }. ` +\n          `The project ID (\"${refDbId.projectId}\") or the database (\"${refDbId.database}\") does not match ` +\n          `the project ID (\"${this.databaseId.projectId}\") and database (\"${this.databaseId.database}\") of the target database of this Pipeline.`\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ObjectValue } from '../model/object_value';\nimport { firestoreV1ApiClientInterfaces } from '../protos/firestore_proto_api';\nimport { isOptionalEqual } from '../util/misc';\n\nimport { Field, isField } from './expressions';\nimport { FieldPath } from './field_path';\nimport { Pipeline } from './pipeline';\nimport { DocumentData, DocumentReference, refEqual } from './reference';\nimport { Timestamp } from './timestamp';\nimport { fieldPathFromArgument } from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * @beta\n * Represents the results of a Firestore pipeline execution.\n *\n * A `PipelineSnapshot` contains zero or more {@link @firebase/firestore/pipelines#PipelineResult} objects\n * representing the documents returned by a pipeline query. It provides methods\n * to iterate over the documents and access metadata about the query results.\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await firestore\n *   .pipeline()\n *   .collection('myCollection')\n *   .where(field('value').greaterThan(10))\n *   .execute();\n *\n * snapshot.results.forEach(doc => {\n *   console.log(doc.id, '=>', doc.data());\n * });\n * ```\n */\nexport class PipelineSnapshot {\n  private readonly _pipeline: Pipeline;\n  private readonly _executionTime: Timestamp | undefined;\n  private readonly _results: PipelineResult[];\n  constructor(\n    pipeline: Pipeline,\n    results: PipelineResult[],\n    executionTime?: Timestamp\n  ) {\n    this._pipeline = pipeline;\n    this._executionTime = executionTime;\n    this._results = results;\n  }\n\n  /**\n   * @beta An array of all the results in the `PipelineSnapshot`.\n   */\n  get results(): PipelineResult[] {\n    return this._results;\n  }\n\n  /**\n   * @beta\n   * The time at which the pipeline producing this result is executed.\n   *\n   * @readonly\n   *\n   */\n  get executionTime(): Timestamp {\n    if (this._executionTime === undefined) {\n      throw new Error(\n        \"'executionTime' is expected to exist, but it is undefined\"\n      );\n    }\n    return this._executionTime;\n  }\n}\n\n/**\n * @beta\n *\n * A PipelineResult contains data read from a Firestore Pipeline. The data can be extracted with the\n * {@link @firebase/firestore/pipelines#PipelineResult.data} or {@link @firebase/firestore/pipelines#PipelineResult.(get:1)} methods.\n *\n * <p>If the PipelineResult represents a non-document result, `ref` will return a undefined\n * value.\n */\nexport class PipelineResult<AppModelType = DocumentData> {\n  private readonly _userDataWriter: AbstractUserDataWriter;\n\n  private readonly _createTime: Timestamp | undefined;\n  private readonly _updateTime: Timestamp | undefined;\n\n  /**\n   * @internal\n   * @private\n   */\n  readonly _ref: DocumentReference | undefined;\n\n  /**\n   * @internal\n   * @private\n   */\n  readonly _fields: ObjectValue;\n\n  /**\n   * @private\n   * @internal\n   *\n   * @param userDataWriter - The serializer used to encode/decode protobuf.\n   * @param ref - The reference to the document.\n   * @param fields - The fields of the Firestore `Document` Protobuf backing\n   * this document.\n   * @param createTime - The time when the document was created if the result is a document, undefined otherwise.\n   * @param updateTime - The time when the document was last updated if the result is a document, undefined otherwise.\n   */\n  constructor(\n    userDataWriter: AbstractUserDataWriter,\n    fields: ObjectValue,\n    ref?: DocumentReference,\n    createTime?: Timestamp,\n    updateTime?: Timestamp\n  ) {\n    this._ref = ref;\n    this._userDataWriter = userDataWriter;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n    this._fields = fields;\n  }\n\n  /**\n   * @beta\n   * The reference of the document, if it is a document; otherwise `undefined`.\n   */\n  get ref(): DocumentReference | undefined {\n    return this._ref;\n  }\n\n  /**\n   * @beta\n   * The ID of the document for which this PipelineResult contains data, if it is a document; otherwise `undefined`.\n   *\n   * @readonly\n   *\n   */\n  get id(): string | undefined {\n    return this._ref?.id;\n  }\n\n  /**\n   * @beta\n   * The time the document was created. Undefined if this result is not a document.\n   *\n   * @readonly\n   */\n  get createTime(): Timestamp | undefined {\n    return this._createTime;\n  }\n\n  /**\n   * @beta\n   * The time the document was last updated (at the time the snapshot was\n   * generated). Undefined if this result is not a document.\n   *\n   * @readonly\n   */\n  get updateTime(): Timestamp | undefined {\n    return this._updateTime;\n  }\n\n  /**\n   * @beta\n   * Retrieves all fields in the result as an object.\n   *\n   * @returns An object containing all fields in the document or\n   * 'undefined' if the document doesn't exist.\n   *\n   * @example\n   * ```\n   * let p = firestore.pipeline().collection('col');\n   *\n   * p.execute().then(results => {\n   *   let data = results[0].data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   * ```\n   */\n  data(): AppModelType {\n    return this._userDataWriter.convertValue(\n      this._fields.value\n    ) as AppModelType;\n  }\n\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the result as a proto value.\n   *\n   * @returns An `Object` containing all fields in the result.\n   */\n  _fieldsProto(): { [key: string]: firestoreV1ApiClientInterfaces.Value } {\n    // Return a cloned value to prevent manipulation of the Snapshot's data\n    return this._fields.clone().value.mapValue.fields!;\n  }\n\n  /**\n   * @beta\n   * Retrieves the field specified by `field`.\n   *\n   * @param field - The field path\n   * (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns The data at the specified field location or `undefined` if no\n   * such field exists.\n   *\n   * @example\n   * ```\n   * let p = firestore.pipeline().collection('col');\n   *\n   * p.execute().then(results => {\n   *   let field = results[0].get('a.b');\n   *   console.log(`Retrieved field value: ${field}`);\n   * });\n   * ```\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(fieldPath: string | FieldPath | Field): any {\n    if (this._fields === undefined) {\n      return undefined;\n    }\n    if (isField(fieldPath)) {\n      fieldPath = fieldPath.fieldName;\n    }\n\n    const value = this._fields.field(\n      fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n    );\n    if (value !== null) {\n      return this._userDataWriter.convertValue(value);\n    }\n  }\n}\n\n/**\n * @beta\n * Test equality of two PipelineResults.\n * @param left - First PipelineResult to compare.\n * @param right - Second PipelineResult to compare.\n */\nexport function pipelineResultEqual(\n  left: PipelineResult,\n  right: PipelineResult\n): boolean {\n  if (left === right) {\n    return true;\n  }\n\n  return (\n    isOptionalEqual(left._ref, right._ref, refEqual) &&\n    isOptionalEqual(left._fields, right._fields, (l, r) => l.isEqual(r))\n  );\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirestoreError, vector } from '../api';\nimport {\n  _constant,\n  AggregateFunction,\n  AliasedAggregate,\n  array,\n  constant,\n  Expression,\n  AliasedExpression,\n  field,\n  Field,\n  map,\n  Selectable\n} from '../lite-api/expressions';\nimport { VectorValue } from '../lite-api/vector_value';\n\nimport { fail } from './assert';\nimport { isPlainObject } from './input_validation';\nimport { isFirestoreValue } from './proto';\nimport { isString } from './types';\n\nexport function selectablesToMap(\n  selectables: Array<Selectable | string>\n): Map<string, Expression> {\n  const result = new Map<string, Expression>();\n  for (const selectable of selectables) {\n    let alias: string;\n    let expression: Expression;\n    if (typeof selectable === 'string') {\n      alias = selectable as string;\n      expression = field(selectable);\n    } else if (selectable instanceof Field) {\n      alias = selectable.alias;\n      expression = selectable.expr;\n    } else if (selectable instanceof AliasedExpression) {\n      alias = selectable.alias;\n      expression = selectable.expr;\n    } else {\n      fail(0x5319, '`selectable` has an unsupported type', { selectable });\n    }\n\n    if (result.get(alias) !== undefined) {\n      throw new FirestoreError(\n        'invalid-argument',\n        `Duplicate alias or field '${alias}'`\n      );\n    }\n\n    result.set(alias, expression);\n  }\n  return result;\n}\n\nexport function aliasedAggregateToMap(\n  aliasedAggregatees: AliasedAggregate[]\n): Map<string, AggregateFunction> {\n  return aliasedAggregatees.reduce(\n    (map: Map<string, AggregateFunction>, selectable: AliasedAggregate) => {\n      if (map.get(selectable.alias) !== undefined) {\n        throw new FirestoreError(\n          'invalid-argument',\n          `Duplicate alias or field '${selectable.alias}'`\n        );\n      }\n\n      map.set(selectable.alias, selectable.aggregate as AggregateFunction);\n      return map;\n    },\n    new Map() as Map<string, AggregateFunction>\n  );\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nexport function vectorToExpr(\n  value: VectorValue | number[] | Expression\n): Expression {\n  if (value instanceof Expression) {\n    return value;\n  } else if (value instanceof VectorValue) {\n    const result = constant(value);\n    return result;\n  } else if (Array.isArray(value)) {\n    const result = constant(vector(value));\n    return result;\n  } else {\n    throw new Error('Unsupported value: ' + typeof value);\n  }\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n * If the input is a string, it is assumed to be a field name, and a\n * field(value) is returned.\n *\n * @private\n * @internal\n * @param value\n */\nexport function fieldOrExpression(value: unknown): Expression {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return valueToDefaultExpr(value);\n  }\n}\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nexport function valueToDefaultExpr(value: unknown): Expression {\n  let result: Expression | undefined;\n  if (isFirestoreValue(value)) {\n    return constant(value);\n  }\n  if (value instanceof Expression) {\n    return value;\n  } else if (isPlainObject(value)) {\n    result = map(value as Record<string, unknown>);\n  } else if (value instanceof Array) {\n    result = array(value);\n  } else {\n    result = _constant(value, undefined);\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Pipeline as ProtoPipeline,\n  Stage as ProtoStage\n} from '../protos/firestore_proto_api';\nimport { JsonProtoSerializer, ProtoSerializable } from '../remote/serializer';\nimport { isPlainObject } from '../util/input_validation';\nimport {\n  aliasedAggregateToMap,\n  fieldOrExpression,\n  selectablesToMap,\n  vectorToExpr\n} from '../util/pipeline_util';\nimport { isNumber, isString } from '../util/types';\n\nimport { Firestore } from './database';\nimport {\n  _mapValue,\n  AggregateFunction,\n  AliasedAggregate,\n  BooleanExpression,\n  _constant,\n  Expression,\n  Field,\n  field,\n  Ordering,\n  Selectable,\n  _field,\n  isSelectable,\n  isField,\n  isBooleanExpr,\n  isAliasedAggregate,\n  toField,\n  isOrdering,\n  isExpr\n} from './expressions';\nimport {\n  AddFields,\n  Aggregate,\n  Distinct,\n  FindNearest,\n  RawStage,\n  Limit,\n  Offset,\n  RemoveFields,\n  Replace,\n  Sample,\n  Select,\n  Sort,\n  Stage,\n  Union,\n  Unnest,\n  Where\n} from './stage';\nimport {\n  AddFieldsStageOptions,\n  AggregateStageOptions,\n  DistinctStageOptions,\n  FindNearestStageOptions,\n  LimitStageOptions,\n  OffsetStageOptions,\n  RemoveFieldsStageOptions,\n  ReplaceWithStageOptions,\n  SampleStageOptions,\n  SelectStageOptions,\n  SortStageOptions,\n  StageOptions,\n  UnionStageOptions,\n  UnnestStageOptions,\n  WhereStageOptions\n} from './stage_options';\nimport { UserDataReader, UserDataSource } from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * @beta\n *\n * The Pipeline class provides a flexible and expressive framework for building complex data\n * transformation and query pipelines for Firestore.\n *\n * A pipeline takes data sources, such as Firestore collections or collection groups, and applies\n * a series of stages that are chained together. Each stage takes the output from the previous stage\n * (or the data source) and produces an output for the next stage (or as the final output of the\n * pipeline).\n *\n * Expressions can be used within each stage to filter and transform data through the stage.\n *\n * NOTE: The chained stages do not prescribe exactly how Firestore will execute the pipeline.\n * Instead, Firestore only guarantees that the result is the same as if the chained stages were\n * executed in order.\n *\n * Usage Examples:\n *\n * @example\n * ```typescript\n * const db: Firestore; // Assumes a valid firestore instance.\n *\n * // Example 1: Select specific fields and rename 'rating' to 'bookRating'\n * const results1 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .select(\"title\", \"author\", field(\"rating\").as(\"bookRating\")));\n *\n * // Example 2: Filter documents where 'genre' is \"Science Fiction\" and 'published' is after 1950\n * const results2 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .where(and(field(\"genre\").eq(\"Science Fiction\"), field(\"published\").gt(1950))));\n *\n * // Example 3: Calculate the average rating of books published after 1980\n * const results3 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .where(field(\"published\").gt(1980))\n *     .aggregate(avg(field(\"rating\")).as(\"averageRating\")));\n * ```\n */\nexport class Pipeline implements ProtoSerializable<ProtoPipeline> {\n  /**\n   * @internal\n   * @private\n   * @param _db\n   * @param userDataReader\n   * @param _userDataWriter\n   * @param stages\n   */\n  constructor(\n    /**\n     * @internal\n     * @private\n     */\n    public _db: Firestore,\n    /**\n     * @internal\n     * @private\n     */\n    private userDataReader: UserDataReader,\n    /**\n     * @internal\n     * @private\n     */\n    public _userDataWriter: AbstractUserDataWriter,\n    /**\n     * @internal\n     * @private\n     */\n    private stages: Stage[]\n  ) {}\n\n  /**\n   * @beta\n   * Adds new fields to outputs from previous stages.\n   *\n   * This stage allows you to compute values on-the-fly based on existing data from previous\n   * stages or constants. You can use this to create new fields or overwrite existing ones (if there\n   * is name overlaps).\n   *\n   * The added fields are defined using {@link @firebase/firestore/pipelines#Selectable}s, which can be:\n   *\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#Expression}: Either a literal value (see {@link @firebase/firestore/pipelines#(constant:1)}) or a computed value\n   *   with an assigned alias using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .addFields(\n   *     field(\"rating\").as(\"bookRating\"), // Rename 'rating' to 'bookRating'\n   *     add(5, field(\"quantity\")).as(\"totalCost\")  // Calculate 'totalCost'\n   *   );\n   * ```\n   *\n   * @param field - The first field to add to the documents, specified as a {@link @firebase/firestore/pipelines#Selectable}.\n   * @param additionalFields - Optional additional fields to add to the documents, specified as {@link @firebase/firestore/pipelines#Selectable}s.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  addFields(field: Selectable, ...additionalFields: Selectable[]): Pipeline;\n  /**\n   * @beta\n   * Adds new fields to outputs from previous stages.\n   *\n   * This stage allows you to compute values on-the-fly based on existing data from previous\n   * stages or constants. You can use this to create new fields or overwrite existing ones (if there\n   * is name overlaps).\n   *\n   * The added fields are defined using {@link @firebase/firestore/pipelines#Selectable}s, which can be:\n   *\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#Expression}: Either a literal value (see {@link @firebase/firestore/pipelines#(constant:1)}) or a computed value\n   *   with an assigned alias using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .addFields(\n   *     field(\"rating\").as(\"bookRating\"), // Rename 'rating' to 'bookRating'\n   *     add(5, field(\"quantity\")).as(\"totalCost\")  // Calculate 'totalCost'\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  addFields(options: AddFieldsStageOptions): Pipeline;\n  addFields(\n    fieldOrOptions: Selectable | AddFieldsStageOptions,\n    ...additionalFields: Selectable[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    let fields: Selectable[];\n    let options: {};\n    if (isSelectable(fieldOrOptions)) {\n      fields = [fieldOrOptions, ...additionalFields];\n      options = {};\n    } else {\n      ({ fields, ...options } = fieldOrOptions);\n    }\n\n    // Convert user land convenience types to internal types\n    const normalizedFields: Map<string, Expression> = selectablesToMap(fields);\n\n    // Create stage object\n    const stage = new AddFields(normalizedFields, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'addFields'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Remove fields from outputs of previous stages.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection('books')\n   *   // removes field 'rating' and 'cost' from the previous stage outputs.\n   *   .removeFields(\n   *     field('rating'),\n   *     'cost'\n   *   );\n   * ```\n   *\n   * @param fieldValue - The first field to remove.\n   * @param additionalFields - Optional additional fields to remove.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  removeFields(\n    fieldValue: Field | string,\n    ...additionalFields: Array<Field | string>\n  ): Pipeline;\n  /**\n   * @beta\n   * Remove fields from outputs of previous stages.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection('books')\n   *   // removes field 'rating' and 'cost' from the previous stage outputs.\n   *   .removeFields(\n   *     field('rating'),\n   *     'cost'\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  removeFields(options: RemoveFieldsStageOptions): Pipeline;\n  removeFields(\n    fieldValueOrOptions: Field | string | RemoveFieldsStageOptions,\n    ...additionalFields: Array<Field | string>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isField(fieldValueOrOptions) || isString(fieldValueOrOptions)\n        ? {}\n        : fieldValueOrOptions;\n    const fields: Array<Field | string> =\n      isField(fieldValueOrOptions) || isString(fieldValueOrOptions)\n        ? [fieldValueOrOptions, ...additionalFields]\n        : fieldValueOrOptions.fields;\n\n    // Convert user land convenience types to internal types\n    const convertedFields: Field[] = fields.map(f =>\n      isString(f) ? field(f) : (f as Field)\n    );\n\n    // Create stage object\n    const stage = new RemoveFields(convertedFields, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    stage._readUserData(\n      this.userDataReader.createContext(UserDataSource.Argument, 'removeFields')\n    );\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Selects or creates a set of fields from the outputs of previous stages.\n   *\n   * <p>The selected fields are defined using {@link @firebase/firestore/pipelines#Selectable} expressions, which can be:\n   *\n   * <ul>\n   *   <li>`string` : Name of an existing field</li>\n   *   <li>{@link @firebase/firestore/pipelines#Field}: References an existing field.</li>\n   *   <li>{@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name using\n   *       {@link @firebase/firestore/pipelines#Expression.(as:1)}</li>\n   * </ul>\n   *\n   * <p>If no selections are provided, the output of this stage is empty. Use {@link\n   * @firebase/firestore/pipelines#Pipeline.(addFields:1)} instead if only additions are\n   * desired.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * db.pipeline().collection(\"books\")\n   *   .select(\n   *     \"firstName\",\n   *     field(\"lastName\"),\n   *     field(\"address\").toUppercase().as(\"upperAddress\"),\n   *   );\n   * ```\n   *\n   * @param selection - The first field to include in the output documents, specified as {@link\n   *     @firebase/firestore/pipelines#Selectable} expression or string value representing the field name.\n   * @param additionalSelections - Optional additional fields to include in the output documents, specified as {@link\n   *     @firebase/firestore/pipelines#Selectable} expressions or `string` values representing field names.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  select(\n    selection: Selectable | string,\n    ...additionalSelections: Array<Selectable | string>\n  ): Pipeline;\n  /**\n   * @beta\n   * Selects or creates a set of fields from the outputs of previous stages.\n   *\n   * <p>The selected fields are defined using {@link @firebase/firestore/pipelines#Selectable} expressions, which can be:\n   *\n   * <ul>\n   *   <li>`string`: Name of an existing field</li>\n   *   <li>{@link @firebase/firestore/pipelines#Field}: References an existing field.</li>\n   *   <li>{@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name using\n   *       {@link @firebase/firestore/pipelines#Expression.(as:1)}</li>\n   * </ul>\n   *\n   * <p>If no selections are provided, the output of this stage is empty. Use {@link\n   * @firebase/firestore/pipelines#Pipeline.(addFields:1)} instead if only additions are\n   * desired.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * db.pipeline().collection(\"books\")\n   *   .select(\n   *     \"firstName\",\n   *     field(\"lastName\"),\n   *     field(\"address\").toUppercase().as(\"upperAddress\"),\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  select(options: SelectStageOptions): Pipeline;\n  select(\n    selectionOrOptions: Selectable | string | SelectStageOptions,\n    ...additionalSelections: Array<Selectable | string>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isSelectable(selectionOrOptions) || isString(selectionOrOptions)\n        ? {}\n        : selectionOrOptions;\n\n    const selections: Array<Selectable | string> =\n      isSelectable(selectionOrOptions) || isString(selectionOrOptions)\n        ? [selectionOrOptions, ...additionalSelections]\n        : selectionOrOptions.selections;\n\n    // Convert user land convenience types to internal types\n    const normalizedSelections: Map<string, Expression> =\n      selectablesToMap(selections);\n\n    // Create stage object\n    const stage = new Select(normalizedSelections, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'select'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Filters the documents from previous stages to only include those matching the specified {@link\n   * @firebase/firestore/pipelines#BooleanExpression}.\n   *\n   * <p>This stage allows you to apply conditions to the data, similar to a \"WHERE\" clause in SQL.\n   * You can filter documents based on their field values, using implementations of {@link\n   * @firebase/firestore/pipelines#BooleanExpression}, typically including but not limited to:\n   *\n   * <ul>\n   *   <li>field comparators: {@link @firebase/firestore/pipelines#Expression.(equal:1)}, {@link @firebase/firestore/pipelines#Expression.(lessThan:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(greaterThan:1)}, etc.</li>\n   *   <li>logical operators: {@link @firebase/firestore/pipelines#Expression.(and:1)}, {@link @firebase/firestore/pipelines#Expression.(or:1)}, {@link @firebase/firestore/pipelines#Expression.(not:1)}, etc.</li>\n   *   <li>advanced functions: {@link @firebase/firestore/pipelines#Expression.(regexMatch:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(arrayContains:1)}, etc.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .where(\n   *     and(\n   *         gt(field(\"rating\"), 4.0),   // Filter for ratings greater than 4.0\n   *         field(\"genre\").eq(\"Science Fiction\") // Equivalent to gt(\"genre\", \"Science Fiction\")\n   *     )\n   *   );\n   * ```\n   *\n   * @param condition - The {@link @firebase/firestore/pipelines#BooleanExpression} to apply.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  where(condition: BooleanExpression): Pipeline;\n  /**\n   * @beta\n   * Filters the documents from previous stages to only include those matching the specified {@link\n   * @firebase/firestore/pipelines#BooleanExpression}.\n   *\n   * <p>This stage allows you to apply conditions to the data, similar to a \"WHERE\" clause in SQL.\n   * You can filter documents based on their field values, using implementations of {@link\n   * @firebase/firestore/pipelines#BooleanExpression}, typically including but not limited to:\n   *\n   * <ul>\n   *   <li>field comparators: {@link @firebase/firestore/pipelines#Expression.(eq:1)}, {@link @firebase/firestore/pipelines#Expression.(lt:1)} (less than), {@link\n   *       @firebase/firestore/pipelines#Expression.(greaterThan:1)}, etc.</li>\n   *   <li>logical operators: {@link @firebase/firestore/pipelines#Expression.(and:1)}, {@link @firebase/firestore/pipelines#Expression.(or:1)}, {@link @firebase/firestore/pipelines#Expression.(not:1)}, etc.</li>\n   *   <li>advanced functions: {@link @firebase/firestore/pipelines#Expression.(regexMatch:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(arrayContains:1)}, etc.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .where(\n   *     and(\n   *         gt(field(\"rating\"), 4.0),   // Filter for ratings greater than 4.0\n   *         field(\"genre\").eq(\"Science Fiction\") // Equivalent to gt(\"genre\", \"Science Fiction\")\n   *     )\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  where(options: WhereStageOptions): Pipeline;\n  where(conditionOrOptions: BooleanExpression | WhereStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isBooleanExpr(conditionOrOptions) ? {} : conditionOrOptions;\n    const condition: BooleanExpression = isBooleanExpr(conditionOrOptions)\n      ? conditionOrOptions\n      : conditionOrOptions.condition;\n\n    // Create stage object\n    const stage = new Where(condition, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'where'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Skips the first `offset` number of documents from the results of previous stages.\n   *\n   * <p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve\n   * results in chunks. It is typically used in conjunction with {@link @firebase/firestore/pipelines#Pipeline.limit} to control the\n   * size of each page.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page of 20 results\n   * firestore.pipeline().collection('books')\n   *     .sort(field('published').descending())\n   *     .offset(20)  // Skip the first 20 results\n   *     .limit(20);   // Take the next 20 results\n   * ```\n   *\n   * @param offset - The number of documents to skip.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  offset(offset: number): Pipeline;\n  /**\n   * @beta\n   * Skips the first `offset` number of documents from the results of previous stages.\n   *\n   * <p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve\n   * results in chunks. It is typically used in conjunction with {@link @firebase/firestore/pipelines#Pipeline.limit} to control the\n   * size of each page.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page of 20 results\n   * firestore.pipeline().collection('books')\n   *     .sort(field('published').descending())\n   *     .offset(20)  // Skip the first 20 results\n   *     .limit(20);   // Take the next 20 results\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  offset(options: OffsetStageOptions): Pipeline;\n  offset(offsetOrOptions: number | OffsetStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let offset: number;\n    if (isNumber(offsetOrOptions)) {\n      options = {};\n      offset = offsetOrOptions;\n    } else {\n      options = offsetOrOptions;\n      offset = offsetOrOptions.offset;\n    }\n\n    // Create stage object\n    const stage = new Offset(offset, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'offset'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Limits the maximum number of documents returned by previous stages to `limit`.\n   *\n   * <p>This stage is particularly useful when you want to retrieve a controlled subset of data from\n   * a potentially large result set. It's often used for:\n   *\n   * <ul>\n   *   <li>**Pagination:** In combination with {@link @firebase/firestore/pipelines#Pipeline.offset} to retrieve specific pages of\n   *       results.</li>\n   *   <li>**Limiting Data Retrieval:** To prevent excessive data transfer and improve performance,\n   *       especially when dealing with large collections.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Limit the results to the top 10 highest-rated books\n   * firestore.pipeline().collection('books')\n   *     .sort(field('rating').descending())\n   *     .limit(10);\n   * ```\n   *\n   * @param limit - The maximum number of documents to return.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  limit(limit: number): Pipeline;\n  /**\n   * @beta\n   * Limits the maximum number of documents returned by previous stages to `limit`.\n   *\n   * <p>This stage is particularly useful when you want to retrieve a controlled subset of data from\n   * a potentially large result set. It's often used for:\n   *\n   * <ul>\n   *   <li>**Pagination:** In combination with {@link @firebase/firestore/pipelines#Pipeline.offset} to retrieve specific pages of\n   *       results.</li>\n   *   <li>**Limiting Data Retrieval:** To prevent excessive data transfer and improve performance,\n   *       especially when dealing with large collections.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Limit the results to the top 10 highest-rated books\n   * firestore.pipeline().collection('books')\n   *     .sort(field('rating').descending())\n   *     .limit(10);\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  limit(options: LimitStageOptions): Pipeline;\n  limit(limitOrOptions: number | LimitStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isNumber(limitOrOptions) ? {} : limitOrOptions;\n    const limit: number = isNumber(limitOrOptions)\n      ? limitOrOptions\n      : limitOrOptions.limit;\n\n    // Create stage object\n    const stage = new Limit(limit, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'limit'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Returns a set of distinct values from the inputs to this stage.\n   *\n   * This stage runs through the results from previous stages to include only results with\n   * unique combinations of {@link @firebase/firestore/pipelines#Expression} values ({@link @firebase/firestore/pipelines#Field}, {@link @firebase/firestore/pipelines#AliasedExpression}, etc).\n   *\n   * The parameters to this stage are defined using {@link @firebase/firestore/pipelines#Selectable} expressions or strings:\n   *\n   * - `string`: Name of an existing field\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name\n   *   using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Get a list of unique author names in uppercase and genre combinations.\n   * firestore.pipeline().collection(\"books\")\n   *     .distinct(toUppercase(field(\"author\")).as(\"authorName\"), field(\"genre\"), \"publishedAt\")\n   *     .select(\"authorName\");\n   * ```\n   *\n   * @param group - The {@link @firebase/firestore/pipelines#Selectable} expression or field name to consider when determining\n   *     distinct value combinations.\n   * @param additionalGroups - Optional additional {@link @firebase/firestore/pipelines#Selectable} expressions to consider when determining distinct\n   *     value combinations or strings representing field names.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  distinct(\n    group: string | Selectable,\n    ...additionalGroups: Array<string | Selectable>\n  ): Pipeline;\n  /**\n   * @beta\n   * Returns a set of distinct values from the inputs to this stage.\n   *\n   * This stage runs through the results from previous stages to include only results with\n   * unique combinations of {@link @firebase/firestore/pipelines#Expression} values ({@link @firebase/firestore/pipelines#Field}, {@link @firebase/firestore/pipelines#AliasedExpression}, etc).\n   *\n   * The parameters to this stage are defined using {@link @firebase/firestore/pipelines#Selectable} expressions or strings:\n   *\n   * - `string`: Name of an existing field\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name\n   *   using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Get a list of unique author names in uppercase and genre combinations.\n   * firestore.pipeline().collection(\"books\")\n   *     .distinct(toUppercase(field(\"author\")).as(\"authorName\"), field(\"genre\"), \"publishedAt\")\n   *     .select(\"authorName\");\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  distinct(options: DistinctStageOptions): Pipeline;\n  distinct(\n    groupOrOptions: string | Selectable | DistinctStageOptions,\n    ...additionalGroups: Array<string | Selectable>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(groupOrOptions) || isSelectable(groupOrOptions)\n        ? {}\n        : groupOrOptions;\n    const groups: Array<string | Selectable> =\n      isString(groupOrOptions) || isSelectable(groupOrOptions)\n        ? [groupOrOptions, ...additionalGroups]\n        : groupOrOptions.groups;\n\n    // Convert user land convenience types to internal types\n    const convertedGroups: Map<string, Expression> = selectablesToMap(groups);\n\n    // Create stage object\n    const stage = new Distinct(convertedGroups, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'distinct'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs aggregation operations on the documents from previous stages.\n   *\n   * <p>This stage allows you to calculate aggregate values over a set of documents. You define the\n   * aggregations to perform using {@link @firebase/firestore/pipelines#AliasedAggregate} expressions which are typically results of\n   * calling {@link @firebase/firestore/pipelines#Expression.(as:1)} on {@link @firebase/firestore/pipelines#AggregateFunction} instances.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average rating and the total number of books\n   * firestore.pipeline().collection(\"books\")\n   *     .aggregate(\n   *         field(\"rating\").avg().as(\"averageRating\"),\n   *         countAll().as(\"totalBooks\")\n   *     );\n   * ```\n   *\n   * @param accumulator - The first {@link @firebase/firestore/pipelines#AliasedAggregate}, wrapping an {@link @firebase/firestore/pipelines#AggregateFunction}\n   *     and providing a name for the accumulated results.\n   * @param additionalAccumulators - Optional additional {@link @firebase/firestore/pipelines#AliasedAggregate}, each wrapping an {@link @firebase/firestore/pipelines#AggregateFunction}\n   *     and providing a name for the accumulated results.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  aggregate(\n    accumulator: AliasedAggregate,\n    ...additionalAccumulators: AliasedAggregate[]\n  ): Pipeline;\n  /**\n   * @beta\n   * Performs optionally grouped aggregation operations on the documents from previous stages.\n   *\n   * <p>This stage allows you to calculate aggregate values over a set of documents, optionally\n   * grouped by one or more fields or functions. You can specify:\n   *\n   * <ul>\n   *   <li>**Grouping Fields or Functions:** One or more fields or functions to group the documents\n   *       by. For each distinct combination of values in these fields, a separate group is created.\n   *       If no grouping fields are provided, a single group containing all documents is used. Not\n   *       specifying groups is the same as putting the entire inputs into one group.</li>\n   *   <li>**Accumulators:** One or more accumulation operations to perform within each group. These\n   *       are defined using {@link @firebase/firestore/pipelines#AliasedAggregate} expressions, which are typically created by\n   *       calling {@link @firebase/firestore/pipelines#Expression.(as:1)} on {@link @firebase/firestore/pipelines#AggregateFunction} instances. Each aggregation\n   *       calculates a value (e.g., sum, average, count) based on the documents within its group.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average rating for each genre.\n   * firestore.pipeline().collection(\"books\")\n   *   .aggregate({\n   *       accumulators: [avg(field(\"rating\")).as(\"avg_rating\")]\n   *       groups: [\"genre\"]\n   *       });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage\n   * list.\n   */\n  aggregate(options: AggregateStageOptions): Pipeline;\n  aggregate(\n    targetOrOptions: AliasedAggregate | AggregateStageOptions,\n    ...rest: AliasedAggregate[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isAliasedAggregate(targetOrOptions) ? {} : targetOrOptions;\n    const accumulators: AliasedAggregate[] = isAliasedAggregate(targetOrOptions)\n      ? [targetOrOptions, ...rest]\n      : targetOrOptions.accumulators;\n    const groups: Array<Selectable | string> = isAliasedAggregate(\n      targetOrOptions\n    )\n      ? []\n      : targetOrOptions.groups ?? [];\n\n    // Convert user land convenience types to internal types\n    const convertedAccumulators: Map<string, AggregateFunction> =\n      aliasedAggregateToMap(accumulators);\n    const convertedGroups: Map<string, Expression> = selectablesToMap(groups);\n\n    // Create stage object\n    const stage = new Aggregate(\n      convertedGroups,\n      convertedAccumulators,\n      options\n    );\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'aggregate'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs a vector proximity search on the documents from the previous stage, returning the\n   * K-nearest documents based on the specified query `vectorValue` and `distanceMeasure`. The\n   * returned documents will be sorted in order from nearest to furthest from the query `vectorValue`.\n   *\n   * <p>Example:\n   *\n   * ```typescript\n   * // Find the 10 most similar books based on the book description.\n   * const bookDescription = \"Lorem ipsum...\";\n   * const queryVector: number[] = ...; // compute embedding of `bookDescription`\n   *\n   * firestore.pipeline().collection(\"books\")\n   *     .findNearest({\n   *       field: 'embedding',\n   *       vectorValue: queryVector,\n   *       distanceMeasure: 'euclidean',\n   *       limit: 10,                        // optional\n   *       distanceField: 'computedDistance' // optional\n   *     });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  findNearest(options: FindNearestStageOptions): Pipeline {\n    // Convert user land convenience types to internal types\n    const field = toField(options.field);\n    const vectorValue = vectorToExpr(options.vectorValue);\n    const distanceField = options.distanceField\n      ? toField(options.distanceField)\n      : undefined;\n    const internalOptions = {\n      distanceField,\n      limit: options.limit,\n      rawOptions: options.rawOptions\n    };\n\n    // Create stage object\n    const stage = new FindNearest(\n      vectorValue,\n      field,\n      options.distanceMeasure,\n      internalOptions\n    );\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'addFields'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Sorts the documents from previous stages based on one or more {@link @firebase/firestore/pipelines#Ordering} criteria.\n   *\n   * <p>This stage allows you to order the results of your pipeline. You can specify multiple {@link\n   * @firebase/firestore/pipelines#Ordering} instances to sort by multiple fields in ascending or descending order. If documents\n   * have the same value for a field used for sorting, the next specified ordering will be used. If\n   * all orderings result in equal comparison, the documents are considered equal and the order is\n   * unspecified.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Sort books by rating in descending order, and then by title in ascending order for books\n   * // with the same rating\n   * firestore.pipeline().collection(\"books\")\n   *     .sort(\n   *         Ordering.of(field(\"rating\")).descending(),\n   *         Ordering.of(field(\"title\"))  // Ascending order is the default\n   *     );\n   * ```\n   *\n   * @param ordering - The first {@link @firebase/firestore/pipelines#Ordering} instance specifying the sorting criteria.\n   * @param additionalOrderings - Optional additional {@link @firebase/firestore/pipelines#Ordering} instances specifying the additional sorting criteria.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sort(ordering: Ordering, ...additionalOrderings: Ordering[]): Pipeline;\n  /**\n   * @beta\n   * Sorts the documents from previous stages based on one or more {@link @firebase/firestore/pipelines#Ordering} criteria.\n   *\n   * <p>This stage allows you to order the results of your pipeline. You can specify multiple {@link\n   * @firebase/firestore/pipelines#Ordering} instances to sort by multiple fields in ascending or descending order. If documents\n   * have the same value for a field used for sorting, the next specified ordering will be used. If\n   * all orderings result in equal comparison, the documents are considered equal and the order is\n   * unspecified.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Sort books by rating in descending order, and then by title in ascending order for books\n   * // with the same rating\n   * firestore.pipeline().collection(\"books\")\n   *     .sort(\n   *         Ordering.of(field(\"rating\")).descending(),\n   *         Ordering.of(field(\"title\"))  // Ascending order is the default\n   *     );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sort(options: SortStageOptions): Pipeline;\n  sort(\n    orderingOrOptions: Ordering | SortStageOptions,\n    ...additionalOrderings: Ordering[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isOrdering(orderingOrOptions) ? {} : orderingOrOptions;\n    const orderings: Ordering[] = isOrdering(orderingOrOptions)\n      ? [orderingOrOptions, ...additionalOrderings]\n      : orderingOrOptions.orderings;\n\n    // Create stage object\n    const stage = new Sort(orderings, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'sort'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a nested map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith('parents');\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param fieldName - The {@link @firebase/firestore/pipelines#Field} field containing the nested map.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(fieldName: string): Pipeline;\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith(map({\n   *   foo: 'bar',\n   *   info: {\n   *     name: field('name')\n   *   }\n   * }));\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param expr - An {@link @firebase/firestore/pipelines#Expression} that when returned evaluates to a map.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(expr: Expression): Pipeline;\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith(map({\n   *   foo: 'bar',\n   *   info: {\n   *     name: field('name')\n   *   }\n   * }));\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(options: ReplaceWithStageOptions): Pipeline;\n  replaceWith(\n    valueOrOptions: Expression | string | ReplaceWithStageOptions\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(valueOrOptions) || isExpr(valueOrOptions) ? {} : valueOrOptions;\n    const fieldNameOrExpr: string | Expression =\n      isString(valueOrOptions) || isExpr(valueOrOptions)\n        ? valueOrOptions\n        : valueOrOptions.map;\n\n    // Convert user land convenience types to internal types\n    const mapExpr = fieldOrExpression(fieldNameOrExpr);\n\n    // Create stage object\n    const stage = new Replace(mapExpr, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'replaceWith'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs a pseudo-random sampling of the documents from the previous stage.\n   *\n   * <p>This stage will filter documents pseudo-randomly. The parameter specifies how number of\n   * documents to be returned.\n   *\n   * <p>Examples:\n   *\n   * @example\n   * ```typescript\n   * // Sample 25 books, if available.\n   * firestore.pipeline().collection('books')\n   *     .sample(25);\n   * ```\n   *\n   * @param documents - The number of documents to sample.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sample(documents: number): Pipeline;\n\n  /**\n   * @beta\n   * Performs a pseudo-random sampling of the documents from the previous stage.\n   *\n   * <p>This stage will filter documents pseudo-randomly. The 'options' parameter specifies how\n   * sampling will be performed. See {@link @firebase/firestore/pipelines#SampleStageOptions} for more information.\n   *\n   * @example\n   * ```typescript\n   * // Sample 10 books, if available.\n   * firestore.pipeline().collection(\"books\")\n   *     .sample({ documents: 10 });\n   *\n   * // Sample 50% of books.\n   * firestore.pipeline().collection(\"books\")\n   *     .sample({ percentage: 0.5 });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sample(options: SampleStageOptions): Pipeline;\n  sample(documentsOrOptions: number | SampleStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isNumber(documentsOrOptions) ? {} : documentsOrOptions;\n    let rate: number;\n    let mode: 'documents' | 'percent';\n    if (isNumber(documentsOrOptions)) {\n      rate = documentsOrOptions;\n      mode = 'documents';\n    } else if (isNumber(documentsOrOptions.documents)) {\n      rate = documentsOrOptions.documents;\n      mode = 'documents';\n    } else {\n      rate = documentsOrOptions.percentage!;\n      mode = 'percent';\n    }\n\n    // Create stage object\n    const stage = new Sample(rate, mode, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'sample'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs union of all documents from two pipelines, including duplicates.\n   *\n   * <p>This stage will pass through documents from previous stage, and also pass through documents\n   * from previous stage of the `other` {@link @firebase/firestore/pipelines#Pipeline} given in parameter. The order of documents\n   * emitted from this stage is undefined.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Emit documents from books collection and magazines collection.\n   * firestore.pipeline().collection('books')\n   *     .union(firestore.pipeline().collection('magazines'));\n   * ```\n   *\n   * @param other - The other {@link @firebase/firestore/pipelines#Pipeline} that is part of union.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  union(other: Pipeline): Pipeline;\n  /**\n   * @beta\n   * Performs union of all documents from two pipelines, including duplicates.\n   *\n   * <p>This stage will pass through documents from previous stage, and also pass through documents\n   * from previous stage of the `other` {@link @firebase/firestore/pipelines#Pipeline} given in parameter. The order of documents\n   * emitted from this stage is undefined.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Emit documents from books collection and magazines collection.\n   * firestore.pipeline().collection('books')\n   *     .union(firestore.pipeline().collection('magazines'));\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  union(options: UnionStageOptions): Pipeline;\n  union(otherOrOptions: Pipeline | UnionStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let otherPipeline: Pipeline;\n    if (isPipeline(otherOrOptions)) {\n      options = {};\n      otherPipeline = otherOrOptions;\n    } else {\n      ({ other: otherPipeline, ...options } = otherOrOptions);\n    }\n\n    // Create stage object\n    const stage = new Union(otherPipeline, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'union'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Produces a document for each element in an input array.\n   *\n   * For each previous stage document, this stage will emit zero or more augmented documents. The\n   * input array specified by the `selectable` parameter, will emit an augmented document for each input array element. The input array element will\n   * augment the previous stage document by setting the `alias` field  with the array element value.\n   *\n   * When `selectable` evaluates to a non-array value (ex: number, null, absent), then the stage becomes a no-op for\n   * the current input document, returning it as is with the `alias` field absent.\n   *\n   * No documents are emitted when `selectable` evaluates to an empty array.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Input:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tags\": [ \"comedy\", \"space\", \"adventure\" ], ... }\n   *\n   * // Emit a book document for each tag of the book.\n   * firestore.pipeline().collection(\"books\")\n   *     .unnest(field(\"tags\").as('tag'), 'tagIndex');\n   *\n   * // Output:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"comedy\", \"tagIndex\": 0, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"space\", \"tagIndex\": 1, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"adventure\", \"tagIndex\": 2, ... }\n   * ```\n   *\n   * @param selectable - A selectable expression defining the field to unnest and the alias to use for each un-nested element in the output documents.\n   * @param indexField - An optional string value specifying the field path to write the offset (starting at zero) into the array the un-nested element is from\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  unnest(selectable: Selectable, indexField?: string): Pipeline;\n  /**\n   * @beta\n   * Produces a document for each element in an input array.\n   *\n   * For each previous stage document, this stage will emit zero or more augmented documents. The\n   * input array specified by the `selectable` parameter, will emit an augmented document for each input array element. The input array element will\n   * augment the previous stage document by setting the `alias` field  with the array element value.\n   *\n   * When `selectable` evaluates to a non-array value (ex: number, null, absent), then the stage becomes a no-op for\n   * the current input document, returning it as is with the `alias` field absent.\n   *\n   * No documents are emitted when `selectable` evaluates to an empty array.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Input:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tags\": [ \"comedy\", \"space\", \"adventure\" ], ... }\n   *\n   * // Emit a book document for each tag of the book.\n   * firestore.pipeline().collection(\"books\")\n   *     .unnest(field(\"tags\").as('tag'), 'tagIndex');\n   *\n   * // Output:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"comedy\", \"tagIndex\": 0, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"space\", \"tagIndex\": 1, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"adventure\", \"tagIndex\": 2, ... }\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  unnest(options: UnnestStageOptions): Pipeline;\n  unnest(\n    selectableOrOptions: Selectable | UnnestStageOptions,\n    indexField?: string\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: { indexField?: Field } & StageOptions;\n    let selectable: Selectable;\n    let indexFieldName: string | undefined;\n    if (isSelectable(selectableOrOptions)) {\n      options = {};\n      selectable = selectableOrOptions;\n      indexFieldName = indexField;\n    } else {\n      ({\n        selectable,\n        indexField: indexFieldName,\n        ...options\n      } = selectableOrOptions);\n    }\n\n    // Convert user land convenience types to internal types\n    const alias = selectable.alias;\n    const expr = selectable.expr as Expression;\n    if (isString(indexFieldName)) {\n      options.indexField = _field(indexFieldName, 'unnest');\n    }\n\n    // Create stage object\n    const stage = new Unnest(alias, expr, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'unnest'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Adds a raw stage to the pipeline.\n   *\n   * <p>This method provides a flexible way to extend the pipeline's functionality by adding custom\n   * stages. Each raw stage is defined by a unique `name` and a set of `params` that control its\n   * behavior.\n   *\n   * <p>Example (Assuming there is no 'where' stage available in SDK):\n   *\n   * @example\n   * ```typescript\n   * // Assume we don't have a built-in 'where' stage\n   * firestore.pipeline().collection('books')\n   *     .rawStage('where', [field('published').lt(1900)]) // Custom 'where' stage\n   *     .select('title', 'author');\n   * ```\n   *\n   * @param name - The unique name of the raw stage to add.\n   * @param params - A list of parameters to configure the raw stage's behavior.\n   * @param options - An object of key value pairs that specifies optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  rawStage(\n    name: string,\n    params: unknown[],\n    options?: { [key: string]: Expression | unknown }\n  ): Pipeline {\n    // Convert user land convenience types to internal types\n    const expressionParams = params.map((value: unknown) => {\n      if (value instanceof Expression) {\n        return value;\n      } else if (value instanceof AggregateFunction) {\n        return value;\n      } else if (isPlainObject(value)) {\n        return _mapValue(value as Record<string, unknown>);\n      } else {\n        return _constant(value, 'rawStage');\n      }\n    });\n\n    // Create stage object\n    const stage = new RawStage(name, expressionParams, options ?? {});\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'rawStage'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(jsonProtoSerializer: JsonProtoSerializer): ProtoPipeline {\n    const stages: ProtoStage[] = this.stages.map(stage =>\n      stage._toProto(jsonProtoSerializer)\n    );\n    return { stages };\n  }\n\n  private _addStage(stage: Stage): Pipeline {\n    const copy = this.stages.map(s => s);\n    copy.push(stage);\n    return this.newPipeline(\n      this._db,\n      this.userDataReader,\n      this._userDataWriter,\n      copy\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   * @param db\n   * @param userDataReader\n   * @param userDataWriter\n   * @param stages\n   * @protected\n   */\n  protected newPipeline(\n    db: Firestore,\n    userDataReader: UserDataReader,\n    userDataWriter: AbstractUserDataWriter,\n    stages: Stage[]\n  ): Pipeline {\n    return new Pipeline(db, userDataReader, userDataWriter, stages);\n  }\n}\n\nexport function isPipeline(val: unknown): val is Pipeline {\n  return val instanceof Pipeline;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Pipeline as LitePipeline } from '../lite-api/pipeline';\nimport { Stage } from '../lite-api/stage';\nimport { UserDataReader } from '../lite-api/user_data_reader';\nimport { AbstractUserDataWriter } from '../lite-api/user_data_writer';\n\nimport { Firestore } from './database';\n\n/**\n * @beta\n */\nexport class Pipeline extends LitePipeline {\n  /**\n   * @internal\n   * @private\n   * @param db\n   * @param userDataReader\n   * @param userDataWriter\n   * @param stages\n   * @param converter\n   * @protected\n   */\n  protected newPipeline(\n    db: Firestore,\n    userDataReader: UserDataReader,\n    userDataWriter: AbstractUserDataWriter,\n    stages: Stage[]\n  ): Pipeline {\n    return new Pipeline(db, userDataReader, userDataWriter, stages);\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Pipeline } from '../api/pipeline';\nimport { firestoreClientExecutePipeline } from '../core/firestore_client';\nimport {\n  StructuredPipeline,\n  StructuredPipelineOptions\n} from '../core/structured_pipeline';\nimport { Pipeline as LitePipeline } from '../lite-api/pipeline';\nimport { PipelineResult, PipelineSnapshot } from '../lite-api/pipeline-result';\nimport { PipelineSource } from '../lite-api/pipeline-source';\nimport { PipelineExecuteOptions } from '../lite-api/pipeline_options';\nimport { Stage } from '../lite-api/stage';\nimport {\n  newUserDataReader,\n  UserDataReader,\n  UserDataSource\n} from '../lite-api/user_data_reader';\nimport { cast } from '../util/input_validation';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport { DocumentReference } from './reference';\nimport { ExpUserDataWriter } from './user_data_writer';\n\ndeclare module './database' {\n  /**\n   * @beta\n   * Creates and returns a new PipelineSource, which allows specifying the source stage of a {@link @firebase/firestore/pipelines#Pipeline}.\n   *\n   * @example\n   * ```\n   * let myPipeline: Pipeline = firestore.pipeline().collection('books');\n   * ```\n   */\n  interface Firestore {\n    pipeline(): PipelineSource<Pipeline>;\n  }\n}\n\n/**\n * @beta\n * Executes a pipeline and returns a Promise to represent the asynchronous operation.\n *\n * The returned Promise can be used to track the progress of the pipeline execution\n * and retrieve the results (or handle any errors) asynchronously.\n *\n * The pipeline results are returned as a {@link @firebase/firestore/pipelines#PipelineSnapshot} that contains\n * a list of {@link @firebase/firestore/pipelines#PipelineResult} objects. Each {@link @firebase/firestore/pipelines#PipelineResult} typically\n * represents a single key/value map that has passed through all the\n * stages of the pipeline, however this might differ depending on the stages involved in the\n * pipeline. For example:\n *\n * <ul>\n *   <li>If there are no stages or only transformation stages, each {@link @firebase/firestore/pipelines#PipelineResult}\n *       represents a single document.</li>\n *   <li>If there is an aggregation, only a single {@link @firebase/firestore/pipelines#PipelineResult} is returned,\n *       representing the aggregated results over the entire dataset .</li>\n *   <li>If there is an aggregation stage with grouping, each {@link @firebase/firestore/pipelines#PipelineResult} represents a\n *       distinct group and its associated aggregated values.</li>\n * </ul>\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await execute(firestore.pipeline().collection(\"books\")\n *     .where(gt(field(\"rating\"), 4.5))\n *     .select(\"title\", \"author\", \"rating\"));\n *\n * const results: PipelineResults = snapshot.results;\n * ```\n *\n * @param pipeline - The pipeline to execute.\n * @returns A Promise representing the asynchronous pipeline execution.\n */\nexport function execute(pipeline: LitePipeline): Promise<PipelineSnapshot>;\n/**\n * @beta\n * Executes a pipeline and returns a Promise to represent the asynchronous operation.\n *\n * The returned Promise can be used to track the progress of the pipeline execution\n * and retrieve the results (or handle any errors) asynchronously.\n *\n * The pipeline results are returned as a {@link @firebase/firestore/pipelines#PipelineSnapshot} that contains\n * a list of {@link @firebase/firestore/pipelines#PipelineResult} objects. Each {@link @firebase/firestore/pipelines#PipelineResult} typically\n * represents a single key/value map that has passed through all the\n * stages of the pipeline, however this might differ depending on the stages involved in the\n * pipeline. For example:\n *\n * <ul>\n *   <li>If there are no stages or only transformation stages, each {@link @firebase/firestore/pipelines#PipelineResult}\n *       represents a single document.</li>\n *   <li>If there is an aggregation, only a single {@link @firebase/firestore/pipelines#PipelineResult} is returned,\n *       representing the aggregated results over the entire dataset .</li>\n *   <li>If there is an aggregation stage with grouping, each {@link @firebase/firestore/pipelines#PipelineResult} represents a\n *       distinct group and its associated aggregated values.</li>\n * </ul>\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await execute(firestore.pipeline().collection(\"books\")\n *     .where(gt(field(\"rating\"), 4.5))\n *     .select(\"title\", \"author\", \"rating\"));\n *\n * const results: PipelineResults = snapshot.results;\n * ```\n *\n * @param options - Specifies the pipeline to execute and other options for execute.\n * @returns A Promise representing the asynchronous pipeline execution.\n */\nexport function execute(\n  options: PipelineExecuteOptions\n): Promise<PipelineSnapshot>;\nexport function execute(\n  pipelineOrOptions: LitePipeline | PipelineExecuteOptions\n): Promise<PipelineSnapshot> {\n  const options: PipelineExecuteOptions = !(\n    pipelineOrOptions instanceof LitePipeline\n  )\n    ? pipelineOrOptions\n    : {\n        pipeline: pipelineOrOptions\n      };\n\n  const { pipeline, rawOptions, ...rest } = options;\n\n  const firestore = cast(pipeline._db, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n\n  const udr = new UserDataReader(\n    firestore._databaseId,\n    /* ignoreUndefinedProperties */ true\n  );\n  const context = udr.createContext(UserDataSource.Argument, 'execute');\n\n  const structuredPipelineOptions = new StructuredPipelineOptions(\n    rest,\n    rawOptions\n  );\n  structuredPipelineOptions._readUserData(context);\n\n  const structuredPipeline: StructuredPipeline = new StructuredPipeline(\n    pipeline,\n    structuredPipelineOptions\n  );\n\n  return firestoreClientExecutePipeline(client, structuredPipeline).then(\n    result => {\n      // Get the execution time from the first result.\n      // firestoreClientExecutePipeline returns at least one PipelineStreamElement\n      // even if the returned document set is empty.\n      const executionTime =\n        result.length > 0 ? result[0].executionTime?.toTimestamp() : undefined;\n\n      const docs = result\n        // Currently ignore any response from ExecutePipeline that does\n        // not contain any document data in the `fields` property.\n        .filter(element => !!element.fields)\n        .map(\n          element =>\n            new PipelineResult(\n              pipeline._userDataWriter,\n              element.fields!,\n              element.key?.path\n                ? new DocumentReference(firestore, null, element.key)\n                : undefined,\n              element.createTime?.toTimestamp(),\n              element.updateTime?.toTimestamp()\n            )\n        );\n\n      return new PipelineSnapshot(pipeline, docs, executionTime);\n    }\n  );\n}\n\n/**\n * @beta\n * Creates and returns a new PipelineSource, which allows specifying the source stage of a {@link @firebase/firestore/pipelines#Pipeline}.\n *\n * @example\n * ```\n * let myPipeline: Pipeline = firestore.pipeline().collection('books');\n * ```\n */\n// Augment the Firestore class with the pipeline() factory method\nFirestore.prototype.pipeline = function (): PipelineSource<Pipeline> {\n  const userDataReader = newUserDataReader(this);\n  return new PipelineSource<Pipeline>(\n    this._databaseId,\n    userDataReader,\n    (stages: Stage[]) => {\n      return new Pipeline(\n        this,\n        userDataReader,\n        new ExpUserDataWriter(this),\n        stages\n      );\n    }\n  );\n};\n"],"names":["__PRIVATE_isFirestoreValue","obj","nullValue","booleanValue","integerValue","doubleValue","timestampValue","__PRIVATE_isITimestamp","seconds","nanos","stringValue","bytesValue","Uint8Array","referenceValue","geoPointValue","__PRIVATE_isILatLng","latitude","longitude","arrayValue","__PRIVATE_isIArrayValue","values","Array","isArray","mapValue","__PRIVATE_isIMapValue","fields","__PRIVATE_isPlainObject","fieldReferenceValue","functionValue","__PRIVATE_isIFunction","name","args","pipelineValue","__PRIVATE_isIPipeline","stages","__PRIVATE_valueToDefaultExpr","value","result","Expression","__PRIVATE__map","array","__PRIVATE__constant","undefined","__PRIVATE_vectorToExpr","VectorValue","constant","vector","Error","__PRIVATE_fieldOrExpression","__PRIVATE_isString","field","constructor","this","_protoValueType","add","second","FunctionExpression","asBoolean","BooleanExpression","Constant","__PRIVATE_BooleanConstant","Field","__PRIVATE_BooleanField","__PRIVATE_BooleanFunctionExpression","FirestoreError","subtract","subtrahend","multiply","divide","divisor","mod","other","equal","notEqual","lessThan","lessThanOrEqual","greaterThan","greaterThanOrEqual","arrayConcat","secondArray","otherArrays","__PRIVATE_exprValues","map","arrayContains","element","arrayContainsAll","__PRIVATE_normalizedExpr","__PRIVATE_ListOfExprs","arrayContainsAny","arrayReverse","arrayLength","equalAny","others","__PRIVATE_exprOthers","notEqualAny","exists","charLength","like","__PRIVATE_stringOrExpr","regexContains","regexMatch","stringContains","startsWith","endsWith","toLower","toUpper","trim","valueToTrim","push","stringConcat","secondString","otherStrings","__PRIVATE_exprs","concat","reverse","byteLength","ceil","floor","abs","exp","mapGet","subfield","count","AggregateFunction","_create","sum","average","minimum","maximum","countDistinct","logicalMaximum","logicalMinimum","vectorLength","cosineDistance","dotProduct","euclideanDistance","unixMicrosToTimestamp","timestampToUnixMicros","unixMillisToTimestamp","timestampToUnixMillis","unixSecondsToTimestamp","timestampToUnixSeconds","timestampAdd","unit","amount","timestampSubtract","documentId","substring","position","length","__PRIVATE_positionExpr","arrayGet","offset","isError","ifError","catchValue","isAbsent","mapRemove","__PRIVATE_stringExpr","mapMerge","secondMap","otherMaps","__PRIVATE_secondMapExpr","__PRIVATE_otherMapExprs","pow","exponent","round","decimalPlaces","collectionId","ln","sqrt","stringReverse","ifAbsent","__PRIVATE_elseValueOrExpression","join","__PRIVATE_delimeterValueOrExpression","log10","arraySum","split","delimiter","timestampTruncate","granularity","timezone","toLowerCase","type","ascending","descending","as","AliasedExpression","params","exprType","methodName","__PRIVATE_af","_methodName","AliasedAggregate","_toProto","serializer","p","_readUserData","context","contextWith","forEach","expr","aggregate","alias","selectable","super","expressionType","fieldPath","fieldName","canonicalString","nameOrPath","_field","__PRIVATE_DOCUMENT_KEY_NAME","__PRIVATE_documentIdFieldPath","_internalPath","__PRIVATE_fieldPathFromArgument","_fromProto","_protoValue","_","__PRIVATE_hardAssert","__PRIVATE_parseData","c","MapValue","__PRIVATE_plainObject","__PRIVATE_toMapValue","_expr","countIf","not","conditional","thenExpr","elseExpr","__PRIVATE_normalizedCatchValue","booleanExpr","tryExpr","mapExpr","firstMap","documentPath","__PRIVATE_fieldExpr","__PRIVATE_lengthExpr","first","left","right","__PRIVATE_normalizedLeft","__PRIVATE_normalizedRight","elements","key","Object","prototype","hasOwnProperty","call","__PRIVATE__array","__PRIVATE_leftExpr","__PRIVATE_rightExpr","firstArray","__PRIVATE_arrayExpr","__PRIVATE_elementExpr","xor","additionalConditions","condition","__PRIVATE_valueOrField","__PRIVATE_expressionOrFieldName","pattern","__PRIVATE_patternExpr","__PRIVATE_substringExpr","prefix","suffix","__PRIVATE_fieldOrExpr","subField","countAll","__PRIVATE_expr1","__PRIVATE_expr2","timestamp","__PRIVATE_normalizedTimestamp","__PRIVATE_normalizedUnit","__PRIVATE_normalizedAmount","currentTimestamp","and","more","or","base","log","__PRIVATE_fieldNameOrExpression","elseValue","__PRIVATE_delimiterValueOrExpression","__PRIVATE_internalGranularity","Ordering","direction","__PRIVATE_toStringValue","expression","__PRIVATE_isSelectable","val","candidate","__PRIVATE_isExpr","__PRIVATE_isOrdering","__PRIVATE_isAliasedAggregate","__PRIVATE_isBooleanExpr","__PRIVATE_isField","__PRIVATE_toField","__PRIVATE_toPipelineBooleanExpr","f","__PRIVATE_FieldFilterInternal","fieldValue","toString","op","fail","__PRIVATE_CompositeFilterInternal","__PRIVATE_conditions","getFilters","slice","__PRIVATE_toPipeline","query","db","pipeline","__PRIVATE_isCollectionGroupQuery","collectionGroup","__PRIVATE_isDocumentQuery","documents","doc","path","collection","filter","filters","where","__PRIVATE_orders","__PRIVATE_queryNormalizedOrderBy","__PRIVATE_existsConditions","order","orderings","dir","limitType","__PRIVATE_actualOrderings","__PRIVATE_reverseOrderings","o","sort","startAt","__PRIVATE_whereConditionsFromCursor","endAt","limit","bound","__PRIVATE_filterFunc","__PRIVATE_cursors","size","inclusive","__PRIVATE_i","Stage","options","optionsProto","rawOptions","knownOptions","_optionsUtil","getOptionsProto","_name","__PRIVATE_AddFields","OptionsUtil","__PRIVATE_readUserDataHelper","__PRIVATE_RemoveFields","__PRIVATE_Aggregate","groups","accumulators","__PRIVATE_Distinct","__PRIVATE_CollectionSource","forceIndex","serverName","__PRIVATE_formattedCollectionPath","__PRIVATE_CollectionGroupSource","__PRIVATE_DatabaseSource","__PRIVATE_DocumentsSource","__PRIVATE_docPaths","__PRIVATE_formattedPaths","__PRIVATE_Where","__PRIVATE_FindNearest","distanceField","vectorValue","distanceMeasure","__PRIVATE_Limit","isNaN","Infinity","toNumber","__PRIVATE_Offset","__PRIVATE_Select","selections","__PRIVATE_Sort","__PRIVATE_Sample","rate","mode","__PRIVATE_Union","__PRIVATE_toPipelineValue","__PRIVATE_Unnest","indexField","__PRIVATE_Replace","__PRIVATE_MODE","__PRIVATE_RawStage","__PRIVATE_expressionMap","__PRIVATE_isUserData","__PRIVATE_readableData","PipelineSource","databaseId","userDataReader","_createPipeline","__PRIVATE_collectionOrOptions","__PRIVATE_isCollectionReference","__PRIVATE_collectionRefOrString","_validateReference","__PRIVATE_normalizedCollection","__PRIVATE_stage","__PRIVATE_parseContext","createContext","__PRIVATE_collectionIdOrOptions","database","__PRIVATE_docsOrOptions","docs","v","DocumentReference","__PRIVATE_dr","__PRIVATE_normalizedDocs","createFrom","_query","firestore","reference","__PRIVATE_refDbId","_databaseId","isEqual","Code","INVALID_ARGUMENT","CollectionReference","projectId","PipelineSnapshot","results","executionTime","_pipeline","_executionTime","_results","PipelineResult","userDataWriter","ref","createTime","updateTime","_ref","_userDataWriter","_createTime","_updateTime","_fields","id","data","convertValue","_fieldsProto","clone","get","pipelineResultEqual","__PRIVATE_isOptionalEqual","refEqual","l","r","__PRIVATE_selectablesToMap","__PRIVATE_selectables","Map","set","Pipeline","_db","addFields","__PRIVATE_fieldOrOptions","additionalFields","__PRIVATE_normalizedFields","_addStage","removeFields","__PRIVATE_fieldValueOrOptions","__PRIVATE_convertedFields","select","__PRIVATE_selectionOrOptions","additionalSelections","__PRIVATE_normalizedSelections","__PRIVATE_conditionOrOptions","__PRIVATE_offsetOrOptions","__PRIVATE_isNumber","__PRIVATE_limitOrOptions","distinct","__PRIVATE_groupOrOptions","additionalGroups","__PRIVATE_convertedGroups","__PRIVATE_targetOrOptions","__PRIVATE_rest","__PRIVATE_convertedAccumulators","__PRIVATE_aliasedAggregateToMap","__PRIVATE_aliasedAggregatees","reduce","findNearest","__PRIVATE_internalOptions","__PRIVATE_orderingOrOptions","additionalOrderings","replaceWith","__PRIVATE_valueOrOptions","sample","__PRIVATE_documentsOrOptions","percentage","union","__PRIVATE_otherOrOptions","__PRIVATE_otherPipeline","__PRIVATE_isPipeline","unnest","__PRIVATE_selectableOrOptions","__PRIVATE_indexFieldName","rawStage","__PRIVATE_expressionParams","__PRIVATE__mapValue","jsonProtoSerializer","copy","s","newPipeline","__PRIVATE_LitePipeline","execute","__PRIVATE_pipelineOrOptions","__PRIVATE_cast","Firestore","__PRIVATE_client","ensureFirestoreConfigured","UserDataReader","__PRIVATE_structuredPipelineOptions","__PRIVATE_StructuredPipelineOptions","structuredPipeline","StructuredPipeline","__PRIVATE_firestoreClientExecutePipeline","then","toTimestamp","__PRIVATE_newUserDataReader","__PRIVATE_ExpUserDataWriter"],"mappings":"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"}