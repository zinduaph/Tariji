{"version":3,"file":"pipelines.node.mjs","sources":["../../../src/core/options_util.ts","../../../src/core/structured_pipeline.ts","../../../src/util/proto.ts","../../../src/lite-api/expressions.ts","../../../src/core/pipeline-util.ts","../../../src/lite-api/stage.ts","../../../src/lite-api/pipeline-source.ts","../../../src/lite-api/pipeline-result.ts","../../../src/util/pipeline_util.ts","../../../src/lite-api/pipeline.ts","../../../src/lite-api/pipeline_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParseContext } from '../api/parse_context';\nimport { parseData } from '../lite-api/user_data_reader';\nimport { ObjectValue } from '../model/object_value';\nimport { FieldPath } from '../model/path';\nimport { ApiClientObjectMap, Value } from '../protos/firestore_proto_api';\nimport { isPlainObject } from '../util/input_validation';\nimport { mapToArray } from '../util/obj';\nexport type OptionsDefinitions = Record<string, OptionDefinition>;\nexport interface OptionDefinition {\n  serverName: string;\n  nestedOptions?: OptionsDefinitions;\n}\n\nexport class OptionsUtil {\n  constructor(private optionDefinitions: OptionsDefinitions) {}\n\n  private _getKnownOptions(\n    options: Record<string, unknown>,\n    context: ParseContext\n  ): ObjectValue {\n    const knownOptions: ObjectValue = ObjectValue.empty();\n\n    // SERIALIZE KNOWN OPTIONS\n    for (const knownOptionKey in this.optionDefinitions) {\n      if (this.optionDefinitions.hasOwnProperty(knownOptionKey)) {\n        const optionDefinition: OptionDefinition =\n          this.optionDefinitions[knownOptionKey];\n\n        if (knownOptionKey in options) {\n          const optionValue: unknown = options[knownOptionKey];\n          let protoValue: Value | undefined = undefined;\n\n          if (optionDefinition.nestedOptions && isPlainObject(optionValue)) {\n            const nestedUtil = new OptionsUtil(optionDefinition.nestedOptions);\n            protoValue = {\n              mapValue: {\n                fields: nestedUtil.getOptionsProto(context, optionValue)\n              }\n            };\n          } else if (optionValue) {\n            protoValue = parseData(optionValue, context) ?? undefined;\n          }\n\n          if (protoValue) {\n            knownOptions.set(\n              FieldPath.fromServerFormat(optionDefinition.serverName),\n              protoValue\n            );\n          }\n        }\n      }\n    }\n\n    return knownOptions;\n  }\n\n  getOptionsProto(\n    context: ParseContext,\n    knownOptions: Record<string, unknown>,\n    optionsOverride?: Record<string, unknown>\n  ): ApiClientObjectMap<Value> | undefined {\n    const result: ObjectValue = this._getKnownOptions(knownOptions, context);\n\n    // APPLY OPTIONS OVERRIDES\n    if (optionsOverride) {\n      const optionsMap = new Map(\n        mapToArray(optionsOverride, (value, key) => [\n          FieldPath.fromServerFormat(key),\n          value !== undefined ? parseData(value, context) : null\n        ])\n      );\n      result.setAll(optionsMap);\n    }\n\n    // Return MapValue from `result` or empty map value\n    return result.value.mapValue.fields ?? {};\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParseContext } from '../api/parse_context';\nimport { UserData } from '../lite-api/user_data_reader';\nimport {\n  ApiClientObjectMap,\n  firestoreV1ApiClientInterfaces,\n  Pipeline as PipelineProto,\n  StructuredPipeline as StructuredPipelineProto\n} from '../protos/firestore_proto_api';\nimport { JsonProtoSerializer, ProtoSerializable } from '../remote/serializer';\n\nimport { OptionsUtil } from './options_util';\n\nexport class StructuredPipelineOptions implements UserData {\n  proto: ApiClientObjectMap<firestoreV1ApiClientInterfaces.Value> | undefined;\n\n  readonly optionsUtil = new OptionsUtil({\n    indexMode: {\n      serverName: 'index_mode'\n    }\n  });\n\n  constructor(\n    private _userOptions: Record<string, unknown> = {},\n    private _optionsOverride: Record<string, unknown> = {}\n  ) {}\n\n  _readUserData(context: ParseContext): void {\n    this.proto = this.optionsUtil.getOptionsProto(\n      context,\n      this._userOptions,\n      this._optionsOverride\n    );\n  }\n}\n\nexport class StructuredPipeline\n  implements ProtoSerializable<StructuredPipelineProto>\n{\n  constructor(\n    private pipeline: ProtoSerializable<PipelineProto>,\n    private options: StructuredPipelineOptions\n  ) {}\n\n  _toProto(serializer: JsonProtoSerializer): StructuredPipelineProto {\n    return {\n      pipeline: this.pipeline._toProto(serializer),\n      options: this.options.proto\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ArrayValue as ProtoArrayValue,\n  Function as ProtoFunction,\n  LatLng as ProtoLatLng,\n  MapValue as ProtoMapValue,\n  Pipeline as ProtoPipeline,\n  Timestamp as ProtoTimestamp,\n  Value as ProtoValue\n} from '../protos/firestore_proto_api';\n\nimport { isPlainObject } from './input_validation';\n\n/* eslint @typescript-eslint/no-explicit-any: 0 */\n\nfunction isITimestamp(obj: any): obj is ProtoTimestamp {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'seconds' in obj &&\n    (obj.seconds === null ||\n      typeof obj.seconds === 'number' ||\n      typeof obj.seconds === 'string') &&\n    'nanos' in obj &&\n    (obj.nanos === null || typeof obj.nanos === 'number')\n  ) {\n    return true;\n  }\n\n  return false;\n}\nfunction isILatLng(obj: any): obj is ProtoLatLng {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'latitude' in obj &&\n    (obj.latitude === null || typeof obj.latitude === 'number') &&\n    'longitude' in obj &&\n    (obj.longitude === null || typeof obj.longitude === 'number')\n  ) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIArrayValue(obj: any): obj is ProtoArrayValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('values' in obj && (obj.values === null || Array.isArray(obj.values))) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIMapValue(obj: any): obj is ProtoMapValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('fields' in obj && (obj.fields === null || isPlainObject(obj.fields))) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIFunction(obj: any): obj is ProtoFunction {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'name' in obj &&\n    (obj.name === null || typeof obj.name === 'string') &&\n    'args' in obj &&\n    (obj.args === null || Array.isArray(obj.args))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isIPipeline(obj: any): obj is ProtoPipeline {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('stages' in obj && (obj.stages === null || Array.isArray(obj.stages))) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isFirestoreValue(obj: any): obj is ProtoValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n\n  // Check optional properties and their types\n  if (\n    ('nullValue' in obj &&\n      (obj.nullValue === null || obj.nullValue === 'NULL_VALUE')) ||\n    ('booleanValue' in obj &&\n      (obj.booleanValue === null || typeof obj.booleanValue === 'boolean')) ||\n    ('integerValue' in obj &&\n      (obj.integerValue === null ||\n        typeof obj.integerValue === 'number' ||\n        typeof obj.integerValue === 'string')) ||\n    ('doubleValue' in obj &&\n      (obj.doubleValue === null || typeof obj.doubleValue === 'number')) ||\n    ('timestampValue' in obj &&\n      (obj.timestampValue === null || isITimestamp(obj.timestampValue))) ||\n    ('stringValue' in obj &&\n      (obj.stringValue === null || typeof obj.stringValue === 'string')) ||\n    ('bytesValue' in obj &&\n      (obj.bytesValue === null || obj.bytesValue instanceof Uint8Array)) ||\n    ('referenceValue' in obj &&\n      (obj.referenceValue === null ||\n        typeof obj.referenceValue === 'string')) ||\n    ('geoPointValue' in obj &&\n      (obj.geoPointValue === null || isILatLng(obj.geoPointValue))) ||\n    ('arrayValue' in obj &&\n      (obj.arrayValue === null || isIArrayValue(obj.arrayValue))) ||\n    ('mapValue' in obj &&\n      (obj.mapValue === null || isIMapValue(obj.mapValue))) ||\n    ('fieldReferenceValue' in obj &&\n      (obj.fieldReferenceValue === null ||\n        typeof obj.fieldReferenceValue === 'string')) ||\n    ('functionValue' in obj &&\n      (obj.functionValue === null || isIFunction(obj.functionValue))) ||\n    ('pipelineValue' in obj &&\n      (obj.pipelineValue === null || isIPipeline(obj.pipelineValue)))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirestoreError } from '../api';\nimport { ParseContext } from '../api/parse_context';\nimport {\n  DOCUMENT_KEY_NAME,\n  FieldPath as InternalFieldPath\n} from '../model/path';\nimport { Value as ProtoValue } from '../protos/firestore_proto_api';\nimport {\n  JsonProtoSerializer,\n  ProtoValueSerializable,\n  toMapValue,\n  toStringValue\n} from '../remote/serializer';\nimport { hardAssert } from '../util/assert';\nimport { isPlainObject } from '../util/input_validation';\nimport { isFirestoreValue } from '../util/proto';\nimport { isString } from '../util/types';\n\nimport { Bytes } from './bytes';\nimport { documentId as documentIdFieldPath, FieldPath } from './field_path';\nimport { vector } from './field_value_impl';\nimport { GeoPoint } from './geo_point';\nimport { DocumentReference } from './reference';\nimport { Timestamp } from './timestamp';\nimport { fieldPathFromArgument, parseData, UserData } from './user_data_reader';\nimport { VectorValue } from './vector_value';\n\n/**\n * @beta\n *\n * An enumeration of the different types of expressions.\n */\nexport type ExpressionType =\n  | 'Field'\n  | 'Constant'\n  | 'Function'\n  | 'AggregateFunction'\n  | 'ListOfExpressions'\n  | 'AliasedExpression';\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nfunction valueToDefaultExpr(value: unknown): Expression {\n  let result: Expression | undefined;\n  if (value instanceof Expression) {\n    return value;\n  } else if (isPlainObject(value)) {\n    result = _map(value as Record<string, unknown>, undefined);\n  } else if (value instanceof Array) {\n    result = array(value);\n  } else {\n    result = _constant(value, undefined);\n  }\n\n  return result;\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nfunction vectorToExpr(value: VectorValue | number[] | Expression): Expression {\n  if (value instanceof Expression) {\n    return value;\n  } else if (value instanceof VectorValue) {\n    return constant(value);\n  } else if (Array.isArray(value)) {\n    return constant(vector(value));\n  } else {\n    throw new Error('Unsupported value: ' + typeof value);\n  }\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n * If the input is a string, it is assumed to be a field name, and a\n * field(value) is returned.\n *\n * @private\n * @internal\n * @param value\n */\nfunction fieldOrExpression(value: unknown): Expression {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return valueToDefaultExpr(value);\n  }\n}\n\n/**\n * @beta\n *\n * Represents an expression that can be evaluated to a value within the execution of a {@link\n * @firebase/firestore/pipelines#Pipeline}.\n *\n * Expressions are the building blocks for creating complex queries and transformations in\n * Firestore pipelines. They can represent:\n *\n * - **Field references:** Access values from document fields.\n * - **Literals:** Represent constant values (strings, numbers, booleans).\n * - **Function calls:** Apply functions to one or more expressions.\n *\n * The `Expression` class provides a fluent API for building expressions. You can chain together\n * method calls to create complex expressions.\n */\nexport abstract class Expression implements ProtoValueSerializable, UserData {\n  abstract readonly expressionType: ExpressionType;\n\n  abstract readonly _methodName?: string;\n\n  /**\n   * @private\n   * @internal\n   */\n  abstract _toProto(serializer: JsonProtoSerializer): ProtoValue;\n  _protoValueType = 'ProtoValue' as const;\n\n  /**\n   * @private\n   * @internal\n   */\n  abstract _readUserData(context: ParseContext): void;\n\n  /**\n   * Creates an expression that adds this expression to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Add the value of the 'quantity' field and the 'reserve' field.\n   * field(\"quantity\").add(field(\"reserve\"));\n   * ```\n   *\n   * @param second - The expression or literal to add to this expression.\n   * @param others - Optional additional expressions or literals to add to this expression.\n   * @returns A new `Expression` representing the addition operation.\n   */\n  add(second: Expression | unknown): FunctionExpression {\n    return new FunctionExpression(\n      'add',\n      [this, valueToDefaultExpr(second)],\n      'add'\n    );\n  }\n\n  /**\n   * @beta\n   * Wraps the expression in a [BooleanExpression].\n   *\n   * @returns A [BooleanExpression] representing the same expression.\n   */\n  asBoolean(): BooleanExpression {\n    if (this instanceof BooleanExpression) {\n      return this;\n    } else if (this instanceof Constant) {\n      return new BooleanConstant(this);\n    } else if (this instanceof Field) {\n      return new BooleanField(this);\n    } else if (this instanceof FunctionExpression) {\n      return new BooleanFunctionExpression(this);\n    } else {\n      throw new FirestoreError(\n        'invalid-argument',\n        `Conversion of type ${typeof this} to BooleanExpression not supported.`\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that subtracts another expression from this expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract the 'discount' field from the 'price' field\n   * field(\"price\").subtract(field(\"discount\"));\n   * ```\n   *\n   * @param subtrahend - The expression to subtract from this expression.\n   * @returns A new `Expression` representing the subtraction operation.\n   */\n  subtract(subtrahend: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a constant value from this expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract 20 from the value of the 'total' field\n   * field(\"total\").subtract(20);\n   * ```\n   *\n   * @param subtrahend - The constant value to subtract.\n   * @returns A new `Expression` representing the subtraction operation.\n   */\n  subtract(subtrahend: number): FunctionExpression;\n  subtract(subtrahend: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'subtract',\n      [this, valueToDefaultExpr(subtrahend)],\n      'subtract'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that multiplies this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Multiply the 'quantity' field by the 'price' field\n   * field(\"quantity\").multiply(field(\"price\"));\n   * ```\n   *\n   * @param second - The second expression or literal to multiply by.\n   * @param others - Optional additional expressions or literals to multiply by.\n   * @returns A new `Expression` representing the multiplication operation.\n   */\n  multiply(second: Expression | number): FunctionExpression {\n    return new FunctionExpression(\n      'multiply',\n      [this, valueToDefaultExpr(second)],\n      'multiply'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that divides this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Divide the 'total' field by the 'count' field\n   * field(\"total\").divide(field(\"count\"));\n   * ```\n   *\n   * @param divisor - The expression to divide by.\n   * @returns A new `Expression` representing the division operation.\n   */\n  divide(divisor: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that divides this expression by a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Divide the 'value' field by 10\n   * field(\"value\").divide(10);\n   * ```\n   *\n   * @param divisor - The constant value to divide by.\n   * @returns A new `Expression` representing the division operation.\n   */\n  divide(divisor: number): FunctionExpression;\n  divide(divisor: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'divide',\n      [this, valueToDefaultExpr(divisor)],\n      'divide'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the modulo (remainder) of dividing this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the remainder of dividing the 'value' field by the 'divisor' field\n   * field(\"value\").mod(field(\"divisor\"));\n   * ```\n   *\n   * @param expression - The expression to divide by.\n   * @returns A new `Expression` representing the modulo operation.\n   */\n  mod(expression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that calculates the modulo (remainder) of dividing this expression by a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the remainder of dividing the 'value' field by 10\n   * field(\"value\").mod(10);\n   * ```\n   *\n   * @param value - The constant value to divide by.\n   * @returns A new `Expression` representing the modulo operation.\n   */\n  mod(value: number): FunctionExpression;\n  mod(other: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'mod',\n      [this, valueToDefaultExpr(other)],\n      'mod'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is equal to 21\n   * field(\"age\").equal(21);\n   * ```\n   *\n   * @param expression - The expression to compare for equality.\n   * @returns A new `Expression` representing the equality comparison.\n   */\n  equal(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'city' field is equal to \"London\"\n   * field(\"city\").equal(\"London\");\n   * ```\n   *\n   * @param value - The constant value to compare for equality.\n   * @returns A new `Expression` representing the equality comparison.\n   */\n  equal(value: unknown): BooleanExpression;\n  equal(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'equal',\n      [this, valueToDefaultExpr(other)],\n      'equal'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is not equal to \"completed\"\n   * field(\"status\").notEqual(\"completed\");\n   * ```\n   *\n   * @param expression - The expression to compare for inequality.\n   * @returns A new `Expression` representing the inequality comparison.\n   */\n  notEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'country' field is not equal to \"USA\"\n   * field(\"country\").notEqual(\"USA\");\n   * ```\n   *\n   * @param value - The constant value to compare for inequality.\n   * @returns A new `Expression` representing the inequality comparison.\n   */\n  notEqual(value: unknown): BooleanExpression;\n  notEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'not_equal',\n      [this, valueToDefaultExpr(other)],\n      'notEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is less than 'limit'\n   * field(\"age\").lessThan(field('limit'));\n   * ```\n   *\n   * @param experession - The expression to compare for less than.\n   * @returns A new `Expression` representing the less than comparison.\n   */\n  lessThan(experession: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is less than 50\n   * field(\"price\").lessThan(50);\n   * ```\n   *\n   * @param value - The constant value to compare for less than.\n   * @returns A new `Expression` representing the less than comparison.\n   */\n  lessThan(value: unknown): BooleanExpression;\n  lessThan(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'less_than',\n      [this, valueToDefaultExpr(other)],\n      'lessThan'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than or equal to another\n   * expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'quantity' field is less than or equal to 20\n   * field(\"quantity\").lessThan(constant(20));\n   * ```\n   *\n   * @param expression - The expression to compare for less than or equal to.\n   * @returns A new `Expression` representing the less than or equal to comparison.\n   */\n  lessThanOrEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than or equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'score' field is less than or equal to 70\n   * field(\"score\").lessThan(70);\n   * ```\n   *\n   * @param value - The constant value to compare for less than or equal to.\n   * @returns A new `Expression` representing the less than or equal to comparison.\n   */\n  lessThanOrEqual(value: unknown): BooleanExpression;\n  lessThanOrEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'less_than_or_equal',\n      [this, valueToDefaultExpr(other)],\n      'lessThanOrEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is greater than the 'limit' field\n   * field(\"age\").greaterThan(field(\"limit\"));\n   * ```\n   *\n   * @param expression - The expression to compare for greater than.\n   * @returns A new `Expression` representing the greater than comparison.\n   */\n  greaterThan(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is greater than 100\n   * field(\"price\").greaterThan(100);\n   * ```\n   *\n   * @param value - The constant value to compare for greater than.\n   * @returns A new `Expression` representing the greater than comparison.\n   */\n  greaterThan(value: unknown): BooleanExpression;\n  greaterThan(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'greater_than',\n      [this, valueToDefaultExpr(other)],\n      'greaterThan'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than or equal to another\n   * expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'quantity' field is greater than or equal to field 'requirement' plus 1\n   * field(\"quantity\").greaterThanOrEqual(field('requirement').add(1));\n   * ```\n   *\n   * @param expression - The expression to compare for greater than or equal to.\n   * @returns A new `Expression` representing the greater than or equal to comparison.\n   */\n  greaterThanOrEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than or equal to a constant\n   * value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'score' field is greater than or equal to 80\n   * field(\"score\").greaterThanOrEqual(80);\n   * ```\n   *\n   * @param value - The constant value to compare for greater than or equal to.\n   * @returns A new `Expression` representing the greater than or equal to comparison.\n   */\n  greaterThanOrEqual(value: unknown): BooleanExpression;\n  greaterThanOrEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'greater_than_or_equal',\n      [this, valueToDefaultExpr(other)],\n      'greaterThanOrEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates an array expression with one or more other arrays.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'items' array with another array field.\n   * field(\"items\").arrayConcat(field(\"otherItems\"));\n   * ```\n   * @param secondArray - Second array expression or array literal to concatenate.\n   * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n   * @returns A new `Expression` representing the concatenated array.\n   */\n  arrayConcat(\n    secondArray: Expression | unknown[],\n    ...otherArrays: Array<Expression | unknown[]>\n  ): FunctionExpression {\n    const elements = [secondArray, ...otherArrays];\n    const exprValues = elements.map(value => valueToDefaultExpr(value));\n    return new FunctionExpression(\n      'array_concat',\n      [this, ...exprValues],\n      'arrayConcat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains a specific element.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'sizes' array contains the value from the 'selectedSize' field\n   * field(\"sizes\").arrayContains(field(\"selectedSize\"));\n   * ```\n   *\n   * @param expression - The element to search for in the array.\n   * @returns A new `Expression` representing the 'array_contains' comparison.\n   */\n  arrayContains(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains a specific value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'colors' array contains \"red\"\n   * field(\"colors\").arrayContains(\"red\");\n   * ```\n   *\n   * @param value - The element to search for in the array.\n   * @returns A new `Expression` representing the 'array_contains' comparison.\n   */\n  arrayContains(value: unknown): BooleanExpression;\n  arrayContains(element: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'array_contains',\n      [this, valueToDefaultExpr(element)],\n      'arrayContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains all the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'tags' array contains both the value in field \"tag1\" and the literal value \"tag2\"\n   * field(\"tags\").arrayContainsAll([field(\"tag1\"), \"tag2\"]);\n   * ```\n   *\n   * @param values - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_all' comparison.\n   */\n  arrayContainsAll(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains all the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'tags' array contains both of the values from field \"tag1\" and the literal value \"tag2\"\n   * field(\"tags\").arrayContainsAll(array([field(\"tag1\"), \"tag2\"]));\n   * ```\n   *\n   * @param arrayExpression - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_all' comparison.\n   */\n  arrayContainsAll(arrayExpression: Expression): BooleanExpression;\n  arrayContainsAll(values: unknown[] | Expression): BooleanExpression {\n    const normalizedExpr = Array.isArray(values)\n      ? new ListOfExprs(values.map(valueToDefaultExpr), 'arrayContainsAll')\n      : values;\n    return new FunctionExpression(\n      'array_contains_all',\n      [this, normalizedExpr],\n      'arrayContainsAll'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains any of the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'categories' array contains either values from field \"cate1\" or \"cate2\"\n   * field(\"categories\").arrayContainsAny([field(\"cate1\"), field(\"cate2\")]);\n   * ```\n   *\n   * @param values - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_any' comparison.\n   */\n  arrayContainsAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains any of the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'groups' array contains either the value from the 'userGroup' field\n   * // or the value \"guest\"\n   * field(\"groups\").arrayContainsAny(array([field(\"userGroup\"), \"guest\"]));\n   * ```\n   *\n   * @param arrayExpression - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_any' comparison.\n   */\n  arrayContainsAny(arrayExpression: Expression): BooleanExpression;\n  arrayContainsAny(\n    values: Array<unknown | Expression> | Expression\n  ): BooleanExpression {\n    const normalizedExpr = Array.isArray(values)\n      ? new ListOfExprs(values.map(valueToDefaultExpr), 'arrayContainsAny')\n      : values;\n    return new FunctionExpression(\n      'array_contains_any',\n      [this, normalizedExpr],\n      'arrayContainsAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses an array.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myArray' field.\n   * field(\"myArray\").arrayReverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n   */\n  arrayReverse(): FunctionExpression {\n    return new FunctionExpression('array_reverse', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of an array.\n   *\n   * @example\n   * ```typescript\n   * // Get the number of items in the 'cart' array\n   * field(\"cart\").arrayLength();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the array.\n   */\n  arrayLength(): FunctionExpression {\n    return new FunctionExpression('array_length', [this], 'arrayLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n   * field(\"category\").equalAny(\"Electronics\", field(\"primaryType\"));\n   * ```\n   *\n   * @param values - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'IN' comparison.\n   */\n  equalAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n   * field(\"category\").equalAny(array([\"Electronics\", field(\"primaryType\")]));\n   * ```\n   *\n   * @param arrayExpression - An expression that evaluates to an array of values to check against.\n   * @returns A new `Expression` representing the 'IN' comparison.\n   */\n  equalAny(arrayExpression: Expression): BooleanExpression;\n  equalAny(others: unknown[] | Expression): BooleanExpression {\n    const exprOthers = Array.isArray(others)\n      ? new ListOfExprs(others.map(valueToDefaultExpr), 'equalAny')\n      : others;\n    return new FunctionExpression(\n      'equal_any',\n      [this, exprOthers],\n      'equalAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n   * field(\"status\").notEqualAny([\"pending\", field(\"rejectedStatus\")]);\n   * ```\n   *\n   * @param values - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'notEqualAny' comparison.\n   */\n  notEqualAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to any of the values in the evaluated expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is not equal to any value in the field 'rejectedStatuses'\n   * field(\"status\").notEqualAny(field('rejectedStatuses'));\n   * ```\n   *\n   * @param arrayExpression - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'notEqualAny' comparison.\n   */\n  notEqualAny(arrayExpression: Expression): BooleanExpression;\n  notEqualAny(others: unknown[] | Expression): BooleanExpression {\n    const exprOthers = Array.isArray(others)\n      ? new ListOfExprs(others.map(valueToDefaultExpr), 'notEqualAny')\n      : others;\n    return new FunctionExpression(\n      'not_equal_any',\n      [this, exprOthers],\n      'notEqualAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a field exists in the document.\n   *\n   * @example\n   * ```typescript\n   * // Check if the document has a field named \"phoneNumber\"\n   * field(\"phoneNumber\").exists();\n   * ```\n   *\n   * @returns A new `Expression` representing the 'exists' check.\n   */\n  exists(): BooleanExpression {\n    return new FunctionExpression('exists', [this], 'exists').asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the character length of a string in UTF-8.\n   *\n   * @example\n   * ```typescript\n   * // Get the character length of the 'name' field in its UTF-8 form.\n   * field(\"name\").charLength();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the string.\n   */\n  charLength(): FunctionExpression {\n    return new FunctionExpression('char_length', [this], 'charLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that performs a case-sensitive string comparison.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'title' field contains the word \"guide\" (case-sensitive)\n   * field(\"title\").like(\"%guide%\");\n   * ```\n   *\n   * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n   * @returns A new `Expression` representing the 'like' comparison.\n   */\n  like(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that performs a case-sensitive string comparison.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'title' field contains the word \"guide\" (case-sensitive)\n   * field(\"title\").like(\"%guide%\");\n   * ```\n   *\n   * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n   * @returns A new `Expression` representing the 'like' comparison.\n   */\n  like(pattern: Expression): BooleanExpression;\n  like(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'like',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'like'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified regular expression as a\n   * substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains \"example\" (case-insensitive)\n   * field(\"description\").regexContains(\"(?i)example\");\n   * ```\n   *\n   * @param pattern - The regular expression to use for the search.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  regexContains(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified regular expression as a\n   * substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains the regular expression stored in field 'regex'\n   * field(\"description\").regexContains(field(\"regex\"));\n   * ```\n   *\n   * @param pattern - The regular expression to use for the search.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  regexContains(pattern: Expression): BooleanExpression;\n  regexContains(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'regex_contains',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string matches a specified regular expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'email' field matches a valid email pattern\n   * field(\"email\").regexMatch(\"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n   * ```\n   *\n   * @param pattern - The regular expression to use for the match.\n   * @returns A new `Expression` representing the regular expression match.\n   */\n  regexMatch(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string matches a specified regular expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'email' field matches a regular expression stored in field 'regex'\n   * field(\"email\").regexMatch(field(\"regex\"));\n   * ```\n   *\n   * @param pattern - The regular expression to use for the match.\n   * @returns A new `Expression` representing the regular expression match.\n   */\n  regexMatch(pattern: Expression): BooleanExpression;\n  regexMatch(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'regex_match',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexMatch'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains \"example\".\n   * field(\"description\").stringContains(\"example\");\n   * ```\n   *\n   * @param substring - The substring to search for.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  stringContains(substring: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains the string represented by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains the value of the 'keyword' field.\n   * field(\"description\").stringContains(field(\"keyword\"));\n   * ```\n   *\n   * @param expr - The expression representing the substring to search for.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  stringContains(expr: Expression): BooleanExpression;\n  stringContains(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'string_contains',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'stringContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string starts with a given prefix.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'name' field starts with \"Mr.\"\n   * field(\"name\").startsWith(\"Mr.\");\n   * ```\n   *\n   * @param prefix - The prefix to check for.\n   * @returns A new `Expression` representing the 'starts with' comparison.\n   */\n  startsWith(prefix: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string starts with a given prefix (represented as an\n   * expression).\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'fullName' field starts with the value of the 'firstName' field\n   * field(\"fullName\").startsWith(field(\"firstName\"));\n   * ```\n   *\n   * @param prefix - The prefix expression to check for.\n   * @returns A new `Expression` representing the 'starts with' comparison.\n   */\n  startsWith(prefix: Expression): BooleanExpression;\n  startsWith(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'starts_with',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'startsWith'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string ends with a given postfix.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'filename' field ends with \".txt\"\n   * field(\"filename\").endsWith(\".txt\");\n   * ```\n   *\n   * @param suffix - The postfix to check for.\n   * @returns A new `Expression` representing the 'ends with' comparison.\n   */\n  endsWith(suffix: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string ends with a given postfix (represented as an\n   * expression).\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'url' field ends with the value of the 'extension' field\n   * field(\"url\").endsWith(field(\"extension\"));\n   * ```\n   *\n   * @param suffix - The postfix expression to check for.\n   * @returns A new `Expression` representing the 'ends with' comparison.\n   */\n  endsWith(suffix: Expression): BooleanExpression;\n  endsWith(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'ends_with',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'endsWith'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts a string to lowercase.\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'name' field to lowercase\n   * field(\"name\").toLower();\n   * ```\n   *\n   * @returns A new `Expression` representing the lowercase string.\n   */\n  toLower(): FunctionExpression {\n    return new FunctionExpression('to_lower', [this], 'toLower');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts a string to uppercase.\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'title' field to uppercase\n   * field(\"title\").toUpper();\n   * ```\n   *\n   * @returns A new `Expression` representing the uppercase string.\n   */\n  toUpper(): FunctionExpression {\n    return new FunctionExpression('to_upper', [this], 'toUpper');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that removes leading and trailing characters from a string or byte array.\n   *\n   * @example\n   * ```typescript\n   * // Trim whitespace from the 'userInput' field\n   * field(\"userInput\").trim();\n   *\n   * // Trim quotes from the 'userInput' field\n   * field(\"userInput\").trim('\"');\n   * ```\n   * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n   * trimmed from the input. If not specified, then whitespace will be trimmed.\n   * @returns A new `Expression` representing the trimmed string or byte array.\n   */\n  trim(valueToTrim?: string | Expression | Bytes): FunctionExpression {\n    const args: Expression[] = [this];\n    if (valueToTrim) {\n      args.push(valueToDefaultExpr(valueToTrim));\n    }\n    return new FunctionExpression('trim', args, 'trim');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates string expressions together.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n   * field(\"firstName\").stringConcat(constant(\" \"), field(\"lastName\"));\n   * ```\n   *\n   * @param secondString - The additional expression or string literal to concatenate.\n   * @param otherStrings - Optional additional expressions or string literals to concatenate.\n   * @returns A new `Expression` representing the concatenated string.\n   */\n  stringConcat(\n    secondString: Expression | string,\n    ...otherStrings: Array<Expression | string>\n  ): FunctionExpression {\n    const elements = [secondString, ...otherStrings];\n    const exprs = elements.map(valueToDefaultExpr);\n    return new FunctionExpression(\n      'string_concat',\n      [this, ...exprs],\n      'stringConcat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates expression results together.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'firstName', ' ', and 'lastName' fields into a single value.\n   * field(\"firstName\").concat(constant(\" \"), field(\"lastName\"));\n   * ```\n   *\n   * @param second - The additional expression or literal to concatenate.\n   * @param others - Optional additional expressions or literals to concatenate.\n   * @returns A new `Expression` representing the concatenated value.\n   */\n  concat(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const elements = [second, ...others];\n    const exprs = elements.map(valueToDefaultExpr);\n    return new FunctionExpression('concat', [this, ...exprs], 'concat');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses this string expression.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myString' field.\n   * field(\"myString\").reverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n   */\n  reverse(): FunctionExpression {\n    return new FunctionExpression('reverse', [this], 'reverse');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of this string expression in bytes.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the length of the 'myString' field in bytes.\n   * field(\"myString\").byteLength();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n   */\n  byteLength(): FunctionExpression {\n    return new FunctionExpression('byte_length', [this], 'byteLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the ceiling of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the ceiling of the 'price' field.\n   * field(\"price\").ceil();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n   */\n  ceil(): FunctionExpression {\n    return new FunctionExpression('ceil', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the floor of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the floor of the 'price' field.\n   * field(\"price\").floor();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n   */\n  floor(): FunctionExpression {\n    return new FunctionExpression('floor', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the absolute value of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the absolute value of the 'price' field.\n   * field(\"price\").abs();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n   */\n  abs(): FunctionExpression {\n    return new FunctionExpression('abs', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes e to the power of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Compute e to the power of the 'value' field.\n   * field(\"value\").exp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n   */\n  exp(): FunctionExpression {\n    return new FunctionExpression('exp', [this]);\n  }\n\n  /**\n   * @beta\n   * Accesses a value from a map (object) field using the provided key.\n   *\n   * @example\n   * ```typescript\n   * // Get the 'city' value from the 'address' map field\n   * field(\"address\").mapGet(\"city\");\n   * ```\n   *\n   * @param subfield - The key to access in the map.\n   * @returns A new `Expression` representing the value associated with the given key in the map.\n   */\n  mapGet(subfield: string): FunctionExpression {\n    return new FunctionExpression(\n      'map_get',\n      [this, constant(subfield)],\n      'mapGet'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that counts the number of stage inputs with valid evaluations of the\n   * expression or field.\n   *\n   * @example\n   * ```typescript\n   * // Count the total number of products\n   * field(\"productId\").count().as(\"totalProducts\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'count' aggregation.\n   */\n  count(): AggregateFunction {\n    return AggregateFunction._create('count', [this], 'count');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that calculates the sum of a numeric field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the total revenue from a set of orders\n   * field(\"orderAmount\").sum().as(\"totalRevenue\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'sum' aggregation.\n   */\n  sum(): AggregateFunction {\n    return AggregateFunction._create('sum', [this], 'sum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that calculates the average (mean) of a numeric field across multiple\n   * stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average age of users\n   * field(\"age\").average().as(\"averageAge\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'average' aggregation.\n   */\n  average(): AggregateFunction {\n    return AggregateFunction._create('average', [this], 'average');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the minimum value of a field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the lowest price of all products\n   * field(\"price\").minimum().as(\"lowestPrice\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'minimum' aggregation.\n   */\n  minimum(): AggregateFunction {\n    return AggregateFunction._create('minimum', [this], 'minimum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the maximum value of a field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the highest score in a leaderboard\n   * field(\"score\").maximum().as(\"highestScore\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'maximum' aggregation.\n   */\n  maximum(): AggregateFunction {\n    return AggregateFunction._create('maximum', [this], 'maximum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that counts the number of distinct values of the expression or field.\n   *\n   * @example\n   * ```typescript\n   * // Count the distinct number of products\n   * field(\"productId\").countDistinct().as(\"distinctProducts\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'count_distinct' aggregation.\n   */\n  countDistinct(): AggregateFunction {\n    return AggregateFunction._create('count_distinct', [this], 'countDistinct');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the larger value between this expression and another expression, based on Firestore's value type ordering.\n   *\n   * @example\n   * ```typescript\n   * // Returns the larger value between the 'timestamp' field and the current timestamp.\n   * field(\"timestamp\").logicalMaximum(Function.currentTimestamp());\n   * ```\n   *\n   * @param second - The second expression or literal to compare with.\n   * @param others - Optional additional expressions or literals to compare with.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n   */\n  logicalMaximum(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const values = [second, ...others];\n    return new FunctionExpression(\n      'maximum',\n      [this, ...values.map(valueToDefaultExpr)],\n      'logicalMaximum'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the smaller value between this expression and another expression, based on Firestore's value type ordering.\n   *\n   * @example\n   * ```typescript\n   * // Returns the smaller value between the 'timestamp' field and the current timestamp.\n   * field(\"timestamp\").logicalMinimum(Function.currentTimestamp());\n   * ```\n   *\n   * @param second - The second expression or literal to compare with.\n   * @param others - Optional additional expressions or literals to compare with.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n   */\n  logicalMinimum(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const values = [second, ...others];\n    return new FunctionExpression(\n      'minimum',\n      [this, ...values.map(valueToDefaultExpr)],\n      'minimum'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length (number of dimensions) of this Firestore Vector expression.\n   *\n   * @example\n   * ```typescript\n   * // Get the vector length (dimension) of the field 'embedding'.\n   * field(\"embedding\").vectorLength();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the vector.\n   */\n  vectorLength(): FunctionExpression {\n    return new FunctionExpression('vector_length', [this], 'vectorLength');\n  }\n\n  /**\n   * @beta\n   * Calculates the cosine distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n   * field(\"userVector\").cosineDistance(field(\"itemVector\"));\n   * ```\n   *\n   * @param vectorExpression - The other vector (represented as an Expression) to compare against.\n   * @returns A new `Expression` representing the cosine distance between the two vectors.\n   */\n  cosineDistance(vectorExpression: Expression): FunctionExpression;\n  /**\n   * @beta\n   * Calculates the Cosine distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Cosine distance between the 'location' field and a target location\n   * field(\"location\").cosineDistance(new VectorValue([37.7749, -122.4194]));\n   * ```\n   *\n   * @param vector - The other vector (as a VectorValue) to compare against.\n   * @returns A new `Expression` representing the Cosine* distance between the two vectors.\n   */\n  cosineDistance(vector: VectorValue | number[]): FunctionExpression;\n  cosineDistance(\n    other: Expression | VectorValue | number[]\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'cosine_distance',\n      [this, vectorToExpr(other)],\n      'cosineDistance'\n    );\n  }\n\n  /**\n   * @beta\n   * Calculates the dot product between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the dot product between a feature vector and a target vector\n   * field(\"features\").dotProduct([0.5, 0.8, 0.2]);\n   * ```\n   *\n   * @param vectorExpression - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the dot product between the two vectors.\n   */\n  dotProduct(vectorExpression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Calculates the dot product between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the dot product between a feature vector and a target vector\n   * field(\"features\").dotProduct(new VectorValue([0.5, 0.8, 0.2]));\n   * ```\n   *\n   * @param vector - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the dot product between the two vectors.\n   */\n  dotProduct(vector: VectorValue | number[]): FunctionExpression;\n  dotProduct(other: Expression | VectorValue | number[]): FunctionExpression {\n    return new FunctionExpression(\n      'dot_product',\n      [this, vectorToExpr(other)],\n      'dotProduct'\n    );\n  }\n\n  /**\n   * @beta\n   * Calculates the Euclidean distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Euclidean distance between the 'location' field and a target location\n   * field(\"location\").euclideanDistance([37.7749, -122.4194]);\n   * ```\n   *\n   * @param vectorExpression - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the Euclidean distance between the two vectors.\n   */\n  euclideanDistance(vectorExpression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Calculates the Euclidean distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Euclidean distance between the 'location' field and a target location\n   * field(\"location\").euclideanDistance(new VectorValue([37.7749, -122.4194]));\n   * ```\n   *\n   * @param vector - The other vector (as a VectorValue) to compare against.\n   * @returns A new `Expression` representing the Euclidean distance between the two vectors.\n   */\n  euclideanDistance(vector: VectorValue | number[]): FunctionExpression;\n  euclideanDistance(\n    other: Expression | VectorValue | number[]\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'euclidean_distance',\n      [this, vectorToExpr(other)],\n      'euclideanDistance'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'microseconds' field as microseconds since epoch.\n   * field(\"microseconds\").unixMicrosToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixMicrosToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_micros_to_timestamp',\n      [this],\n      'unixMicrosToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to microseconds since epoch.\n   * field(\"timestamp\").timestampToUnixMicros();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n   */\n  timestampToUnixMicros(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_micros',\n      [this],\n      'timestampToUnixMicros'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'milliseconds' field as milliseconds since epoch.\n   * field(\"milliseconds\").unixMillisToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixMillisToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_millis_to_timestamp',\n      [this],\n      'unixMillisToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to milliseconds since epoch.\n   * field(\"timestamp\").timestampToUnixMillis();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n   */\n  timestampToUnixMillis(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_millis',\n      [this],\n      'timestampToUnixMillis'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'seconds' field as seconds since epoch.\n   * field(\"seconds\").unixSecondsToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixSecondsToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_seconds_to_timestamp',\n      [this],\n      'unixSecondsToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to seconds since epoch.\n   * field(\"timestamp\").timestampToUnixSeconds();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n   */\n  timestampToUnixSeconds(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_seconds',\n      [this],\n      'timestampToUnixSeconds'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that adds a specified amount of time to this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Add some duration determined by field 'unit' and 'amount' to the 'timestamp' field.\n   * field(\"timestamp\").timestampAdd(field(\"unit\"), field(\"amount\"));\n   * ```\n   *\n   * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n   * @param amount - The expression evaluates to amount of the unit.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampAdd(unit: Expression, amount: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that adds a specified amount of time to this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Add 1 day to the 'timestamp' field.\n   * field(\"timestamp\").timestampAdd(\"day\", 1);\n   * ```\n   *\n   * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n   * @param amount - The amount of time to add.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampAdd(\n    unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n    amount: number\n  ): FunctionExpression;\n  timestampAdd(\n    unit:\n      | Expression\n      | 'microsecond'\n      | 'millisecond'\n      | 'second'\n      | 'minute'\n      | 'hour'\n      | 'day',\n    amount: Expression | number\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_add',\n      [this, valueToDefaultExpr(unit), valueToDefaultExpr(amount)],\n      'timestampAdd'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a specified amount of time from this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract some duration determined by field 'unit' and 'amount' from the 'timestamp' field.\n   * field(\"timestamp\").timestampSubtract(field(\"unit\"), field(\"amount\"));\n   * ```\n   *\n   * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n   * @param amount - The expression evaluates to amount of the unit.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampSubtract(unit: Expression, amount: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a specified amount of time from this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract 1 day from the 'timestamp' field.\n   * field(\"timestamp\").timestampSubtract(\"day\", 1);\n   * ```\n   *\n   * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n   * @param amount - The amount of time to subtract.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampSubtract(\n    unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n    amount: number\n  ): FunctionExpression;\n  timestampSubtract(\n    unit:\n      | Expression\n      | 'microsecond'\n      | 'millisecond'\n      | 'second'\n      | 'minute'\n      | 'hour'\n      | 'day',\n    amount: Expression | number\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_subtract',\n      [this, valueToDefaultExpr(unit), valueToDefaultExpr(amount)],\n      'timestampSubtract'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the document ID from a path.\n   *\n   * @example\n   * ```typescript\n   * // Get the document ID from a path.\n   * field(\"__path__\").documentId();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n   */\n  documentId(): FunctionExpression {\n    return new FunctionExpression('document_id', [this], 'documentId');\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns a substring of the results of this expression.\n   *\n   * @param position - Index of the first character of the substring.\n   * @param length - Length of the substring. If not provided, the substring will\n   * end at the end of the input.\n   */\n  substring(position: number, length?: number): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns a substring of the results of this expression.\n   *\n   * @param position - An expression returning the index of the first character of the substring.\n   * @param length - An expression returning the length of the substring. If not provided the\n   * substring will end at the end of the input.\n   */\n  substring(position: Expression, length?: Expression): FunctionExpression;\n  substring(\n    position: Expression | number,\n    length?: Expression | number\n  ): FunctionExpression {\n    const positionExpr = valueToDefaultExpr(position);\n    if (length === undefined) {\n      return new FunctionExpression(\n        'substring',\n        [this, positionExpr],\n        'substring'\n      );\n    } else {\n      return new FunctionExpression(\n        'substring',\n        [this, positionExpr, valueToDefaultExpr(length)],\n        'substring'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that indexes into an array from the beginning or end\n   * and returns the element. If the offset exceeds the array length, an error is\n   * returned. A negative offset, starts from the end.\n   *\n   * @example\n   * ```typescript\n   * // Return the value in the 'tags' field array at index `1`.\n   * field('tags').arrayGet(1);\n   * ```\n   *\n   * @param offset - The index of the element to return.\n   * @returns A new `Expression` representing the 'arrayGet' operation.\n   */\n  arrayGet(offset: number): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that indexes into an array from the beginning or end\n   * and returns the element. If the offset exceeds the array length, an error is\n   * returned. A negative offset, starts from the end.\n   *\n   * @example\n   * ```typescript\n   * // Return the value in the tags field array at index specified by field\n   * // 'favoriteTag'.\n   * field('tags').arrayGet(field('favoriteTag'));\n   * ```\n   *\n   * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n   * @returns A new `Expression` representing the 'arrayGet' operation.\n   */\n  arrayGet(offsetExpr: Expression): FunctionExpression;\n  arrayGet(offset: Expression | number): FunctionExpression {\n    return new FunctionExpression(\n      'array_get',\n      [this, valueToDefaultExpr(offset)],\n      'arrayGet'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that checks if a given expression produces an error.\n   *\n   * @example\n   * ```typescript\n   * // Check if the result of a calculation is an error\n   * field(\"title\").arrayContains(1).isError();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#BooleanExpression} representing the 'isError' check.\n   */\n  isError(): BooleanExpression {\n    return new FunctionExpression('is_error', [this], 'isError').asBoolean();\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the result of the `catchExpr` argument\n   * if there is an error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Returns the first item in the title field arrays, or returns\n   * // the entire title field if the array is empty or the field is another type.\n   * field(\"title\").arrayGet(0).ifError(field(\"title\"));\n   * ```\n   *\n   * @param catchExpr - The catch expression that will be evaluated and\n   * returned if this expression produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchExpr: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Returns the first item in the title field arrays, or returns\n   * // \"Default Title\"\n   * field(\"title\").arrayGet(0).ifError(\"Default Title\");\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: unknown): FunctionExpression;\n  ifError(catchValue: unknown): FunctionExpression | BooleanExpression {\n    const result = new FunctionExpression(\n      'if_error',\n      [this, valueToDefaultExpr(catchValue)],\n      'ifError'\n    );\n\n    return catchValue instanceof BooleanExpression\n      ? result.asBoolean()\n      : result;\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns `true` if the result of this expression\n   * is absent. Otherwise, returns `false` even if the value is `null`.\n   *\n   * @example\n   * ```typescript\n   * // Check if the field `value` is absent.\n   * field(\"value\").isAbsent();\n   * @example\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#BooleanExpression} representing the 'isAbsent' check.\n   */\n  isAbsent(): BooleanExpression {\n    return new FunctionExpression('is_absent', [this], 'isAbsent').asBoolean();\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that removes a key from the map produced by evaluating this expression.\n   *\n   * @example\n   * ```\n   * // Removes the key 'baz' from the input map.\n   * map({foo: 'bar', baz: true}).mapRemove('baz');\n   * ```\n   *\n   * @param key - The name of the key to remove from the input map.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapRemove' operation.\n   */\n  mapRemove(key: string): FunctionExpression;\n  /**\n   * @beta\n   *\n   * Creates an expression that removes a key from the map produced by evaluating this expression.\n   *\n   * @example\n   * ```\n   * // Removes the key 'baz' from the input map.\n   * map({foo: 'bar', baz: true}).mapRemove(constant('baz'));\n   * @example\n   * ```\n   *\n   * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapRemove' operation.\n   */\n  mapRemove(keyExpr: Expression): FunctionExpression;\n  mapRemove(stringExpr: Expression | string): FunctionExpression {\n    return new FunctionExpression(\n      'map_remove',\n      [this, valueToDefaultExpr(stringExpr)],\n      'mapRemove'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that merges multiple map values.\n   *\n   * @example\n   * ```\n   * // Merges the map in the settings field with, a map literal, and a map in\n   * // that is conditionally returned by another expression\n   * field('settings').mapMerge({ enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n   * ```\n   *\n   * @param secondMap - A required second map to merge. Represented as a literal or\n   * an expression that returns a map.\n   * @param otherMaps - Optional additional maps to merge. Each map is represented\n   * as a literal or an expression that returns a map.\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapMerge' operation.\n   */\n  mapMerge(\n    secondMap: Record<string, unknown> | Expression,\n    ...otherMaps: Array<Record<string, unknown> | Expression>\n  ): FunctionExpression {\n    const secondMapExpr = valueToDefaultExpr(secondMap);\n    const otherMapExprs = otherMaps.map(valueToDefaultExpr);\n    return new FunctionExpression(\n      'map_merge',\n      [this, secondMapExpr, ...otherMapExprs],\n      'mapMerge'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the value of this expression raised to the power of another expression.\n   *\n   * @example\n   * ```typescript\n   * // Raise the value of the 'base' field to the power of the 'exponent' field.\n   * field(\"base\").pow(field(\"exponent\"));\n   * ```\n   *\n   * @param exponent - The expression to raise this expression to the power of.\n   * @returns A new `Expression` representing the power operation.\n   */\n  pow(exponent: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the value of this expression raised to the power of a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Raise the value of the 'base' field to the power of 2.\n   * field(\"base\").pow(2);\n   * ```\n   *\n   * @param exponent - The constant value to raise this expression to the power of.\n   * @returns A new `Expression` representing the power operation.\n   */\n  pow(exponent: number): FunctionExpression;\n  pow(exponent: number | Expression): FunctionExpression {\n    return new FunctionExpression('pow', [this, valueToDefaultExpr(exponent)]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the nearest whole number.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field.\n   * field(\"price\").round();\n   * ```\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(): FunctionExpression;\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field to two decimal places.\n   * field(\"price\").round(2);\n   * ```\n   *\n   * @param decimalPlaces - A constant specifying the rounding precision in decimal places.\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(decimalPlaces: number): FunctionExpression;\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field to two decimal places.\n   * field(\"price\").round(constant(2));\n   * ```\n   *\n   * @param decimalPlaces - An expression specifying the rounding precision in decimal places.\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(decimalPlaces: Expression): FunctionExpression;\n  round(decimalPlaces?: number | Expression): FunctionExpression {\n    if (decimalPlaces === undefined) {\n      return new FunctionExpression('round', [this]);\n    } else {\n      return new FunctionExpression(\n        'round',\n        [this, valueToDefaultExpr(decimalPlaces)],\n        'round'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the collection ID from a path.\n   *\n   * @example\n   * ```typescript\n   * // Get the collection ID from a path.\n   * field(\"__path__\").collectionId();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n   */\n  collectionId(): FunctionExpression {\n    return new FunctionExpression('collection_id', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n   *\n   * @example\n   * ```typescript\n   * // Get the length of the 'name' field.\n   * field(\"name\").length();\n   *\n   * // Get the number of items in the 'cart' array.\n   * field(\"cart\").length();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n   */\n  length(): FunctionExpression {\n    return new FunctionExpression('length', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the natural logarithm of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the natural logarithm of the 'value' field.\n   * field(\"value\").ln();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the natural logarithm of the numeric value.\n   */\n  ln(): FunctionExpression {\n    return new FunctionExpression('ln', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the square root of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the square root of the 'value' field.\n   * field(\"value\").sqrt();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n   */\n  sqrt(): FunctionExpression {\n    return new FunctionExpression('sqrt', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses a string.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myString' field.\n   * field(\"myString\").stringReverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n   */\n  stringReverse(): FunctionExpression {\n    return new FunctionExpression('string_reverse', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the `elseValue` argument if this expression results in an absent value, else\n   * return the result of the this expression evaluation.\n   *\n   * @example\n   * ```typescript\n   * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n   * // if the field is absent.\n   * field(\"optional_field\").ifAbsent(\"default_value\")\n   * ```\n   *\n   * @param elseValue - The value that will be returned if this Expression evaluates to an absent value.\n   * @returns A new [Expression] representing the ifAbsent operation.\n   */\n  ifAbsent(elseValue: unknown): Expression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the `elseValue` argument if this expression results in an absent value, else\n   * return the result of this expression evaluation.\n   *\n   * ```typescript\n   * // Returns the value of the optional field 'optional_field', or if that is\n   * // absent, then returns the value of the field `\n   * field(\"optional_field\").ifAbsent(field('default_field'))\n   * ```\n   *\n   * @param elseExpression - The Expression that will be evaluated if this Expression evaluates to an absent value.\n   * @returns A new [Expression] representing the ifAbsent operation.\n   */\n  ifAbsent(elseExpression: unknown): Expression;\n\n  ifAbsent(elseValueOrExpression: Expression | unknown): Expression {\n    return new FunctionExpression(\n      'if_absent',\n      [this, valueToDefaultExpr(elseValueOrExpression)],\n      'ifAbsent'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that joins the elements of an array into a string.\n   *\n   * @example\n   * ```typescript\n   * // Join the elements of the 'tags' field with the delimiter from the 'separator' field.\n   * field(\"tags\").join(field(\"separator\"))\n   * ```\n   *\n   * @param delimiterExpression - The expression that evaluates to the delimiter string.\n   * @returns A new Expression representing the join operation.\n   */\n  join(delimiterExpression: Expression): Expression;\n\n  /**\n   * @beta\n   * Creates an expression that joins the elements of an array field into a string.\n   *\n   * @example\n   * ```typescript\n   * // Join the elements of the 'tags' field with a comma and space.\n   * field(\"tags\").join(\", \")\n   * ```\n   *\n   * @param delimiter - The string to use as a delimiter.\n   * @returns A new Expression representing the join operation.\n   */\n  join(delimiter: string): Expression;\n\n  join(delimeterValueOrExpression: string | Expression): Expression {\n    return new FunctionExpression(\n      'join',\n      [this, valueToDefaultExpr(delimeterValueOrExpression)],\n      'join'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the base-10 logarithm of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the base-10 logarithm of the 'value' field.\n   * field(\"value\").log10();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the base-10 logarithm of the numeric value.\n   */\n  log10(): FunctionExpression {\n    return new FunctionExpression('log10', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the sum of the elements in an array.\n   *\n   * @example\n   * ```typescript\n   * // Compute the sum of the elements in the 'scores' field.\n   * field(\"scores\").arraySum();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the sum of the elements in the array.\n   */\n  arraySum(): FunctionExpression {\n    return new FunctionExpression('sum', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that splits the result of this expression into an\n   * array of substrings based on the provided delimiter.\n   *\n   * @example\n   * ```typescript\n   * // Split the 'scoresCsv' field on delimiter ','\n   * field('scoresCsv').split(',')\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n   */\n  split(delimiter: string): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that splits the result of this expression into an\n   * array of substrings based on the provided delimiter.\n   *\n   * @example\n   * ```typescript\n   * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n   * field('scores').split(conditional(field('format').equal('csv'), constant(','), constant(':'))\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n   */\n  split(delimiter: Expression): FunctionExpression;\n  split(delimiter: string | Expression): FunctionExpression {\n    return new FunctionExpression('split', [\n      this,\n      valueToDefaultExpr(delimiter)\n    ]);\n  }\n\n  /**\n   * Creates an expression that truncates a timestamp to a specified granularity.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'createdAt' timestamp to the beginning of the day.\n   * field('createdAt').timestampTruncate('day')\n   * ```\n   *\n   * @param granularity - The granularity to truncate to.\n   * @param timezone - The timezone to use for truncation. Valid values are from\n   * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n   * @returns A new `Expression` representing the truncated timestamp.\n   */\n  timestampTruncate(\n    granularity: TimeGranularity,\n    timezone?: string | Expression\n  ): FunctionExpression;\n\n  /**\n   * Creates an expression that truncates a timestamp to a specified granularity.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n   * field('createdAt').timestampTruncate(field('granularity'))\n   * ```\n   *\n   * @param granularity - The granularity to truncate to.\n   * @param timezone - The timezone to use for truncation. Valid values are from\n   * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n   * @returns A new `Expression` representing the truncated timestamp.\n   */\n  timestampTruncate(\n    granularity: Expression,\n    timezone?: string | Expression\n  ): FunctionExpression;\n  timestampTruncate(\n    granularity: TimeGranularity | Expression,\n    timezone?: string | Expression\n  ): FunctionExpression {\n    const internalGranularity = isString(granularity)\n      ? granularity.toLowerCase()\n      : granularity;\n\n    const args = [this, valueToDefaultExpr(internalGranularity)];\n    if (timezone) {\n      args.push(valueToDefaultExpr(timezone));\n    }\n    return new FunctionExpression('timestamp_trunc', args);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the data type of this expression's result, as a string.\n   *\n   * @example\n   * ```typescript\n   * // Get the data type of the value in field 'title'\n   * field('title').type()\n   * ```\n   *\n   * @returns A new `Expression` representing the data type.\n   */\n  type(): FunctionExpression {\n    return new FunctionExpression('type', [this]);\n  }\n\n  // TODO(new-expression): Add new expression method definitions above this line\n\n  /**\n   * @beta\n   * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on this expression.\n   *\n   * @example\n   * ```typescript\n   * // Sort documents by the 'name' field in ascending order\n   * pipeline().collection(\"users\")\n   *   .sort(field(\"name\").ascending());\n   * ```\n   *\n   * @returns A new `Ordering` for ascending sorting.\n   */\n  ascending(): Ordering {\n    return ascending(this);\n  }\n\n  /**\n   * @beta\n   * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on this expression.\n   *\n   * @example\n   * ```typescript\n   * // Sort documents by the 'createdAt' field in descending order\n   * firestore.pipeline().collection(\"users\")\n   *   .sort(field(\"createdAt\").descending());\n   * ```\n   *\n   * @returns A new `Ordering` for descending sorting.\n   */\n  descending(): Ordering {\n    return descending(this);\n  }\n\n  /**\n   * @beta\n   * Assigns an alias to this expression.\n   *\n   * Aliases are useful for renaming fields in the output of a stage or for giving meaningful\n   * names to calculated values.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the total price and assign it the alias \"totalPrice\" and add it to the output.\n   * firestore.pipeline().collection(\"items\")\n   *   .addFields(field(\"price\").multiply(field(\"quantity\")).as(\"totalPrice\"));\n   * ```\n   *\n   * @param name - The alias to assign to this expression.\n   * @returns A new {@link @firebase/firestore/pipelines#AliasedExpression} that wraps this\n   *     expression and associates it with the provided alias.\n   */\n  as(name: string): AliasedExpression {\n    return new AliasedExpression(this, name, 'as');\n  }\n}\n\n/**\n * @beta\n * Specify time granularity for expressions.\n */\nexport type TimeGranularity =\n  | 'microsecond'\n  | 'millisecond'\n  | 'second'\n  | 'minute'\n  | 'hour'\n  | 'day'\n  | 'week'\n  | 'week(monday)'\n  | 'week(tuesday)'\n  | 'week(wednesday)'\n  | 'week(thursday)'\n  | 'week(friday)'\n  | 'week(saturday)'\n  | 'week(sunday)'\n  | 'isoWeek'\n  | 'month'\n  | 'quarter'\n  | 'year'\n  | 'isoYear';\n\n/**\n * @beta\n *\n * An interface that represents a selectable expression.\n */\nexport interface Selectable {\n  selectable: true;\n  /**\n   * @private\n   * @internal\n   */\n  readonly alias: string;\n  /**\n   * @private\n   * @internal\n   */\n  readonly expr: Expression;\n}\n\n/**\n * @beta\n *\n * A class that represents an aggregate function.\n */\nexport class AggregateFunction implements ProtoValueSerializable, UserData {\n  exprType: ExpressionType = 'AggregateFunction';\n\n  /**\n   * @internal\n   */\n  _methodName?: string;\n\n  constructor(private name: string, private params: Expression[]) {}\n\n  /**\n   * @internal\n   * @private\n   */\n  static _create(\n    name: string,\n    params: Expression[],\n    methodName: string\n  ): AggregateFunction {\n    const af = new AggregateFunction(name, params);\n    af._methodName = methodName;\n\n    return af;\n  }\n\n  /**\n   * @beta\n   * Assigns an alias to this AggregateFunction. The alias specifies the name that\n   * the aggregated value will have in the output document.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average price of all items and assign it the alias \"averagePrice\".\n   * firestore.pipeline().collection(\"items\")\n   *   .aggregate(field(\"price\").average().as(\"averagePrice\"));\n   * ```\n   *\n   * @param name - The alias to assign to this AggregateFunction.\n   * @returns A new {@link @firebase/firestore/pipelines#AliasedAggregate} that wraps this\n   *     AggregateFunction and associates it with the provided alias.\n   */\n  as(name: string): AliasedAggregate {\n    return new AliasedAggregate(this, name, 'as');\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      functionValue: {\n        name: this.name,\n        args: this.params.map(p => p._toProto(serializer))\n      }\n    };\n  }\n\n  _protoValueType = 'ProtoValue' as const;\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.params.forEach(expr => {\n      return expr._readUserData(context);\n    });\n  }\n}\n\n/**\n * @beta\n *\n * An AggregateFunction with alias.\n */\nexport class AliasedAggregate implements UserData {\n  constructor(\n    readonly aggregate: AggregateFunction,\n    readonly alias: string,\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.aggregate._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class AliasedExpression implements Selectable, UserData {\n  exprType: ExpressionType = 'AliasedExpression';\n  selectable = true as const;\n\n  constructor(\n    readonly expr: Expression,\n    readonly alias: string,\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.expr._readUserData(context);\n  }\n}\n\n/**\n * @internal\n */\nclass ListOfExprs extends Expression implements UserData {\n  expressionType: ExpressionType = 'ListOfExpressions';\n\n  constructor(\n    private exprs: Expression[],\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      arrayValue: {\n        values: this.exprs.map(p => p._toProto(serializer)!)\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.exprs.forEach((expr: Expression) => expr._readUserData(context));\n  }\n}\n\n/**\n * @beta\n *\n * Represents a reference to a field in a Firestore document, or outputs of a {@link @firebase/firestore/pipelines#Pipeline} stage.\n *\n * <p>Field references are used to access document field values in expressions and to specify fields\n * for sorting, filtering, and projecting data in Firestore pipelines.\n *\n * <p>You can create a `Field` instance using the static {@link @firebase/firestore/pipelines#field} method:\n *\n * @example\n * ```typescript\n * // Create a Field instance for the 'name' field\n * const nameField = field(\"name\");\n *\n * // Create a Field instance for a nested field 'address.city'\n * const cityField = field(\"address.city\");\n * ```\n */\nexport class Field extends Expression implements Selectable {\n  readonly expressionType: ExpressionType = 'Field';\n  selectable = true as const;\n\n  /**\n   * @internal\n   * @private\n   * @hideconstructor\n   * @param fieldPath\n   */\n  constructor(\n    private fieldPath: InternalFieldPath,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  get fieldName(): string {\n    return this.fieldPath.canonicalString();\n  }\n\n  get alias(): string {\n    return this.fieldName;\n  }\n\n  get expr(): Expression {\n    return this;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      fieldReferenceValue: this.fieldPath.canonicalString()\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {}\n}\n\n/**\n * @beta\n * Creates a {@link @firebase/firestore/pipelines#Field} instance representing the field at the given path.\n *\n * The path can be a simple field name (e.g., \"name\") or a dot-separated path to a nested field\n * (e.g., \"address.city\").\n *\n * @example\n * ```typescript\n * // Create a Field instance for the 'title' field\n * const titleField = field(\"title\");\n *\n * // Create a Field instance for a nested field 'author.firstName'\n * const authorFirstNameField = field(\"author.firstName\");\n * ```\n *\n * @param name - The path to the field.\n * @returns A new {@link @firebase/firestore/pipelines#Field} instance representing the specified field.\n */\nexport function field(name: string): Field;\n\n/**\n * @beta\n * Creates a {@link @firebase/firestore/pipelines#Field} instance representing the field at the given path.\n *\n * @param path - A FieldPath specifying the field.\n * @returns A new {@link @firebase/firestore/pipelines#Field} instance representing the specified field.\n */\nexport function field(path: FieldPath): Field;\nexport function field(nameOrPath: string | FieldPath): Field {\n  return _field(nameOrPath, 'field');\n}\n\nexport function _field(\n  nameOrPath: string | FieldPath,\n  methodName: string | undefined\n): Field {\n  if (typeof nameOrPath === 'string') {\n    if (DOCUMENT_KEY_NAME === nameOrPath) {\n      return new Field(documentIdFieldPath()._internalPath, methodName);\n    }\n    return new Field(fieldPathFromArgument('field', nameOrPath), methodName);\n  } else {\n    return new Field(nameOrPath._internalPath, methodName);\n  }\n}\n\n/**\n * @internal\n *\n * Represents a constant value that can be used in a Firestore pipeline expression.\n *\n * You can create a `Constant` instance using the static {@link @firebase/firestore/pipelines#field} method:\n *\n * @example\n * ```typescript\n * // Create a Constant instance for the number 10\n * const ten = constant(10);\n *\n * // Create a Constant instance for the string \"hello\"\n * const hello = constant(\"hello\");\n * ```\n */\nexport class Constant extends Expression {\n  readonly expressionType: ExpressionType = 'Constant';\n\n  private _protoValue?: ProtoValue;\n\n  /**\n   * @private\n   * @internal\n   * @hideconstructor\n   * @param value - The value of the constant.\n   */\n  constructor(\n    private value: unknown,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  static _fromProto(value: ProtoValue): Constant {\n    const result = new Constant(value, undefined);\n    result._protoValue = value;\n    return result;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(_: JsonProtoSerializer): ProtoValue {\n    hardAssert(\n      this._protoValue !== undefined,\n      0x00ed,\n      'Value of this constant has not been serialized to proto value'\n    );\n    return this._protoValue;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    if (isFirestoreValue(this._protoValue)) {\n      return;\n    } else {\n      this._protoValue = parseData(this.value, context)!;\n    }\n  }\n}\n\n/**\n * @beta\n * Creates a `Constant` instance for a number value.\n *\n * @param value - The number value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: number): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a string value.\n *\n * @param value - The string value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: string): Expression;\n\n/**\n * @beta\n * Creates a `BooleanExpression` instance for a boolean value.\n *\n * @param value - The boolean value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: boolean): BooleanExpression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a null value.\n *\n * @param value - The null value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: null): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a GeoPoint value.\n *\n * @param value - The GeoPoint value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: GeoPoint): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Timestamp value.\n *\n * @param value - The Timestamp value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Timestamp): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Date value.\n *\n * @param value - The Date value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Date): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Bytes value.\n *\n * @param value - The Bytes value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Bytes): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a DocumentReference value.\n *\n * @param value - The DocumentReference value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: DocumentReference): Expression;\n\n/**\n * Creates a `Constant` instance for a Firestore proto value.\n * For internal use only.\n * @private\n * @internal\n * @param value - The Firestore proto value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: ProtoValue): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a VectorValue value.\n *\n * @param value - The VectorValue value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: VectorValue): Expression;\n\nexport function constant(value: unknown): Expression | BooleanExpression {\n  return _constant(value, 'constant');\n}\n\n/**\n * @internal\n * @private\n * @param value\n * @param methodName\n */\nexport function _constant(\n  value: unknown,\n  methodName: string | undefined\n): Constant | BooleanExpression {\n  const c = new Constant(value, methodName);\n  if (typeof value === 'boolean') {\n    return new BooleanConstant(c);\n  } else {\n    return c;\n  }\n}\n\n/**\n * Internal only\n * @internal\n * @private\n */\nexport class MapValue extends Expression {\n  constructor(\n    private plainObject: Map<string, Expression>,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  expressionType: ExpressionType = 'Constant';\n\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.plainObject.forEach(expr => {\n      expr._readUserData(context);\n    });\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return toMapValue(serializer, this.plainObject);\n  }\n}\n\n/**\n * @beta\n *\n * This class defines the base class for Firestore {@link @firebase/firestore/pipelines#Pipeline} functions, which can be evaluated within pipeline\n * execution.\n *\n * Typically, you would not use this class or its children directly. Use either the functions like {@link @firebase/firestore/pipelines#and}, {@link @firebase/firestore/pipelines#(equal:1)},\n * or the methods on {@link @firebase/firestore/pipelines#Expression} ({@link @firebase/firestore/pipelines#Expression.(equal:1)}, {@link @firebase/firestore/pipelines#Expression.(lessThan:1)}, etc.) to construct new Function instances.\n */\nexport class FunctionExpression extends Expression {\n  readonly expressionType: ExpressionType = 'Function';\n\n  constructor(name: string, params: Expression[]);\n  constructor(\n    name: string,\n    params: Expression[],\n    _methodName: string | undefined\n  );\n  constructor(\n    private name: string,\n    private params: Expression[],\n    readonly _methodName?: string\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      functionValue: {\n        name: this.name,\n        args: this.params.map(p => p._toProto(serializer))\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.params.forEach(expr => {\n      return expr._readUserData(context);\n    });\n  }\n}\n\n/**\n * @beta\n *\n * An interface that represents a filter condition.\n */\nexport abstract class BooleanExpression extends Expression {\n  abstract get _expr(): Expression;\n\n  get _methodName(): string | undefined {\n    return this._expr._methodName;\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the count of input documents satisfying\n   * this boolean expression.\n   *\n   * @example\n   * ```typescript\n   * // Find the count of documents with a score greater than 90\n   * field(\"score\").greaterThan(90).countIf().as(\"highestScore\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'countIf' aggregation.\n   */\n  countIf(): AggregateFunction {\n    return AggregateFunction._create('count_if', [this], 'countIf');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that negates this boolean expression.\n   *\n   * @example\n   * ```typescript\n   * // Find documents where the 'tags' field does not contain 'completed'\n   * field(\"tags\").arrayContains(\"completed\").not();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the negated filter condition.\n   */\n  not(): BooleanExpression {\n    return new FunctionExpression('not', [this], 'not').asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates a conditional expression that evaluates to the 'then' expression\n   * if `this` expression evaluates to `true`,\n   * or evaluates to the 'else' expression if `this` expressions evaluates `false`.\n   *\n   * @example\n   * ```typescript\n   * // If 'age' is greater than 18, return \"Adult\"; otherwise, return \"Minor\".\n   * field(\"age\").greaterThanOrEqual(18).conditional(constant(\"Adult\"), constant(\"Minor\"));\n   * ```\n   *\n   * @param thenExpr - The expression to evaluate if the condition is true.\n   * @param elseExpr - The expression to evaluate if the condition is false.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the conditional expression.\n   */\n  conditional(thenExpr: Expression, elseExpr: Expression): FunctionExpression {\n    return new FunctionExpression(\n      'conditional',\n      [this, thenExpr, elseExpr],\n      'conditional'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error\n   * // but always returns a boolean expression.\n   * constant(50).divide('length').gt(1).ifError(constant(false));\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: BooleanExpression): BooleanExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error\n   * // but always returns a boolean expression.\n   * constant(50).divide('length').gt(1).ifError(false);\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: boolean): BooleanExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error.\n   * constant(50).divide('length').gt(1).ifError(constant(0));\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error.\n   * constant(50).divide('length').gt(1).ifError(0);\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: unknown): FunctionExpression;\n  ifError(catchValue: unknown): unknown {\n    const normalizedCatchValue = valueToDefaultExpr(catchValue);\n    const expr = new FunctionExpression(\n      'if_error',\n      [this, normalizedCatchValue],\n      'ifError'\n    );\n\n    return normalizedCatchValue instanceof BooleanExpression\n      ? expr.asBoolean()\n      : expr;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return this._expr._toProto(serializer);\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this._expr._readUserData(context);\n  }\n}\n\nexport class BooleanFunctionExpression extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Function';\n  constructor(readonly _expr: FunctionExpression) {\n    super();\n  }\n}\n\nexport class BooleanConstant extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Constant';\n  constructor(readonly _expr: Constant) {\n    super();\n  }\n}\n\nexport class BooleanField extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Field';\n  constructor(readonly _expr: Field) {\n    super();\n  }\n}\n\n/**\n * @beta\n * Creates an aggregation that counts the number of stage inputs where the provided\n * boolean expression evaluates to true.\n *\n * @example\n * ```typescript\n * // Count the number of documents where 'is_active' field equals true\n * countIf(field(\"is_active\").equal(true)).as(\"numActiveDocuments\");\n * ```\n *\n * @param booleanExpr - The boolean expression to evaluate on each input.\n * @returns A new `AggregateFunction` representing the 'countIf' aggregation.\n */\nexport function countIf(booleanExpr: BooleanExpression): AggregateFunction {\n  return booleanExpr.countIf();\n}\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index 1.\n * arrayGet('tags', 1);\n * ```\n *\n * @param arrayField - The name of the array field.\n * @param offset - The index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayField: string,\n  offset: number\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index specified by field\n * // 'favoriteTag'.\n * arrayGet('tags', field('favoriteTag'));\n * ```\n *\n * @param arrayField - The name of the array field.\n * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayField: string,\n  offsetExpr: Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index 1.\n * arrayGet(field('tags'), 1);\n * ```\n *\n * @param arrayExpression - An `Expression` evaluating to an array.\n * @param offset - The index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayExpression: Expression,\n  offset: number\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index specified by field\n * // 'favoriteTag'.\n * arrayGet(field('tags'), field('favoriteTag'));\n * ```\n *\n * @param arrayExpression - An `Expression` evaluating to an array.\n * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayExpression: Expression,\n  offsetExpr: Expression\n): FunctionExpression;\nexport function arrayGet(\n  array: Expression | string,\n  offset: Expression | number\n): FunctionExpression {\n  return fieldOrExpression(array).arrayGet(valueToDefaultExpr(offset));\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a given expression produces an error.\n *\n * @example\n * ```typescript\n * // Check if the result of a calculation is an error\n * isError(field(\"title\").arrayContains(1));\n * ```\n *\n * @param value - The expression to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isError' check.\n */\nexport function isError(value: Expression): BooleanExpression {\n  return value.isError().asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * This overload is useful when a BooleanExpression is required.\n *\n * @example\n * ```typescript\n * // Create an expression that protects against a divide by zero error\n * // but always returns a boolean expression.\n * ifError(constant(50).divide('length').gt(1), constant(false));\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchExpr - The catch expression that will be evaluated and\n * returned if the tryExpr produces an error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: BooleanExpression,\n  catchExpr: BooleanExpression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the first item in the title field arrays, or returns\n * // the entire title field if the array is empty or the field is another type.\n * ifError(field(\"title\").arrayGet(0), field(\"title\"));\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchExpr - The catch expression that will be evaluated and\n * returned if the tryExpr produces an error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: Expression,\n  catchExpr: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the first item in the title field arrays, or returns\n * // \"Default Title\"\n * ifError(field(\"title\").arrayGet(0), \"Default Title\");\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchValue - The value that will be returned if the tryExpr produces an\n * error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: Expression,\n  catchValue: unknown\n): FunctionExpression;\n\nexport function ifError(\n  tryExpr: Expression,\n  catchValue: unknown\n): FunctionExpression | BooleanExpression {\n  if (\n    tryExpr instanceof BooleanExpression &&\n    catchValue instanceof BooleanExpression\n  ) {\n    return tryExpr.ifError(catchValue).asBoolean();\n  } else {\n    return tryExpr.ifError(valueToDefaultExpr(catchValue));\n  }\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns `true` if a value is absent. Otherwise,\n * returns `false` even if the value is `null`.\n *\n * @example\n * ```typescript\n * // Check if the field `value` is absent.\n * isAbsent(field(\"value\"));\n * ```\n *\n * @param value - The expression to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isAbsent' check.\n */\nexport function isAbsent(value: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns `true` if a field is absent. Otherwise,\n * returns `false` even if the field value is `null`.\n *\n * @example\n * ```typescript\n * // Check if the field `value` is absent.\n * isAbsent(\"value\");\n * ```\n *\n * @param field - The field to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isAbsent' check.\n */\nexport function isAbsent(field: string): BooleanExpression;\nexport function isAbsent(value: Expression | string): BooleanExpression {\n  return fieldOrExpression(value).isAbsent();\n}\n\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map at the specified field name.\n *\n * @example\n * ```\n * // Removes the key 'city' field from the map in the address field of the input document.\n * mapRemove('address', 'city');\n * ```\n *\n * @param mapField - The name of a field containing a map value.\n * @param key - The name of the key to remove from the input map.\n */\nexport function mapRemove(mapField: string, key: string): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map produced by evaluating an expression.\n *\n * @example\n * ```\n * // Removes the key 'baz' from the input map.\n * mapRemove(map({foo: 'bar', baz: true}), 'baz');\n * @example\n * ```\n *\n * @param mapExpr - An expression return a map value.\n * @param key - The name of the key to remove from the input map.\n */\nexport function mapRemove(mapExpr: Expression, key: string): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map at the specified field name.\n *\n * @example\n * ```\n * // Removes the key 'city' field from the map in the address field of the input document.\n * mapRemove('address', constant('city'));\n * ```\n *\n * @param mapField - The name of a field containing a map value.\n * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n */\nexport function mapRemove(\n  mapField: string,\n  keyExpr: Expression\n): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map produced by evaluating an expression.\n *\n * @example\n * ```\n * // Removes the key 'baz' from the input map.\n * mapRemove(map({foo: 'bar', baz: true}), constant('baz'));\n * @example\n * ```\n *\n * @param mapExpr - An expression return a map value.\n * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n */\nexport function mapRemove(\n  mapExpr: Expression,\n  keyExpr: Expression\n): FunctionExpression;\n\nexport function mapRemove(\n  mapExpr: Expression | string,\n  stringExpr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(mapExpr).mapRemove(valueToDefaultExpr(stringExpr));\n}\n\n/**\n * @beta\n *\n * Creates an expression that merges multiple map values.\n *\n * @example\n * ```\n * // Merges the map in the settings field with, a map literal, and a map in\n * // that is conditionally returned by another expression\n * mapMerge('settings', { enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n * ```\n *\n * @param mapField - Name of a field containing a map value that will be merged.\n * @param secondMap - A required second map to merge. Represented as a literal or\n * an expression that returns a map.\n * @param otherMaps - Optional additional maps to merge. Each map is represented\n * as a literal or an expression that returns a map.\n */\nexport function mapMerge(\n  mapField: string,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that merges multiple map values.\n *\n * @example\n * ```\n * // Merges the map in the settings field with, a map literal, and a map in\n * // that is conditionally returned by another expression\n * mapMerge(field('settings'), { enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n * ```\n *\n * @param firstMap - An expression or literal map value that will be merged.\n * @param secondMap - A required second map to merge. Represented as a literal or\n * an expression that returns a map.\n * @param otherMaps - Optional additional maps to merge. Each map is represented\n * as a literal or an expression that returns a map.\n */\nexport function mapMerge(\n  firstMap: Record<string, unknown> | Expression,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression;\n\nexport function mapMerge(\n  firstMap: string | Record<string, unknown> | Expression,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression {\n  const secondMapExpr = valueToDefaultExpr(secondMap);\n  const otherMapExprs = otherMaps.map(valueToDefaultExpr);\n  return fieldOrExpression(firstMap).mapMerge(secondMapExpr, ...otherMapExprs);\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the document ID from a path.\n *\n * @example\n * ```typescript\n * // Get the document ID from a path.\n * documentId(myDocumentReference);\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n */\nexport function documentId(\n  documentPath: string | DocumentReference\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the document ID from a path.\n *\n * @example\n * ```typescript\n * // Get the document ID from a path.\n * documentId(field(\"__path__\"));\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n */\nexport function documentId(documentPathExpr: Expression): FunctionExpression;\n\nexport function documentId(\n  documentPath: Expression | string | DocumentReference\n): FunctionExpression {\n  // @ts-ignore\n  const documentPathExpr = valueToDefaultExpr(documentPath);\n  return documentPathExpr.documentId();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param field - The name of a field containing a string or byte array to compute the substring from.\n * @param position - Index of the first character of the substring.\n * @param length - Length of the substring.\n */\nexport function substring(\n  field: string,\n  position: number,\n  length?: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param input - An expression returning a string or byte array to compute the substring from.\n * @param position - Index of the first character of the substring.\n * @param length - Length of the substring.\n */\nexport function substring(\n  input: Expression,\n  position: number,\n  length?: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param field - The name of a field containing a string or byte array to compute the substring from.\n * @param position - An expression that returns the index of the first character of the substring.\n * @param length - An expression that returns the length of the substring.\n */\nexport function substring(\n  field: string,\n  position: Expression,\n  length?: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param input - An expression returning a string or byte array to compute the substring from.\n * @param position - An expression that returns the index of the first character of the substring.\n * @param length - An expression that returns the length of the substring.\n */\nexport function substring(\n  input: Expression,\n  position: Expression,\n  length?: Expression\n): FunctionExpression;\n\nexport function substring(\n  field: Expression | string,\n  position: Expression | number,\n  length?: Expression | number\n): FunctionExpression {\n  const fieldExpr = fieldOrExpression(field);\n  const positionExpr = valueToDefaultExpr(position);\n  const lengthExpr =\n    length === undefined ? undefined : valueToDefaultExpr(length);\n  return fieldExpr.substring(positionExpr, lengthExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that adds two expressions together.\n *\n * @example\n * ```typescript\n * // Add the value of the 'quantity' field and the 'reserve' field.\n * add(field(\"quantity\"), field(\"reserve\"));\n * ```\n *\n * @param first - The first expression to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the addition operation.\n */\nexport function add(\n  first: Expression,\n  second: Expression | unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a field's value to an expression.\n *\n * @example\n * ```typescript\n * // Add the value of the 'quantity' field and the 'reserve' field.\n * add(\"quantity\", field(\"reserve\"));\n * ```\n *\n * @param fieldName - The name of the field containing the value to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the addition operation.\n */\nexport function add(\n  fieldName: string,\n  second: Expression | unknown\n): FunctionExpression;\n\nexport function add(\n  first: Expression | string,\n  second: Expression | unknown\n): FunctionExpression {\n  return fieldOrExpression(first).add(valueToDefaultExpr(second));\n}\n\n/**\n * @beta\n *\n * Creates an expression that subtracts two expressions.\n *\n * @example\n * ```typescript\n * // Subtract the 'discount' field from the 'price' field\n * subtract(field(\"price\"), field(\"discount\"));\n * ```\n *\n * @param left - The expression to subtract from.\n * @param right - The expression to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  left: Expression,\n  right: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a constant value from an expression.\n *\n * @example\n * ```typescript\n * // Subtract the constant value 2 from the 'value' field\n * subtract(field(\"value\"), 2);\n * ```\n *\n * @param expression - The expression to subtract from.\n * @param value - The constant value to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  expression: Expression,\n  value: unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts an expression from a field's value.\n *\n * @example\n * ```typescript\n * // Subtract the 'discount' field from the 'price' field\n * subtract(\"price\", field(\"discount\"));\n * ```\n *\n * @param fieldName - The field name to subtract from.\n * @param expression - The expression to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  fieldName: string,\n  expression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a constant value from a field's value.\n *\n * @example\n * ```typescript\n * // Subtract 20 from the value of the 'total' field\n * subtract(\"total\", 20);\n * ```\n *\n * @param fieldName - The field name to subtract from.\n * @param value - The constant value to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(fieldName: string, value: unknown): FunctionExpression;\nexport function subtract(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.subtract(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that multiplies two expressions together.\n *\n * @example\n * ```typescript\n * // Multiply the 'quantity' field by the 'price' field\n * multiply(field(\"quantity\"), field(\"price\"));\n * ```\n *\n * @param first - The first expression to multiply.\n * @param second - The second expression or literal to multiply.\n * @param others - Optional additional expressions or literals to multiply.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the multiplication operation.\n */\nexport function multiply(\n  first: Expression,\n  second: Expression | unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that multiplies a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Multiply the 'quantity' field by the 'price' field\n * multiply(\"quantity\", field(\"price\"));\n * ```\n *\n * @param fieldName - The name of the field containing the value to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the multiplication operation.\n */\nexport function multiply(\n  fieldName: string,\n  second: Expression | unknown\n): FunctionExpression;\n\nexport function multiply(\n  first: Expression | string,\n  second: Expression | unknown\n): FunctionExpression {\n  return fieldOrExpression(first).multiply(valueToDefaultExpr(second));\n}\n\n/**\n * @beta\n *\n * Creates an expression that divides two expressions.\n *\n * @example\n * ```typescript\n * // Divide the 'total' field by the 'count' field\n * divide(field(\"total\"), field(\"count\"));\n * ```\n *\n * @param left - The expression to be divided.\n * @param right - The expression to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(left: Expression, right: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides an expression by a constant value.\n *\n * @example\n * ```typescript\n * // Divide the 'value' field by 10\n * divide(field(\"value\"), 10);\n * ```\n *\n * @param expression - The expression to be divided.\n * @param value - The constant value to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(\n  expression: Expression,\n  value: unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Divide the 'total' field by the 'count' field\n * divide(\"total\", field(\"count\"));\n * ```\n *\n * @param fieldName - The field name to be divided.\n * @param expressions - The expression to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(\n  fieldName: string,\n  expressions: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides a field's value by a constant value.\n *\n * @example\n * ```typescript\n * // Divide the 'value' field by 10\n * divide(\"value\", 10);\n * ```\n *\n * @param fieldName - The field name to be divided.\n * @param value - The constant value to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(fieldName: string, value: unknown): FunctionExpression;\nexport function divide(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.divide(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing two expressions.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 'field2'.\n * mod(field(\"field1\"), field(\"field2\"));\n * ```\n *\n * @param left - The dividend expression.\n * @param right - The divisor expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(left: Expression, right: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing an expression by a constant.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 5.\n * mod(field(\"field1\"), 5);\n * ```\n *\n * @param expression - The dividend expression.\n * @param value - The divisor constant.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(expression: Expression, value: unknown): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 'field2'.\n * mod(\"field1\", field(\"field2\"));\n * ```\n *\n * @param fieldName - The dividend field name.\n * @param expression - The divisor expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(\n  fieldName: string,\n  expression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing a field's value by a constant.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 5.\n * mod(\"field1\", 5);\n * ```\n *\n * @param fieldName - The dividend field name.\n * @param value - The divisor constant.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(fieldName: string, value: unknown): FunctionExpression;\nexport function mod(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.mod(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that creates a Firestore map value from an input object.\n *\n * @example\n * ```typescript\n * // Create a map from the input object and reference the 'baz' field value from the input document.\n * map({foo: 'bar', baz: Field.of('baz')}).as('data');\n * ```\n *\n * @param elements - The input map to evaluate in the expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the map function.\n */\nexport function map(elements: Record<string, unknown>): FunctionExpression {\n  return _map(elements, 'map');\n}\nexport function _map(\n  elements: Record<string, unknown>,\n  methodName: string | undefined\n): FunctionExpression {\n  const result: Expression[] = [];\n  for (const key in elements) {\n    if (Object.prototype.hasOwnProperty.call(elements, key)) {\n      const value = elements[key];\n      result.push(constant(key));\n      result.push(valueToDefaultExpr(value));\n    }\n  }\n  return new FunctionExpression('map', result, 'map');\n}\n\n/**\n * Internal use only\n * Converts a plainObject to a mapValue in the proto representation,\n * rather than a functionValue+map that is the result of the map(...) function.\n * This behaves different from constant(plainObject) because it\n * traverses the input object, converts values in the object to expressions,\n * and calls _readUserData on each of these expressions.\n * @private\n * @internal\n * @param plainObject\n */\nexport function _mapValue(plainObject: Record<string, unknown>): MapValue {\n  const result: Map<string, Expression> = new Map<string, Expression>();\n  for (const key in plainObject) {\n    if (Object.prototype.hasOwnProperty.call(plainObject, key)) {\n      const value = plainObject[key];\n      result.set(key, valueToDefaultExpr(value));\n    }\n  }\n  return new MapValue(result, undefined);\n}\n\n/**\n * @beta\n *\n * Creates an expression that creates a Firestore array value from an input array.\n *\n * @example\n * ```typescript\n * // Create an array value from the input array and reference the 'baz' field value from the input document.\n * array(['bar', Field.of('baz')]).as('foo');\n * ```\n *\n * @param elements - The input array to evaluate in the expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the array function.\n */\nexport function array(elements: unknown[]): FunctionExpression {\n  return _array(elements, 'array');\n}\nexport function _array(\n  elements: unknown[],\n  methodName: string | undefined\n): FunctionExpression {\n  return new FunctionExpression(\n    'array',\n    elements.map(element => valueToDefaultExpr(element)),\n    methodName\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if two expressions are equal.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to an expression\n * equal(field(\"age\"), field(\"minAge\").add(10));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(left: Expression, right: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to 21\n * equal(field(\"age\"), 21);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to the 'limit' field\n * equal(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'city' field is equal to string constant \"London\"\n * equal(\"city\", \"London\");\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(fieldName: string, value: unknown): BooleanExpression;\nexport function equal(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.equal(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if two expressions are not equal.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to field 'finalState'\n * notEqual(field(\"status\"), field(\"finalState\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to \"completed\"\n * notEqual(field(\"status\"), \"completed\");\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to the value of 'expectedStatus'\n * notEqual(\"status\", field(\"expectedStatus\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'country' field is not equal to \"USA\"\n * notEqual(\"country\", \"USA\");\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(fieldName: string, value: unknown): BooleanExpression;\nexport function notEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.notEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is less than the second expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than 30\n * lessThan(field(\"age\"), field(\"limit\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is less than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than 30\n * lessThan(field(\"age\"), 30);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than the 'limit' field\n * lessThan(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is less than 50\n * lessThan(\"price\", 50);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(fieldName: string, value: unknown): BooleanExpression;\nexport function lessThan(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.lessThan(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is less than or equal to the second\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to 20\n * lessThan(field(\"quantity\"), field(\"limit\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is less than or equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to 20\n * lessThan(field(\"quantity\"), 20);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n * Creates an expression that checks if a field's value is less than or equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to the 'limit' field\n * lessThan(\"quantity\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than or equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'score' field is less than or equal to 70\n * lessThan(\"score\", 70);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function lessThanOrEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.lessThanOrEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is greater than the second\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18\n * greaterThan(field(\"age\"), Constant(9).add(9));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is greater than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18\n * greaterThan(field(\"age\"), 18);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than an expression.\n *\n * @example\n * ```typescript\n * // Check if the value of field 'age' is greater than the value of field 'limit'\n * greaterThan(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is greater than 100\n * greaterThan(\"price\", 100);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function greaterThan(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.greaterThan(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is greater than or equal to the\n * second expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is greater than or equal to the field \"threshold\"\n * greaterThanOrEqual(field(\"quantity\"), field(\"threshold\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is greater than or equal to a constant\n * value.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is greater than or equal to 10\n * greaterThanOrEqual(field(\"quantity\"), 10);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than or equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the value of field 'age' is greater than or equal to the value of field 'limit'\n * greaterThanOrEqual(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The expression to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  fieldName: string,\n  value: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than or equal to a constant\n * value.\n *\n * @example\n * ```typescript\n * // Check if the 'score' field is greater than or equal to 80\n * greaterThanOrEqual(\"score\", 80);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function greaterThanOrEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.greaterThanOrEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that concatenates an array expression with other arrays.\n *\n * @example\n * ```typescript\n * // Combine the 'items' array with two new item arrays\n * arrayConcat(field(\"items\"), [field(\"newItems\"), field(\"otherItems\")]);\n * ```\n *\n * @param firstArray - The first array expression to concatenate to.\n * @param secondArray - The second array expression or array literal to concatenate to.\n * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated array.\n */\nexport function arrayConcat(\n  firstArray: Expression,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that concatenates a field's array value with other arrays.\n *\n * @example\n * ```typescript\n * // Combine the 'items' array with two new item arrays\n * arrayConcat(\"items\", [field(\"newItems\"), field(\"otherItems\")]);\n * ```\n *\n * @param firstArrayField - The first array to concatenate to.\n * @param secondArray - The second array expression or array literal to concatenate to.\n * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated array.\n */\nexport function arrayConcat(\n  firstArrayField: string,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression;\n\nexport function arrayConcat(\n  firstArray: Expression | string,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression {\n  const exprValues = otherArrays.map(element => valueToDefaultExpr(element));\n  return fieldOrExpression(firstArray).arrayConcat(\n    fieldOrExpression(secondArray),\n    ...exprValues\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains the value of field 'selectedColor'\n * arrayContains(field(\"colors\"), field(\"selectedColor\"));\n * ```\n *\n * @param array - The array expression to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  array: Expression,\n  element: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains \"red\"\n * arrayContains(field(\"colors\"), \"red\");\n * ```\n *\n * @param array - The array expression to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  array: Expression,\n  element: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains the value of field 'selectedColor'\n * arrayContains(\"colors\", field(\"selectedColor\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  fieldName: string,\n  element: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains a specific value.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains \"red\"\n * arrayContains(\"colors\", \"red\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  fieldName: string,\n  element: unknown\n): BooleanExpression;\nexport function arrayContains(\n  array: Expression | string,\n  element: unknown\n): BooleanExpression {\n  const arrayExpr = fieldOrExpression(array);\n  const elementExpr = valueToDefaultExpr(element);\n  return arrayExpr.arrayContains(elementExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'categories' array contains either values from field \"cate1\" or \"Science\"\n * arrayContainsAny(field(\"categories\"), [field(\"cate1\"), \"Science\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  array: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'groups' array contains either the value from the 'userGroup' field\n * // or the value \"guest\"\n * arrayContainsAny(\"categories\", [field(\"cate1\"), \"Science\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'categories' array contains either values from field \"cate1\" or \"Science\"\n * arrayContainsAny(field(\"categories\"), array([field(\"cate1\"), \"Science\"]));\n * ```\n *\n * @param array - The array expression to check.\n * @param values - An expression that evaluates to an array, whose elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  array: Expression,\n  values: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'groups' array contains either the value from the 'userGroup' field\n * // or the value \"guest\"\n * arrayContainsAny(\"categories\", array([field(\"cate1\"), \"Science\"]));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - An expression that evaluates to an array, whose elements to check for in the array field.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  fieldName: string,\n  values: Expression\n): BooleanExpression;\nexport function arrayContainsAny(\n  array: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(array).arrayContainsAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains all the specified elements.\n *\n * @example\n * ```typescript\n * // Check if the \"tags\" array contains all of the values: \"SciFi\", \"Adventure\", and the value from field \"tag1\"\n * arrayContainsAll(field(\"tags\"), [field(\"tag1\"), constant(\"SciFi\"), \"Adventure\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  array: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains all the specified values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'tags' array contains both of the values from field 'tag1', the value \"SciFi\", and \"Adventure\"\n * arrayContainsAll(\"tags\", [field(\"tag1\"), \"SciFi\", \"Adventure\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains all the specified elements.\n *\n * @example\n * ```typescript\n * // Check if the \"tags\" array contains all of the values: \"SciFi\", \"Adventure\", and the value from field \"tag1\"\n * arrayContainsAll(field(\"tags\"), [field(\"tag1\"), constant(\"SciFi\"), \"Adventure\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param arrayExpression - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  array: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains all the specified values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'tags' array contains both of the values from field 'tag1', the value \"SciFi\", and \"Adventure\"\n * arrayContainsAll(\"tags\", [field(\"tag1\"), \"SciFi\", \"Adventure\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param arrayExpression - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\nexport function arrayContainsAll(\n  array: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(array).arrayContainsAll(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of an array in a specified field.\n *\n * @example\n * ```typescript\n * // Get the number of items in field 'cart'\n * arrayLength('cart');\n * ```\n *\n * @param fieldName - The name of the field containing an array to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function arrayLength(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of an array expression.\n *\n * @example\n * ```typescript\n * // Get the number of items in the 'cart' array\n * arrayLength(field(\"cart\"));\n * ```\n *\n * @param array - The array expression to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function arrayLength(array: Expression): FunctionExpression;\nexport function arrayLength(array: Expression | string): FunctionExpression {\n  return fieldOrExpression(array).arrayLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression, when evaluated, is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(field(\"category\"), [constant(\"Electronics\"), field(\"primaryType\")]);\n * ```\n *\n * @param expression - The expression whose results to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  expression: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is equal to any of the provided values.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is set to a value in the disabledCategories field\n * equalAny(field(\"category\"), field('disabledCategories'));\n * ```\n *\n * @param expression - The expression whose results to compare.\n * @param arrayExpression - An expression that evaluates to an array, whose elements to check for equality to the input.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  expression: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(\"category\", [constant(\"Electronics\"), field(\"primaryType\")]);\n * ```\n *\n * @param fieldName - The field to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(\"category\", [\"Electronics\", field(\"primaryType\")]);\n * ```\n *\n * @param fieldName - The field to compare.\n * @param arrayExpression - An expression that evaluates to an array, whose elements to check for equality to the input field.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\nexport function equalAny(\n  element: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(element).equalAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n * notEqualAny(field(\"status\"), [\"pending\", field(\"rejectedStatus\")]);\n * ```\n *\n * @param element - The expression to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  element: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n * notEqualAny(\"status\", [constant(\"pending\"), field(\"rejectedStatus\")]);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of the field 'rejectedStatus'\n * notEqualAny(field(\"status\"), [\"pending\", field(\"rejectedStatus\")]);\n * ```\n *\n * @param element - The expression to compare.\n * @param arrayExpression - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  element: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to any of the values in the evaluated expression.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to any value in the field 'rejectedStatuses'\n * notEqualAny(\"status\", field(\"rejectedStatuses\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param arrayExpression - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\n\nexport function notEqualAny(\n  element: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(element).notEqualAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'XOR' (exclusive OR) operation on multiple BooleanExpressions.\n *\n * @example\n * ```typescript\n * // Check if only one of the conditions is true: 'age' greater than 18, 'city' is \"London\",\n * // or 'status' is \"active\".\n * const condition = xor(\n *     greaterThan(\"age\", 18),\n *     equal(\"city\", \"London\"),\n *     equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first condition.\n * @param second - The second condition.\n * @param additionalConditions - Additional conditions to 'XOR' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'XOR' operation.\n */\nexport function xor(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...additionalConditions: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'xor',\n    [first, second, ...additionalConditions],\n    'xor'\n  ).asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates a conditional expression that evaluates to a 'then' expression if a condition is true\n * and an 'else' expression if the condition is false.\n *\n * @example\n * ```typescript\n * // If 'age' is greater than 18, return \"Adult\"; otherwise, return \"Minor\".\n * conditional(\n *     greaterThan(\"age\", 18), constant(\"Adult\"), constant(\"Minor\"));\n * ```\n *\n * @param condition - The condition to evaluate.\n * @param thenExpr - The expression to evaluate if the condition is true.\n * @param elseExpr - The expression to evaluate if the condition is false.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the conditional expression.\n */\nexport function conditional(\n  condition: BooleanExpression,\n  thenExpr: Expression,\n  elseExpr: Expression\n): FunctionExpression {\n  return new FunctionExpression(\n    'conditional',\n    [condition, thenExpr, elseExpr],\n    'conditional'\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that negates a filter condition.\n *\n * @example\n * ```typescript\n * // Find documents where the 'completed' field is NOT true\n * not(equal(\"completed\", true));\n * ```\n *\n * @param booleanExpr - The filter condition to negate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the negated filter condition.\n */\nexport function not(booleanExpr: BooleanExpression): BooleanExpression {\n  return booleanExpr.not();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the largest value between multiple input\n * expressions or literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the largest value between the 'field1' field, the 'field2' field,\n * // and 1000\n * logicalMaximum(field(\"field1\"), field(\"field2\"), 1000);\n * ```\n *\n * @param first - The first operand expression.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n */\nexport function logicalMaximum(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the largest value between multiple input\n * expressions or literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the largest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMaximum(\"field1\", field(\"field2\"), 1000);\n * ```\n *\n * @param fieldName - The first operand field name.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n */\nexport function logicalMaximum(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function logicalMaximum(\n  first: Expression | string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return fieldOrExpression(first).logicalMaximum(\n    valueToDefaultExpr(second),\n    ...others.map(value => valueToDefaultExpr(value))\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the smallest value between multiple input\n * expressions and literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the smallest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMinimum(field(\"field1\"), field(\"field2\"), 1000);\n * ```\n *\n * @param first - The first operand expression.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n */\nexport function logicalMinimum(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the smallest value between a field's value\n * and other input expressions or literal values.\n * Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the smallest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMinimum(\"field1\", field(\"field2\"), 1000);\n * ```\n *\n * @param fieldName - The first operand field name.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n */\nexport function logicalMinimum(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function logicalMinimum(\n  first: Expression | string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return fieldOrExpression(first).logicalMinimum(\n    valueToDefaultExpr(second),\n    ...others.map(value => valueToDefaultExpr(value))\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field exists.\n *\n * @example\n * ```typescript\n * // Check if the document has a field named \"phoneNumber\"\n * exists(field(\"phoneNumber\"));\n * ```\n *\n * @param value - An expression evaluates to the name of the field to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'exists' check.\n */\nexport function exists(value: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field exists.\n *\n * @example\n * ```typescript\n * // Check if the document has a field named \"phoneNumber\"\n * exists(\"phoneNumber\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'exists' check.\n */\nexport function exists(fieldName: string): BooleanExpression;\nexport function exists(valueOrField: Expression | string): BooleanExpression {\n  return fieldOrExpression(valueOrField).exists();\n}\n\n/**\n * @beta\n *\n * Creates an expression that reverses a string.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * reverse(field(\"myString\"));\n * ```\n *\n * @param stringExpression - An expression evaluating to a string value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function reverse(stringExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that reverses a string value in the specified field.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * reverse(\"myString\");\n * ```\n *\n * @param field - The name of the field representing the string to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function reverse(field: string): FunctionExpression;\nexport function reverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).reverse();\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the byte length of a string in UTF-8, or just the length of a Blob.\n *\n * @example\n * ```typescript\n * // Calculate the length of the 'myString' field in bytes.\n * byteLength(field(\"myString\"));\n * ```\n *\n * @param expr - The expression representing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n */\nexport function byteLength(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a string represented by a field in UTF-8 bytes, or just the length of a Blob.\n *\n * @example\n * ```typescript\n * // Calculate the length of the 'myString' field in bytes.\n * byteLength(\"myString\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n */\nexport function byteLength(fieldName: string): FunctionExpression;\nexport function byteLength(expr: Expression | string): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.byteLength();\n}\n\n/**\n * @beta\n * Creates an expression that reverses an array.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myArray' field.\n * arrayReverse(\"myArray\");\n * ```\n *\n * @param fieldName - The name of the field to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n */\nexport function arrayReverse(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that reverses an array.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myArray' field.\n * arrayReverse(field(\"myArray\"));\n * ```\n *\n * @param arrayExpression - An expression evaluating to an array value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n */\nexport function arrayReverse(arrayExpression: Expression): FunctionExpression;\nexport function arrayReverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).arrayReverse();\n}\n\n/**\n * @beta\n * Creates an expression that computes e to the power of the expression's result.\n *\n * @example\n * ```typescript\n * // Compute e to the power of 2.\n * exp(constant(2));\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n */\nexport function exp(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes e to the power of the expression's result.\n *\n * @example\n * ```typescript\n * // Compute e to the power of the 'value' field.\n * exp('value');\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n */\nexport function exp(fieldName: string): FunctionExpression;\n\nexport function exp(\n  expressionOrFieldName: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expressionOrFieldName).exp();\n}\n\n/**\n * @beta\n * Creates an expression that computes the ceiling of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the ceiling of the 'price' field.\n * ceil(\"price\");\n * ```\n *\n * @param fieldName - The name of the field to compute the ceiling of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n */\nexport function ceil(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the ceiling of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the ceiling of the 'price' field.\n * ceil(field(\"price\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the ceiling will be computed for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n */\nexport function ceil(expression: Expression): FunctionExpression;\nexport function ceil(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).ceil();\n}\n\n/**\n * @beta\n * Creates an expression that computes the floor of a numeric value.\n *\n * @param expr - The expression to compute the floor of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n */\nexport function floor(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the floor of a numeric value.\n *\n * @param fieldName - The name of the field to compute the floor of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n */\nexport function floor(fieldName: string): FunctionExpression;\nexport function floor(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).floor();\n}\n\n/**\n * @beta\n * Creates an aggregation that counts the number of distinct values of a field.\n *\n * @param expr - The expression or field to count distinct values of.\n * @returns A new `AggregateFunction` representing the 'count_distinct' aggregation.\n */\nexport function countDistinct(expr: Expression | string): AggregateFunction {\n  return fieldOrExpression(expr).countDistinct();\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the character length of a string field in UTF8.\n *\n * @example\n * ```typescript\n * // Get the character length of the 'name' field in UTF-8.\n * strLength(\"name\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string.\n */\nexport function charLength(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the character length of a string expression in UTF-8.\n *\n * @example\n * ```typescript\n * // Get the character length of the 'name' field in UTF-8.\n * strLength(field(\"name\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string.\n */\nexport function charLength(stringExpression: Expression): FunctionExpression;\nexport function charLength(value: Expression | string): FunctionExpression {\n  const valueExpr = fieldOrExpression(value);\n  return valueExpr.charLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison against a\n * field.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(\"title\", \"%guide%\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(fieldName: string, pattern: string): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison against a\n * field.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(\"title\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(fieldName: string, pattern: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(field(\"title\"), \"%guide%\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(field(\"title\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function like(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.like(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified regular expression as\n * a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(\"description\", \"(?i)example\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  fieldName: string,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified regular expression as\n * a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(\"description\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  fieldName: string,\n  pattern: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified regular\n * expression as a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(field(\"description\"), \"(?i)example\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified regular\n * expression as a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(field(\"description\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function regexContains(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexContains(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field matches a specified regular expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(\"email\", \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  fieldName: string,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field matches a specified regular expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(\"email\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  fieldName: string,\n  pattern: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression matches a specified regular\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(field(\"email\"), \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n * ```\n *\n * @param stringExpression - The expression representing the string to match against.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression matches a specified regular\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(field(\"email\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to match against.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function regexMatch(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexMatch(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\".\n * stringContains(\"description\", \"example\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param substring - The substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  fieldName: string,\n  substring: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a substring specified by an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains the value of the 'keyword' field.\n * stringContains(\"description\", field(\"keyword\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param substring - The expression representing the substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  fieldName: string,\n  substring: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\".\n * stringContains(field(\"description\"), \"example\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param substring - The substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  stringExpression: Expression,\n  substring: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a substring specified by another expression.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains the value of the 'keyword' field.\n * stringContains(field(\"description\"), field(\"keyword\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param substring - The expression representing the substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  stringExpression: Expression,\n  substring: Expression\n): BooleanExpression;\nexport function stringContains(\n  left: Expression | string,\n  substring: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const substringExpr = valueToDefaultExpr(substring);\n  return leftExpr.stringContains(substringExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the 'name' field starts with \"Mr.\"\n * startsWith(\"name\", \"Mr.\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  fieldName: string,\n  prefix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the 'fullName' field starts with the value of the 'firstName' field\n * startsWith(\"fullName\", field(\"firstName\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param prefix - The expression representing the prefix.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  fieldName: string,\n  prefix: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields starts with \"Mr.\"\n * startsWith(field(\"fullName\"), \"Mr.\");\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  stringExpression: Expression,\n  prefix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields starts with \"Mr.\"\n * startsWith(field(\"fullName\"), field(\"prefix\"));\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  stringExpression: Expression,\n  prefix: Expression\n): BooleanExpression;\nexport function startsWith(\n  expr: Expression | string,\n  prefix: Expression | string\n): BooleanExpression {\n  return fieldOrExpression(expr).startsWith(valueToDefaultExpr(prefix));\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the 'filename' field ends with \".txt\"\n * endsWith(\"filename\", \".txt\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(fieldName: string, suffix: string): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the 'url' field ends with the value of the 'extension' field\n * endsWith(\"url\", field(\"extension\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param suffix - The expression representing the postfix.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  fieldName: string,\n  suffix: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields ends with \"Jr.\"\n * endsWith(field(\"fullName\"), \"Jr.\");\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  stringExpression: Expression,\n  suffix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields ends with \"Jr.\"\n * endsWith(field(\"fullName\"), constant(\"Jr.\"));\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  stringExpression: Expression,\n  suffix: Expression\n): BooleanExpression;\nexport function endsWith(\n  expr: Expression | string,\n  suffix: Expression | string\n): BooleanExpression {\n  return fieldOrExpression(expr).endsWith(valueToDefaultExpr(suffix));\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a string field to lowercase.\n *\n * @example\n * ```typescript\n * // Convert the 'name' field to lowercase\n * toLower(\"name\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the lowercase string.\n */\nexport function toLower(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a string expression to lowercase.\n *\n * @example\n * ```typescript\n * // Convert the 'name' field to lowercase\n * toLower(field(\"name\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to convert to lowercase.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the lowercase string.\n */\nexport function toLower(stringExpression: Expression): FunctionExpression;\nexport function toLower(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).toLower();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a string field to uppercase.\n *\n * @example\n * ```typescript\n * // Convert the 'title' field to uppercase\n * toUpper(\"title\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the uppercase string.\n */\nexport function toUpper(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a string expression to uppercase.\n *\n * @example\n * ```typescript\n * // Convert the 'title' field to uppercase\n * toUppercase(field(\"title\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to convert to uppercase.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the uppercase string.\n */\nexport function toUpper(stringExpression: Expression): FunctionExpression;\nexport function toUpper(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).toUpper();\n}\n\n/**\n * @beta\n *\n * Creates an expression that removes leading and trailing whitespace from a string or byte array.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the 'userInput' field\n * trim(\"userInput\");\n *\n * // Trim quotes from the 'userInput' field\n * trim(\"userInput\", '\"');\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n * trimmed from the input. If not specified, then whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string.\n */\nexport function trim(\n  fieldName: string,\n  valueToTrim?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that removes leading and trailing characters from a string or byte array expression.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the 'userInput' field\n * trim(field(\"userInput\"));\n *\n * // Trim quotes from the 'userInput' field\n * trim(field(\"userInput\"), '\"');\n * ```\n *\n * @param stringExpression - The expression representing the string or byte array to trim.\n * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n * trimmed from the input. If not specified, then whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string or byte array.\n */\nexport function trim(\n  stringExpression: Expression,\n  valueToTrim?: string | Expression\n): FunctionExpression;\nexport function trim(\n  expr: Expression | string,\n  valueToTrim?: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(expr).trim(valueToTrim);\n}\n\n/**\n * @beta\n *\n * Creates an expression that concatenates string functions, fields or constants together.\n *\n * @example\n * ```typescript\n * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n * stringConcat(\"firstName\", \" \", field(\"lastName\"));\n * ```\n *\n * @param fieldName - The field name containing the initial string value.\n * @param secondString - An expression or string literal to concatenate.\n * @param otherStrings - Optional additional expressions or literals (typically strings) to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated string.\n */\nexport function stringConcat(\n  fieldName: string,\n  secondString: Expression | string,\n  ...otherStrings: Array<Expression | string>\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that concatenates string expressions together.\n *\n * @example\n * ```typescript\n * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n * stringConcat(field(\"firstName\"), \" \", field(\"lastName\"));\n * ```\n *\n * @param firstString - The initial string expression to concatenate to.\n * @param secondString - An expression or string literal to concatenate.\n * @param otherStrings - Optional additional expressions or literals (typically strings) to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated string.\n */\nexport function stringConcat(\n  firstString: Expression,\n  secondString: Expression | string,\n  ...otherStrings: Array<Expression | string>\n): FunctionExpression;\nexport function stringConcat(\n  first: string | Expression,\n  second: string | Expression,\n  ...elements: Array<string | Expression>\n): FunctionExpression {\n  return fieldOrExpression(first).stringConcat(\n    valueToDefaultExpr(second),\n    ...elements.map(valueToDefaultExpr)\n  );\n}\n\n/**\n * @beta\n *\n * Accesses a value from a map (object) field using the provided key.\n *\n * @example\n * ```typescript\n * // Get the 'city' value from the 'address' map field\n * mapGet(\"address\", \"city\");\n * ```\n *\n * @param fieldName - The field name of the map field.\n * @param subField - The key to access in the map.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the value associated with the given key in the map.\n */\nexport function mapGet(fieldName: string, subField: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Accesses a value from a map (object) expression using the provided key.\n *\n * @example\n * ```typescript\n * // Get the 'city' value from the 'address' map field\n * mapGet(field(\"address\"), \"city\");\n * ```\n *\n * @param mapExpression - The expression representing the map.\n * @param subField - The key to access in the map.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the value associated with the given key in the map.\n */\nexport function mapGet(\n  mapExpression: Expression,\n  subField: string\n): FunctionExpression;\nexport function mapGet(\n  fieldOrExpr: string | Expression,\n  subField: string\n): FunctionExpression {\n  return fieldOrExpression(fieldOrExpr).mapGet(subField);\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that counts the total number of stage inputs.\n *\n * @example\n * ```typescript\n * // Count the total number of input documents\n * countAll().as(\"totalDocument\");\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'countAll' aggregation.\n */\nexport function countAll(): AggregateFunction {\n  return AggregateFunction._create('count', [], 'count');\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that counts the number of stage inputs with valid evaluations of the\n * provided expression.\n *\n * @example\n * ```typescript\n * // Count the number of items where the price is greater than 10\n * count(field(\"price\").greaterThan(10)).as(\"expensiveItemCount\");\n * ```\n *\n * @param expression - The expression to count.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'count' aggregation.\n */\nexport function count(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n * Creates an aggregation that counts the number of stage inputs where the input field exists.\n *\n * @example\n * ```typescript\n * // Count the total number of products\n * count(\"productId\").as(\"totalProducts\");\n * ```\n *\n * @param fieldName - The name of the field to count.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'count' aggregation.\n */\nexport function count(fieldName: string): AggregateFunction;\nexport function count(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).count();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the sum of values from an expression across multiple\n * stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the total revenue from a set of orders\n * sum(field(\"orderAmount\")).as(\"totalRevenue\");\n * ```\n *\n * @param expression - The expression to sum up.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'sum' aggregation.\n */\nexport function sum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the sum of a field's values across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Calculate the total revenue from a set of orders\n * sum(\"orderAmount\").as(\"totalRevenue\");\n * ```\n *\n * @param fieldName - The name of the field containing numeric values to sum up.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'sum' aggregation.\n */\nexport function sum(fieldName: string): AggregateFunction;\nexport function sum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).sum();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the average (mean) of values from an expression across\n * multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the average age of users\n * average(field(\"age\")).as(\"averageAge\");\n * ```\n *\n * @param expression - The expression representing the values to average.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'average' aggregation.\n */\nexport function average(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the average (mean) of a field's values across multiple\n * stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the average age of users\n * average(\"age\").as(\"averageAge\");\n * ```\n *\n * @param fieldName - The name of the field containing numeric values to average.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'average' aggregation.\n */\nexport function average(fieldName: string): AggregateFunction;\nexport function average(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).average();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the minimum value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the lowest price of all products\n * minimum(field(\"price\")).as(\"lowestPrice\");\n * ```\n *\n * @param expression - The expression to find the minimum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'minimum' aggregation.\n */\nexport function minimum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the minimum value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the lowest price of all products\n * minimum(\"price\").as(\"lowestPrice\");\n * ```\n *\n * @param fieldName - The name of the field to find the minimum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'minimum' aggregation.\n */\nexport function minimum(fieldName: string): AggregateFunction;\nexport function minimum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).minimum();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the maximum value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the highest score in a leaderboard\n * maximum(field(\"score\")).as(\"highestScore\");\n * ```\n *\n * @param expression - The expression to find the maximum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'maximum' aggregation.\n */\nexport function maximum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the maximum value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the highest score in a leaderboard\n * maximum(\"score\").as(\"highestScore\");\n * ```\n *\n * @param fieldName - The name of the field to find the maximum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'maximum' aggregation.\n */\nexport function maximum(fieldName: string): AggregateFunction;\nexport function maximum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).maximum();\n}\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a field's vector value and a literal vector value.\n *\n * @example\n * ```typescript\n * // Calculate the Cosine distance between the 'location' field and a target location\n * cosineDistance(\"location\", [37.7749, -122.4194]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles) or {@link VectorValue} to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n * cosineDistance(\"userVector\", field(\"itemVector\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a vector expression and a vector literal.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'location' field and a target location\n * cosineDistance(field(\"location\"), [37.7749, -122.4194]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n * cosineDistance(field(\"userVector\"), field(\"itemVector\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function cosineDistance(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.cosineDistance(expr2);\n}\n\n/**\n * @beta\n *\n * Calculates the dot product between a field's vector value and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the dot product distance between a feature vector and a target vector\n * dotProduct(\"features\", [0.5, 0.8, 0.2]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles or VectorValue) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the dot product distance between two document vectors: 'docVector1' and 'docVector2'\n * dotProduct(\"docVector1\", field(\"docVector2\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between a vector expression and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the dot product between a feature vector and a target vector\n * dotProduct(field(\"features\"), [0.5, 0.8, 0.2]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to calculate with.\n * @param vector - The other vector (as an array of doubles or VectorValue) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the dot product between two document vectors: 'docVector1' and 'docVector2'\n * dotProduct(field(\"docVector1\"), field(\"docVector2\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to calculate with.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function dotProduct(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.dotProduct(expr2);\n}\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a field's vector value and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between the 'location' field and a target location\n * euclideanDistance(\"location\", [37.7749, -122.4194]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between two vector fields: 'pointA' and 'pointB'\n * euclideanDistance(\"pointA\", field(\"pointB\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a vector expression and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between the 'location' field and a target location\n *\n * euclideanDistance(field(\"location\"), [37.7749, -122.4194]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between two vector fields: 'pointA' and 'pointB'\n * euclideanDistance(field(\"pointA\"), field(\"pointB\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function euclideanDistance(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.euclideanDistance(expr2);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a Firestore Vector.\n *\n * @example\n * ```typescript\n * // Get the vector length (dimension) of the field 'embedding'.\n * vectorLength(field(\"embedding\"));\n * ```\n *\n * @param vectorExpression - The expression representing the Firestore Vector.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function vectorLength(vectorExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a Firestore Vector represented by a field.\n *\n * @example\n * ```typescript\n * // Get the vector length (dimension) of the field 'embedding'.\n * vectorLength(\"embedding\");\n * ```\n *\n * @param fieldName - The name of the field representing the Firestore Vector.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function vectorLength(fieldName: string): FunctionExpression;\nexport function vectorLength(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).vectorLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'microseconds' field as microseconds since epoch.\n * unixMicrosToTimestamp(field(\"microseconds\"));\n * ```\n *\n * @param expr - The expression representing the number of microseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMicrosToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'microseconds' field as microseconds since epoch.\n * unixMicrosToTimestamp(\"microseconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of microseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMicrosToTimestamp(fieldName: string): FunctionExpression;\nexport function unixMicrosToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expr).unixMicrosToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to microseconds since epoch.\n * timestampToUnixMicros(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n */\nexport function timestampToUnixMicros(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to microseconds since epoch.\n * timestampToUnixMicros(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n */\nexport function timestampToUnixMicros(fieldName: string): FunctionExpression;\nexport function timestampToUnixMicros(\n  expr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expr).timestampToUnixMicros();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'milliseconds' field as milliseconds since epoch.\n * unixMillisToTimestamp(field(\"milliseconds\"));\n * ```\n *\n * @param expr - The expression representing the number of milliseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMillisToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'milliseconds' field as milliseconds since epoch.\n * unixMillisToTimestamp(\"milliseconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of milliseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMillisToTimestamp(fieldName: string): FunctionExpression;\nexport function unixMillisToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.unixMillisToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to milliseconds since epoch.\n * timestampToUnixMillis(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n */\nexport function timestampToUnixMillis(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to milliseconds since epoch.\n * timestampToUnixMillis(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n */\nexport function timestampToUnixMillis(fieldName: string): FunctionExpression;\nexport function timestampToUnixMillis(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.timestampToUnixMillis();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'seconds' field as seconds since epoch.\n * unixSecondsToTimestamp(field(\"seconds\"));\n * ```\n *\n * @param expr - The expression representing the number of seconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixSecondsToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'seconds' field as seconds since epoch.\n * unixSecondsToTimestamp(\"seconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of seconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixSecondsToTimestamp(fieldName: string): FunctionExpression;\nexport function unixSecondsToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.unixSecondsToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to seconds since epoch.\n * timestampToUnixSeconds(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n */\nexport function timestampToUnixSeconds(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to seconds since epoch.\n * timestampToUnixSeconds(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n */\nexport function timestampToUnixSeconds(fieldName: string): FunctionExpression;\nexport function timestampToUnixSeconds(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.timestampToUnixSeconds();\n}\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp.\n *\n * @example\n * ```typescript\n * // Add some duration determined by field 'unit' and 'amount' to the 'timestamp' field.\n * timestampAdd(field(\"timestamp\"), field(\"unit\"), field(\"amount\"));\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n * @param amount - The expression evaluates to amount of the unit.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  timestamp: Expression,\n  unit: Expression,\n  amount: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp.\n *\n * @example\n * ```typescript\n * // Add 1 day to the 'timestamp' field.\n * timestampAdd(field(\"timestamp\"), \"day\", 1);\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  timestamp: Expression,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp represented by a field.\n *\n * @example\n * ```typescript\n * // Add 1 day to the 'timestamp' field.\n * timestampAdd(\"timestamp\", \"day\", 1);\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  fieldName: string,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\nexport function timestampAdd(\n  timestamp: Expression | string,\n  unit:\n    | Expression\n    | 'microsecond'\n    | 'millisecond'\n    | 'second'\n    | 'minute'\n    | 'hour'\n    | 'day',\n  amount: Expression | number\n): FunctionExpression {\n  const normalizedTimestamp = fieldOrExpression(timestamp);\n  const normalizedUnit = valueToDefaultExpr(unit);\n  const normalizedAmount = valueToDefaultExpr(amount);\n  return normalizedTimestamp.timestampAdd(normalizedUnit, normalizedAmount);\n}\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp.\n *\n * @example\n * ```typescript\n * // Subtract some duration determined by field 'unit' and 'amount' from the 'timestamp' field.\n * timestampSubtract(field(\"timestamp\"), field(\"unit\"), field(\"amount\"));\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n * @param amount - The expression evaluates to amount of the unit.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  timestamp: Expression,\n  unit: Expression,\n  amount: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp.\n *\n * @example\n * ```typescript\n * // Subtract 1 day from the 'timestamp' field.\n * timestampSubtract(field(\"timestamp\"), \"day\", 1);\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  timestamp: Expression,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp represented by a field.\n *\n * @example\n * ```typescript\n * // Subtract 1 day from the 'timestamp' field.\n * timestampSubtract(\"timestamp\", \"day\", 1);\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  fieldName: string,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\nexport function timestampSubtract(\n  timestamp: Expression | string,\n  unit:\n    | Expression\n    | 'microsecond'\n    | 'millisecond'\n    | 'second'\n    | 'minute'\n    | 'hour'\n    | 'day',\n  amount: Expression | number\n): FunctionExpression {\n  const normalizedTimestamp = fieldOrExpression(timestamp);\n  const normalizedUnit = valueToDefaultExpr(unit);\n  const normalizedAmount = valueToDefaultExpr(amount);\n  return normalizedTimestamp.timestampSubtract(\n    normalizedUnit,\n    normalizedAmount\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that evaluates to the current server timestamp.\n *\n * @example\n * ```typescript\n * // Get the current server timestamp\n * currentTimestamp()\n * ```\n *\n * @returns A new Expression representing the current server timestamp.\n */\nexport function currentTimestamp(): FunctionExpression {\n  return new FunctionExpression('current_timestamp', [], 'currentTimestamp');\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'AND' operation on multiple filter conditions.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18 AND the 'city' field is \"London\" AND\n * // the 'status' field is \"active\"\n * const condition = and(greaterThan(\"age\", 18), equal(\"city\", \"London\"), equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first filter condition.\n * @param second - The second filter condition.\n * @param more - Additional filter conditions to 'AND' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'AND' operation.\n */\nexport function and(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...more: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'and',\n    [first, second, ...more],\n    'and'\n  ).asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'OR' operation on multiple filter conditions.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18 OR the 'city' field is \"London\" OR\n * // the 'status' field is \"active\"\n * const condition = or(greaterThan(\"age\", 18), equal(\"city\", \"London\"), equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first filter condition.\n * @param second - The second filter condition.\n * @param more - Additional filter conditions to 'OR' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'OR' operation.\n */\nexport function or(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...more: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'or',\n    [first, second, ...more],\n    'xor'\n  ).asBoolean();\n}\n\n/**\n * @beta\n * Creates an expression that returns the value of the base expression raised to the power of the exponent expression.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of the 'exponent' field.\n * pow(field(\"base\"), field(\"exponent\"));\n * ```\n *\n * @param base - The expression to raise to the power of the exponent.\n * @param exponent - The expression to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: Expression, exponent: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base expression raised to the power of the exponent.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of 2.\n * pow(field(\"base\"), 2);\n * ```\n *\n * @param base - The expression to raise to the power of the exponent.\n * @param exponent - The constant value to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: Expression, exponent: number): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base field raised to the power of the exponent expression.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of the 'exponent' field.\n * pow(\"base\", field(\"exponent\"));\n * ```\n *\n * @param base - The name of the field to raise to the power of the exponent.\n * @param exponent - The expression to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: string, exponent: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base field raised to the power of the exponent.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of 2.\n * pow(\"base\", 2);\n * ```\n *\n * @param base - The name of the field to raise to the power of the exponent.\n * @param exponent - The constant value to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: string, exponent: number): FunctionExpression;\nexport function pow(\n  base: Expression | string,\n  exponent: Expression | number\n): FunctionExpression {\n  return fieldOrExpression(base).pow(exponent as number);\n}\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the nearest whole number.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field.\n * round(\"price\");\n * ```\n *\n * @param fieldName - The name of the field to round.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the nearest whole number.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field.\n * round(field(\"price\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be rounded.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field to two decimal places.\n * round(\"price\", 2);\n * ```\n *\n * @param fieldName - The name of the field to round.\n * @param decimalPlaces - A constant or expression specifying the rounding precision in decimal places.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(\n  fieldName: string,\n  decimalPlaces: number | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field to two decimal places.\n * round(field(\"price\"), constant(2));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be rounded.\n * @param decimalPlaces - A constant or expression specifying the rounding precision in decimal places.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(\n  expression: Expression,\n  decimalPlaces: number | Expression\n): FunctionExpression;\nexport function round(\n  expr: Expression | string,\n  decimalPlaces?: number | Expression\n): FunctionExpression {\n  if (decimalPlaces === undefined) {\n    return fieldOrExpression(expr).round();\n  } else {\n    return fieldOrExpression(expr).round(valueToDefaultExpr(decimalPlaces));\n  }\n}\n\n/**\n * @beta\n * Creates an expression that returns the collection ID from a path.\n *\n * @example\n * ```typescript\n * // Get the collection ID from a path.\n * collectionId(\"__name__\");\n * ```\n *\n * @param fieldName - The name of the field to get the collection ID from.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n */\nexport function collectionId(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the collection ID from a path.\n *\n * @example\n * ```typescript\n * // Get the collection ID from a path.\n * collectionId(field(\"__name__\"));\n * ```\n *\n * @param expression - An expression evaluating to a path, which the collection ID will be extracted from.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n */\nexport function collectionId(expression: Expression): FunctionExpression;\nexport function collectionId(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).collectionId();\n}\n\n/**\n * @beta\n * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n *\n * @example\n * ```typescript\n * // Get the length of the 'name' field.\n * length(\"name\");\n *\n * // Get the number of items in the 'cart' array.\n * length(\"cart\");\n * ```\n *\n * @param fieldName - The name of the field to calculate the length of.\n * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n */\nexport function length(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n *\n * @example\n * ```typescript\n * // Get the length of the 'name' field.\n * length(field(\"name\"));\n *\n * // Get the number of items in the 'cart' array.\n * length(field(\"cart\"));\n * ```\n *\n * @param expression - An expression evaluating to a string, array, map, vector, or bytes, which the length will be calculated for.\n * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n */\nexport function length(expression: Expression): FunctionExpression;\nexport function length(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).length();\n}\n\n/**\n * @beta\n * Creates an expression that computes the natural logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the natural logarithm of the 'value' field.\n * ln(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the natural logarithm of.\n * @returns A new `Expression` representing the natural logarithm of the numeric value.\n */\nexport function ln(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the natural logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the natural logarithm of the 'value' field.\n * ln(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the natural logarithm will be computed for.\n * @returns A new `Expression` representing the natural logarithm of the numeric value.\n */\nexport function ln(expression: Expression): FunctionExpression;\nexport function ln(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).ln();\n}\n\n/**\n * @beta\n * Creates an expression that computes the logarithm of an expression to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with base 10.\n * log(field(\"value\"), 10);\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the logarithm will be computed for.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(expression: Expression, base: number): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of an expression to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with the base in the 'base' field.\n * log(field(\"value\"), field(\"base\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the logarithm will be computed for.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(\n  expression: Expression,\n  base: Expression\n): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of a field to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with base 10.\n * log(\"value\", 10);\n * ```\n *\n * @param fieldName - The name of the field to compute the logarithm of.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(fieldName: string, base: number): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of a field to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with the base in the 'base' field.\n * log(\"value\", field(\"base\"));\n * ```\n *\n * @param fieldName - The name of the field to compute the logarithm of.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(fieldName: string, base: Expression): FunctionExpression;\nexport function log(\n  expr: Expression | string,\n  base: number | Expression\n): FunctionExpression {\n  return new FunctionExpression('log', [\n    fieldOrExpression(expr),\n    valueToDefaultExpr(base)\n  ]);\n}\n\n/**\n * @beta\n * Creates an expression that computes the square root of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the square root of the 'value' field.\n * sqrt(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the square root will be computed for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n */\nexport function sqrt(expression: Expression): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the square root of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the square root of the 'value' field.\n * sqrt(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the square root of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n */\nexport function sqrt(fieldName: string): FunctionExpression;\nexport function sqrt(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).sqrt();\n}\n\n/**\n * @beta\n * Creates an expression that reverses a string.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * strReverse(field(\"myString\"));\n * ```\n *\n * @param stringExpression - An expression evaluating to a string value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function stringReverse(stringExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that reverses a string value in the specified field.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * strReverse(\"myString\");\n * ```\n *\n * @param field - The name of the field representing the string to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function stringReverse(field: string): FunctionExpression;\nexport function stringReverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).stringReverse();\n}\n\n/**\n * @beta\n * Creates an expression that concatenates strings, arrays, or blobs. Types cannot be mixed.\n *\n * @example\n * ```typescript\n * // Concatenate the 'firstName' and 'lastName' fields with a space in between.\n * concat(field(\"firstName\"), \" \", field(\"lastName\"))\n * ```\n *\n * @param first - The first expressions to concatenate.\n * @param second - The second literal or expression to concatenate.\n * @param others - Additional literals or expressions to concatenate.\n * @returns A new `Expression` representing the concatenation.\n */\nexport function concat(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that concatenates strings, arrays, or blobs. Types cannot be mixed.\n *\n * @example\n * ```typescript\n * // Concatenate a field with a literal string.\n * concat(field(\"firstName\"), \"Doe\")\n * ```\n *\n * @param fieldName - The name of a field to concatenate.\n * @param second - The second literal or expression to concatenate.\n * @param others - Additional literal or expressions to concatenate.\n * @returns A new `Expression` representing the concatenation.\n */\nexport function concat(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function concat(\n  fieldNameOrExpression: string | Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return new FunctionExpression('concat', [\n    fieldOrExpression(fieldNameOrExpression),\n    valueToDefaultExpr(second),\n    ...others.map(valueToDefaultExpr)\n  ]);\n}\n\n/**\n * @beta\n * Creates an expression that computes the absolute value of a numeric value.\n *\n * @param expr - The expression to compute the absolute value of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n */\nexport function abs(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the absolute value of a numeric value.\n *\n * @param fieldName - The field to compute the absolute value of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n */\nexport function abs(fieldName: string): FunctionExpression;\nexport function abs(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).abs();\n}\n\n/**\n * @beta\n * Creates an expression that returns the `elseExpr` argument if `ifExpr` is absent, else return\n * the result of the `ifExpr` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(field(\"optional_field\"), constant(\"default_value\"))\n * ```\n *\n * @param ifExpr - The expression to check for absence.\n * @param elseExpr - The expression that will be evaluated and returned if [ifExpr] is absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(ifExpr: Expression, elseExpr: Expression): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseValue` argument if `ifExpr` is absent, else\n * return the result of the `ifExpr` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(field(\"optional_field\"), \"default_value\")\n * ```\n *\n * @param ifExpr - The expression to check for absence.\n * @param elseValue - The value that will be returned if `ifExpr` evaluates to an absent value.\n * @returns A new [Expression] representing the ifAbsent operation.\n */\nexport function ifAbsent(ifExpr: Expression, elseValue: unknown): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseExpr` argument if `ifFieldName` is absent, else\n * return the value of the field.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns the value of\n * // 'default_field' if 'optional_field' is absent.\n * ifAbsent(\"optional_field\", field(\"default_field\"))\n * ```\n *\n * @param ifFieldName - The field to check for absence.\n * @param elseExpr - The expression that will be evaluated and returned if `ifFieldName` is\n * absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(ifFieldName: string, elseExpr: Expression): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseValue` argument if `ifFieldName` is absent, else\n * return the value of the field.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(\"optional_field\", \"default_value\")\n * ```\n *\n * @param ifFieldName - The field to check for absence.\n * @param elseValue - The value that will be returned if [ifFieldName] is absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(\n  ifFieldName: string | Expression,\n  elseValue: Expression | unknown\n): Expression;\nexport function ifAbsent(\n  fieldNameOrExpression: string | Expression,\n  elseValue: Expression | unknown\n): Expression {\n  return fieldOrExpression(fieldNameOrExpression).ifAbsent(\n    valueToDefaultExpr(elseValue)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with a comma and space.\n * join(\"tags\", \", \")\n * ```\n *\n * @param arrayFieldName - The name of the field containing the array.\n * @param delimiter - The string to use as a delimiter.\n * @returns A new Expression representing the join operation.\n */\nexport function join(arrayFieldName: string, delimiter: string): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join an array of string using the delimiter from the 'separator' field.\n * join(array(['foo', 'bar']), field(\"separator\"))\n * ```\n *\n * @param arrayExpression - An expression that evaluates to an array.\n * @param delimiterExpression - The expression that evaluates to the delimiter string.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayExpression: Expression,\n  delimiterExpression: Expression\n): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with a comma and space.\n * join(field(\"tags\"), \", \")\n * ```\n *\n * @param arrayExpression - An expression that evaluates to an array.\n * @param delimiter - The string to use as a delimiter.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayExpression: Expression,\n  delimiter: string\n): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with the delimiter from the 'separator' field.\n * join('tags', field(\"separator\"))\n * ```\n *\n * @param arrayFieldName - The name of the field containing the array.\n * @param delimiterExpression - The expression that evaluates to the delimiter string.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayFieldName: string,\n  delimiterExpression: Expression\n): Expression;\nexport function join(\n  fieldNameOrExpression: string | Expression,\n  delimiterValueOrExpression: Expression | string\n): Expression {\n  return fieldOrExpression(fieldNameOrExpression).join(\n    valueToDefaultExpr(delimiterValueOrExpression)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that computes the base-10 logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the base-10 logarithm of the 'value' field.\n * log10(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the base-10 logarithm of.\n * @returns A new `Expression` representing the base-10 logarithm of the numeric value.\n */\nexport function log10(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the base-10 logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the base-10 logarithm of the 'value' field.\n * log10(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the base-10 logarithm will be computed for.\n * @returns A new `Expression` representing the base-10 logarithm of the numeric value.\n */\nexport function log10(expression: Expression): FunctionExpression;\nexport function log10(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).log10();\n}\n\n/**\n * @beta\n * Creates an expression that computes the sum of the elements in an array.\n *\n * @example\n * ```typescript\n * // Compute the sum of the elements in the 'scores' field.\n * arraySum(\"scores\");\n * ```\n *\n * @param fieldName - The name of the field to compute the sum of.\n * @returns A new `Expression` representing the sum of the elements in the array.\n */\nexport function arraySum(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the sum of the elements in an array.\n *\n * @example\n * ```typescript\n * // Compute the sum of the elements in the 'scores' field.\n * arraySum(field(\"scores\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric array, which the sum will be computed for.\n * @returns A new `Expression` representing the sum of the elements in the array.\n */\nexport function arraySum(expression: Expression): FunctionExpression;\nexport function arraySum(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).arraySum();\n}\n\n/**\n * @beta\n * Creates an expression that splits the value of a field on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scoresCsv' field on delimiter ','\n * split('scoresCsv', ',')\n * ```\n *\n * @param fieldName - Split the value in this field.\n * @param delimiter - Split on this delimiter.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(fieldName: string, delimiter: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits the value of a field on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n * split('scores', conditional(field('format').equal('csv'), constant(','), constant(':'))\n * ```\n *\n * @param fieldName - Split the value in this field.\n * @param delimiter - Split on this delimiter returned by evaluating this expression.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  fieldName: string,\n  delimiter: Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits a string into an array of substrings based on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scoresCsv' field on delimiter ','\n * split(field('scoresCsv'), ',')\n * ```\n *\n * @param expression - Split the result of this expression.\n * @param delimiter - Split on this delimiter.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  expression: Expression,\n  delimiter: string\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits a string into an array of substrings based on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n * split(field('scores'), conditional(field('format').equal('csv'), constant(','), constant(':'))\n * ```\n *\n * @param expression - Split the result of this expression.\n * @param delimiter - Split on this delimiter returned by evaluating this expression.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  expression: Expression,\n  delimiter: Expression\n): FunctionExpression;\nexport function split(\n  fieldNameOrExpression: string | Expression,\n  delimiter: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldNameOrExpression).split(\n    valueToDefaultExpr(delimiter)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the beginning of the day.\n * field('createdAt').timestampTruncate('day')\n * ```\n *\n * @param fieldName - Truncate the timestamp value contained in this field.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  fieldName: string,\n  granularity: TimeGranularity,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n * field('createdAt').timestampTruncate(field('granularity'))\n * ```\n *\n * @param fieldName - Truncate the timestamp value contained in this field.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  fieldName: string,\n  granularity: Expression,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the beginning of the day.\n * field('createdAt').timestampTruncate('day')\n * ```\n *\n * @param timestampExpression - Truncate the timestamp value that is returned by this expression.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  timestampExpression: Expression,\n  granularity: TimeGranularity,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n * field('createdAt').timestampTruncate(field('granularity'))\n * ```\n *\n * @param timestampExpression - Truncate the timestamp value that is returned by this expression.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  timestampExpression: Expression,\n  granularity: Expression,\n  timezone?: string | Expression\n): FunctionExpression;\nexport function timestampTruncate(\n  fieldNameOrExpression: string | Expression,\n  granularity: TimeGranularity | Expression,\n  timezone?: string | Expression\n): FunctionExpression {\n  const internalGranularity = isString(granularity)\n    ? valueToDefaultExpr(granularity.toLowerCase())\n    : granularity;\n  return fieldOrExpression(fieldNameOrExpression).timestampTruncate(\n    internalGranularity,\n    timezone\n  );\n}\n\n/**\n * @beta\n * Creates an expression that returns the data type of the data in the specified field.\n *\n * @example\n * ```typescript\n * // Get the data type of the value in field 'title'\n * type('title')\n * ```\n *\n * @returns A new `Expression` representing the data type.\n */\nexport function type(fieldName: string): FunctionExpression;\n/**\n * @beta\n * Creates an expression that returns the data type of an expression's result.\n *\n * @example\n * ```typescript\n * // Get the data type of a conditional expression\n * type(conditional(exists('foo'), constant(1), constant(true)))\n * ```\n *\n * @returns A new `Expression` representing the data type.\n */\nexport function type(expression: Expression): FunctionExpression;\nexport function type(\n  fieldNameOrExpression: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldNameOrExpression).type();\n}\n\n// TODO(new-expression): Add new top-level expression function definitions above this line\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on an expression.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in lowercase in ascending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(ascending(field(\"name\").toLower()));\n * ```\n *\n * @param expr - The expression to create an ascending ordering for.\n * @returns A new `Ordering` for ascending sorting.\n */\nexport function ascending(expr: Expression): Ordering;\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on a field.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in ascending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(ascending(\"name\"));\n * ```\n *\n * @param fieldName - The field to create an ascending ordering for.\n * @returns A new `Ordering` for ascending sorting.\n */\nexport function ascending(fieldName: string): Ordering;\nexport function ascending(field: Expression | string): Ordering {\n  return new Ordering(fieldOrExpression(field), 'ascending', 'ascending');\n}\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on an expression.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in lowercase in descending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(descending(field(\"name\").toLower()));\n * ```\n *\n * @param expr - The expression to create a descending ordering for.\n * @returns A new `Ordering` for descending sorting.\n */\nexport function descending(expr: Expression): Ordering;\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on a field.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in descending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(descending(\"name\"));\n * ```\n *\n * @param fieldName - The field to create a descending ordering for.\n * @returns A new `Ordering` for descending sorting.\n */\nexport function descending(fieldName: string): Ordering;\nexport function descending(field: Expression | string): Ordering {\n  return new Ordering(fieldOrExpression(field), 'descending', 'descending');\n}\n\n/**\n * @beta\n *\n * Represents an ordering criterion for sorting documents in a Firestore pipeline.\n *\n * You create `Ordering` instances using the `ascending` and `descending` helper functions.\n */\nexport class Ordering implements ProtoValueSerializable, UserData {\n  constructor(\n    public readonly expr: Expression,\n    public readonly direction: 'ascending' | 'descending',\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      mapValue: {\n        fields: {\n          direction: toStringValue(this.direction),\n          expression: this.expr._toProto(serializer)\n        }\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.expr._readUserData(context);\n  }\n\n  _protoValueType: 'ProtoValue' = 'ProtoValue';\n}\n\nexport function isSelectable(val: unknown): val is Selectable {\n  const candidate = val as Selectable;\n  return (\n    candidate.selectable && isString(candidate.alias) && isExpr(candidate.expr)\n  );\n}\n\nexport function isOrdering(val: unknown): val is Ordering {\n  const candidate = val as Ordering;\n  return (\n    isExpr(candidate.expr) &&\n    (candidate.direction === 'ascending' ||\n      candidate.direction === 'descending')\n  );\n}\n\nexport function isAliasedAggregate(val: unknown): val is AliasedAggregate {\n  const candidate = val as AliasedAggregate;\n  return (\n    isString(candidate.alias) &&\n    candidate.aggregate instanceof AggregateFunction\n  );\n}\n\nexport function isExpr(val: unknown): val is Expression {\n  return val instanceof Expression;\n}\n\nexport function isBooleanExpr(val: unknown): val is BooleanExpression {\n  return val instanceof BooleanExpression;\n}\n\nexport function isField(val: unknown): val is Field {\n  return val instanceof Field;\n}\n\nexport function toField(value: string | Field): Field {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return value as Field;\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Firestore } from '../lite-api/database';\nimport {\n  Constant,\n  BooleanExpression,\n  and,\n  or,\n  Ordering,\n  lessThan,\n  greaterThan,\n  field\n} from '../lite-api/expressions';\nimport { Pipeline } from '../lite-api/pipeline';\nimport { doc } from '../lite-api/reference';\nimport { fail } from '../util/assert';\n\nimport { Bound } from './bound';\nimport {\n  CompositeFilter as CompositeFilterInternal,\n  CompositeOperator,\n  FieldFilter as FieldFilterInternal,\n  Filter as FilterInternal,\n  Operator\n} from './filter';\nimport { Direction } from './order_by';\nimport {\n  isCollectionGroupQuery,\n  isDocumentQuery,\n  LimitType,\n  Query,\n  queryNormalizedOrderBy\n} from './query';\n\n/* eslint @typescript-eslint/no-explicit-any: 0 */\n\nexport function toPipelineBooleanExpr(f: FilterInternal): BooleanExpression {\n  if (f instanceof FieldFilterInternal) {\n    const fieldValue = field(f.field.toString());\n    // Comparison filters\n    const value = f.value;\n    switch (f.op) {\n      case Operator.LESS_THAN:\n        return and(\n          fieldValue.exists(),\n          fieldValue.lessThan(Constant._fromProto(value))\n        );\n      case Operator.LESS_THAN_OR_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.lessThanOrEqual(Constant._fromProto(value))\n        );\n      case Operator.GREATER_THAN:\n        return and(\n          fieldValue.exists(),\n          fieldValue.greaterThan(Constant._fromProto(value))\n        );\n      case Operator.GREATER_THAN_OR_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.greaterThanOrEqual(Constant._fromProto(value))\n        );\n      case Operator.EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.equal(Constant._fromProto(value))\n        );\n      case Operator.NOT_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.notEqual(Constant._fromProto(value))\n        );\n      case Operator.ARRAY_CONTAINS:\n        return and(\n          fieldValue.exists(),\n          fieldValue.arrayContains(Constant._fromProto(value))\n        );\n      case Operator.IN: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        if (!values) {\n          return and(fieldValue.exists(), fieldValue.equalAny([]));\n        } else if (values.length === 1) {\n          return and(fieldValue.exists(), fieldValue.equal(values[0]));\n        } else {\n          return and(fieldValue.exists(), fieldValue.equalAny(values));\n        }\n      }\n      case Operator.ARRAY_CONTAINS_ANY: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        return and(fieldValue.exists(), fieldValue.arrayContainsAny(values!));\n      }\n      case Operator.NOT_IN: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        if (!values) {\n          return and(fieldValue.exists(), fieldValue.notEqualAny([]));\n        } else if (values.length === 1) {\n          return and(fieldValue.exists(), fieldValue.notEqual(values[0]));\n        } else {\n          return and(fieldValue.exists(), fieldValue.notEqualAny(values));\n        }\n      }\n      default:\n        fail(0x9047, 'Unexpected operator');\n    }\n  } else if (f instanceof CompositeFilterInternal) {\n    switch (f.op) {\n      case CompositeOperator.AND: {\n        const conditions = f.getFilters().map(f => toPipelineBooleanExpr(f));\n        return and(conditions[0], conditions[1], ...conditions.slice(2));\n      }\n      case CompositeOperator.OR: {\n        const conditions = f.getFilters().map(f => toPipelineBooleanExpr(f));\n        return or(conditions[0], conditions[1], ...conditions.slice(2));\n      }\n      default:\n        fail(0x89ea, 'Unexpected operator');\n    }\n  }\n\n  throw new Error(`Failed to convert filter to pipeline conditions: ${f}`);\n}\n\nfunction reverseOrderings(orderings: Ordering[]): Ordering[] {\n  return orderings.map(\n    o =>\n      new Ordering(\n        o.expr,\n        o.direction === 'ascending' ? 'descending' : 'ascending',\n        undefined\n      )\n  );\n}\n\nexport function toPipeline(query: Query, db: Firestore): Pipeline {\n  let pipeline: Pipeline;\n  if (isCollectionGroupQuery(query)) {\n    pipeline = db.pipeline().collectionGroup(query.collectionGroup!);\n  } else if (isDocumentQuery(query)) {\n    pipeline = db.pipeline().documents([doc(db, query.path.canonicalString())]);\n  } else {\n    pipeline = db.pipeline().collection(query.path.canonicalString());\n  }\n\n  // filters\n  for (const filter of query.filters) {\n    pipeline = pipeline.where(toPipelineBooleanExpr(filter));\n  }\n\n  // orders\n  const orders = queryNormalizedOrderBy(query);\n  const existsConditions = orders.map(order =>\n    field(order.field.canonicalString()).exists()\n  );\n  if (existsConditions.length > 1) {\n    pipeline = pipeline.where(\n      and(\n        existsConditions[0],\n        existsConditions[1],\n        ...existsConditions.slice(2)\n      )\n    );\n  } else {\n    pipeline = pipeline.where(existsConditions[0]);\n  }\n\n  const orderings = orders.map(order =>\n    order.dir === Direction.ASCENDING\n      ? field(order.field.canonicalString()).ascending()\n      : field(order.field.canonicalString()).descending()\n  );\n\n  if (orderings.length > 0) {\n    if (query.limitType === LimitType.Last) {\n      const actualOrderings = reverseOrderings(orderings);\n      pipeline = pipeline.sort(actualOrderings[0], ...actualOrderings.slice(1));\n      // cursors\n      if (query.startAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.startAt, orderings, 'after')\n        );\n      }\n\n      if (query.endAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.endAt, orderings, 'before')\n        );\n      }\n\n      pipeline = pipeline.limit(query.limit!);\n      pipeline = pipeline.sort(orderings[0], ...orderings.slice(1));\n    } else {\n      pipeline = pipeline.sort(orderings[0], ...orderings.slice(1));\n      if (query.startAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.startAt, orderings, 'after')\n        );\n      }\n      if (query.endAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.endAt, orderings, 'before')\n        );\n      }\n\n      if (query.limit !== null) {\n        pipeline = pipeline.limit(query.limit);\n      }\n    }\n  }\n\n  return pipeline;\n}\n\nfunction whereConditionsFromCursor(\n  bound: Bound,\n  orderings: Ordering[],\n  position: 'before' | 'after'\n): BooleanExpression {\n  // The filterFunc is either greater than or less than\n  const filterFunc = position === 'before' ? lessThan : greaterThan;\n  const cursors = bound.position.map(value => Constant._fromProto(value));\n  const size = cursors.length;\n\n  let field = orderings[size - 1].expr;\n  let value = cursors[size - 1];\n\n  // Add condition for last bound\n  let condition: BooleanExpression = filterFunc(field, value);\n  if (bound.inclusive) {\n    // When the cursor bound is inclusive, then the last bound\n    // can be equal to the value, otherwise it's not equal\n    condition = or(condition, field.equal(value));\n  }\n\n  // Iterate backwards over the remaining bounds, adding\n  // a condition for each one\n  for (let i = size - 2; i >= 0; i--) {\n    field = orderings[i].expr;\n    value = cursors[i];\n\n    // For each field in the orderings, the condition is either\n    // a) lt|gt the cursor value,\n    // b) or equal the cursor value and lt|gt the cursor values for other fields\n    condition = or(\n      filterFunc(field, value),\n      and(field.equal(value), condition)\n    );\n  }\n\n  return condition;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParseContext } from '../api/parse_context';\nimport { OptionsUtil } from '../core/options_util';\nimport {\n  ApiClientObjectMap,\n  firestoreV1ApiClientInterfaces,\n  Stage as ProtoStage\n} from '../protos/firestore_proto_api';\nimport { toNumber } from '../remote/number_serializer';\nimport {\n  JsonProtoSerializer,\n  ProtoSerializable,\n  toMapValue,\n  toPipelineValue,\n  toStringValue\n} from '../remote/serializer';\nimport { hardAssert } from '../util/assert';\n\nimport {\n  AggregateFunction,\n  BooleanExpression,\n  Expression,\n  Field,\n  field,\n  Ordering\n} from './expressions';\nimport { Pipeline } from './pipeline';\nimport { StageOptions } from './stage_options';\nimport { isUserData, UserData } from './user_data_reader';\n\n/**\n * @beta\n */\nexport abstract class Stage implements ProtoSerializable<ProtoStage>, UserData {\n  /**\n   * Store optionsProto parsed by _readUserData.\n   * @private\n   * @internal\n   * @protected\n   */\n  protected optionsProto:\n    | ApiClientObjectMap<firestoreV1ApiClientInterfaces.Value>\n    | undefined = undefined;\n  protected knownOptions: Record<string, unknown>;\n  protected rawOptions?: Record<string, unknown>;\n\n  constructor(options: StageOptions) {\n    ({ rawOptions: this.rawOptions, ...this.knownOptions } = options);\n  }\n\n  _readUserData(context: ParseContext): void {\n    this.optionsProto = this._optionsUtil.getOptionsProto(\n      context,\n      this.knownOptions,\n      this.rawOptions\n    );\n  }\n\n  _toProto(_: JsonProtoSerializer): ProtoStage {\n    return {\n      name: this._name,\n      options: this.optionsProto\n    };\n  }\n\n  abstract get _optionsUtil(): OptionsUtil;\n  abstract get _name(): string;\n}\n\n/**\n * @beta\n */\nexport class AddFields extends Stage {\n  get _name(): string {\n    return 'add_fields';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private fields: Map<string, Expression>, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.fields)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.fields, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class RemoveFields extends Stage {\n  get _name(): string {\n    return 'remove_fields';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private fields: Field[], options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.fields.map(f => f._toProto(serializer))\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.fields, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Aggregate extends Stage {\n  get _name(): string {\n    return 'aggregate';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private groups: Map<string, Expression>,\n    private accumulators: Map<string, AggregateFunction>,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        toMapValue(serializer, this.accumulators),\n        toMapValue(serializer, this.groups)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.groups, context);\n    readUserDataHelper(this.accumulators, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Distinct extends Stage {\n  get _name(): string {\n    return 'distinct';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private groups: Map<string, Expression>, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.groups)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.groups, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class CollectionSource extends Stage {\n  get _name(): string {\n    return 'collection';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      forceIndex: {\n        serverName: 'force_index'\n      }\n    });\n  }\n\n  private formattedCollectionPath: string;\n\n  constructor(collection: string, options: StageOptions) {\n    super(options);\n\n    // prepend slash to collection string\n    this.formattedCollectionPath = collection.startsWith('/')\n      ? collection\n      : '/' + collection;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [{ referenceValue: this.formattedCollectionPath }]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class CollectionGroupSource extends Stage {\n  get _name(): string {\n    return 'collection_group';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      forceIndex: {\n        serverName: 'force_index'\n      }\n    });\n  }\n\n  constructor(private collectionId: string, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [{ referenceValue: '' }, { stringValue: this.collectionId }]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class DatabaseSource extends Stage {\n  get _name(): string {\n    return 'database';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer)\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class DocumentsSource extends Stage {\n  get _name(): string {\n    return 'documents';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  private formattedPaths: string[];\n\n  constructor(docPaths: string[], options: StageOptions) {\n    super(options);\n    this.formattedPaths = docPaths.map(path =>\n      path.startsWith('/') ? path : '/' + path\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.formattedPaths.map(p => {\n        return { referenceValue: p };\n      })\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Where extends Stage {\n  get _name(): string {\n    return 'where';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private condition: BooleanExpression, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [this.condition._toProto(serializer)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.condition, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class FindNearest extends Stage {\n  get _name(): string {\n    return 'find_nearest';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      limit: {\n        serverName: 'limit'\n      },\n      distanceField: {\n        serverName: 'distance_field'\n      }\n    });\n  }\n\n  constructor(\n    private vectorValue: Expression,\n    private field: Field,\n    private distanceMeasure: 'euclidean' | 'cosine' | 'dot_product',\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        this.field._toProto(serializer),\n        this.vectorValue._toProto(serializer),\n        toStringValue(this.distanceMeasure)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.vectorValue, context);\n    readUserDataHelper(this.field, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Limit extends Stage {\n  get _name(): string {\n    return 'limit';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private limit: number, options: StageOptions) {\n    hardAssert(\n      !isNaN(limit) && limit !== Infinity && limit !== -Infinity,\n      0x882c,\n      'Invalid limit value'\n    );\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.limit)]\n    };\n  }\n}\n\n/**\n * @beta\n */\nexport class Offset extends Stage {\n  get _name(): string {\n    return 'offset';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private offset: number, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.offset)]\n    };\n  }\n}\n\n/**\n * @beta\n */\nexport class Select extends Stage {\n  get _name(): string {\n    return 'select';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private selections: Map<string, Expression>,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.selections)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.selections, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Sort extends Stage {\n  get _name(): string {\n    return 'sort';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private orderings: Ordering[], options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.orderings.map(o => o._toProto(serializer))\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.orderings, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Sample extends Stage {\n  get _name(): string {\n    return 'sample';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private rate: number,\n    private mode: 'percent' | 'documents',\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.rate)!, toStringValue(this.mode)!]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Union extends Stage {\n  get _name(): string {\n    return 'union';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private other: Pipeline, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toPipelineValue(this.other._toProto(serializer))]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Unnest extends Stage {\n  get _name(): string {\n    return 'unnest';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      indexField: {\n        serverName: 'index_field'\n      }\n    });\n  }\n\n  constructor(\n    private alias: string,\n    private expr: Expression,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        this.expr._toProto(serializer),\n        field(this.alias)._toProto(serializer)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.expr, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Replace extends Stage {\n  static readonly MODE = 'full_replace';\n\n  get _name(): string {\n    return 'replace_with';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private map: Expression, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [this.map._toProto(serializer), toStringValue(Replace.MODE)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.map, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class RawStage extends Stage {\n  /**\n   * @private\n   * @internal\n   */\n  constructor(\n    private name: string,\n    private params: Array<AggregateFunction | Expression>,\n    rawOptions: Record<string, unknown>\n  ) {\n    super({ rawOptions });\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      name: this.name,\n      args: this.params.map(o => o._toProto(serializer)),\n      options: this.optionsProto\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.params, context);\n  }\n\n  get _name(): string {\n    return this.name;\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n}\n\n/**\n * Helper to read user data across a number of different formats.\n * @param name - Name of the calling function. Used for error messages when invalid user data is encountered.\n * @param expressionMap\n * @returns the expressionMap argument.\n * @private\n */\nfunction readUserDataHelper<\n  T extends Map<string, UserData> | UserData[] | UserData\n>(expressionMap: T, context: ParseContext): T {\n  if (isUserData(expressionMap)) {\n    expressionMap._readUserData(context);\n  } else if (Array.isArray(expressionMap)) {\n    expressionMap.forEach(readableData => readableData._readUserData(context));\n  } else {\n    expressionMap.forEach(expr => expr._readUserData(context));\n  }\n  return expressionMap;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DatabaseId } from '../core/database_info';\nimport { toPipeline } from '../core/pipeline-util';\nimport { Code, FirestoreError } from '../util/error';\nimport { isString } from '../util/types';\n\nimport { Pipeline } from './pipeline';\nimport {\n  CollectionReference,\n  DocumentReference,\n  isCollectionReference,\n  Query\n} from './reference';\nimport {\n  CollectionGroupSource,\n  CollectionSource,\n  DatabaseSource,\n  DocumentsSource,\n  Stage\n} from './stage';\nimport {\n  CollectionGroupStageOptions,\n  CollectionStageOptions,\n  DatabaseStageOptions,\n  DocumentsStageOptions\n} from './stage_options';\nimport { UserDataReader, UserDataSource } from './user_data_reader';\n\n/**\n * @beta\n * Provides the entry point for defining the data source of a Firestore {@link @firebase/firestore/pipelines#Pipeline}.\n *\n * Use the methods of this class (e.g., {@link @firebase/firestore/pipelines#PipelineSource.(collection:1)}, {@link @firebase/firestore/pipelines#PipelineSource.(collectionGroup:1)},\n * {@link @firebase/firestore/pipelines#PipelineSource.(database:1)}, or {@link @firebase/firestore/pipelines#PipelineSource.(documents:1)}) to specify the initial data\n * for your pipeline, such as a collection, a collection group, the entire database, or a set of specific documents.\n */\nexport class PipelineSource<PipelineType> {\n  /**\n   * @internal\n   * @private\n   * @param databaseId\n   * @param userDataReader\n   * @param _createPipeline\n   */\n  constructor(\n    private databaseId: DatabaseId,\n    private userDataReader: UserDataReader,\n    /**\n     * @internal\n     * @private\n     */\n    public _createPipeline: (stages: Stage[]) => PipelineType\n  ) {}\n\n  /**\n   * @beta\n   * Returns all documents from the entire collection. The collection can be nested.\n   * @param collection - Name or reference to the collection that will be used as the Pipeline source.\n   */\n  collection(collection: string | CollectionReference): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from the entire collection. The collection can be nested.\n   * @param options - Options defining how this CollectionStage is evaluated.\n   */\n  collection(options: CollectionStageOptions): PipelineType;\n  collection(\n    collectionOrOptions: string | CollectionReference | CollectionStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(collectionOrOptions) ||\n      isCollectionReference(collectionOrOptions)\n        ? {}\n        : collectionOrOptions;\n    const collectionRefOrString =\n      isString(collectionOrOptions) ||\n      isCollectionReference(collectionOrOptions)\n        ? collectionOrOptions\n        : collectionOrOptions.collection;\n\n    // Validate that a user provided reference is for the same Firestore DB\n    if (isCollectionReference(collectionRefOrString)) {\n      this._validateReference(collectionRefOrString);\n    }\n\n    // Convert user land convenience types to internal types\n    const normalizedCollection = isString(collectionRefOrString)\n      ? (collectionRefOrString as string)\n      : collectionRefOrString.path;\n\n    // Create stage object\n    const stage = new CollectionSource(normalizedCollection, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'collection'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Returns all documents from a collection ID regardless of the parent.\n   * @param collectionId - ID of the collection group to use as the Pipeline source.\n   */\n  collectionGroup(collectionId: string): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from a collection ID regardless of the parent.\n   * @param options - Options defining how this CollectionGroupStage is evaluated.\n   */\n  collectionGroup(options: CollectionGroupStageOptions): PipelineType;\n  collectionGroup(\n    collectionIdOrOptions: string | CollectionGroupStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    let collectionId: string;\n    let options: {};\n    if (isString(collectionIdOrOptions)) {\n      collectionId = collectionIdOrOptions;\n      options = {};\n    } else {\n      ({ collectionId, ...options } = collectionIdOrOptions);\n    }\n\n    // Create stage object\n    const stage = new CollectionGroupSource(collectionId, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'collectionGroup'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Returns all documents from the entire database.\n   */\n  database(): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from the entire database.\n   * @param options - Options defining how a DatabaseStage is evaluated.\n   */\n  database(options: DatabaseStageOptions): PipelineType;\n  database(options?: DatabaseStageOptions): PipelineType {\n    // Process argument union(s) from method overloads\n    options = options ?? {};\n\n    // Create stage object\n    const stage = new DatabaseSource(options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'database'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Set the pipeline's source to the documents specified by the given paths and DocumentReferences.\n   *\n   * @param docs - An array of paths and DocumentReferences specifying the individual documents that will be the source of this pipeline.\n   * The converters for these DocumentReferences will be ignored and not have an effect on this pipeline.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  documents(docs: Array<string | DocumentReference>): PipelineType;\n\n  /**\n   * @beta\n   * Set the pipeline's source to the documents specified by the given paths and DocumentReferences.\n   *\n   * @param options - Options defining how this DocumentsStage is evaluated.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  documents(options: DocumentsStageOptions): PipelineType;\n  documents(\n    docsOrOptions: Array<string | DocumentReference> | DocumentsStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let docs: Array<string | DocumentReference>;\n    if (Array.isArray(docsOrOptions)) {\n      docs = docsOrOptions;\n      options = {};\n    } else {\n      ({ docs, ...options } = docsOrOptions);\n    }\n\n    // Validate that all user provided references are for the same Firestore DB\n    docs\n      .filter(v => v instanceof DocumentReference)\n      .forEach(dr => this._validateReference(dr as DocumentReference));\n\n    // Convert user land convenience types to internal types\n    const normalizedDocs: string[] = docs.map(doc =>\n      isString(doc) ? doc : doc.path\n    );\n\n    // Create stage object\n    const stage = new DocumentsSource(normalizedDocs, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'documents'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Convert the given Query into an equivalent Pipeline.\n   *\n   * @param query - A Query to be converted into a Pipeline.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  createFrom(query: Query): Pipeline {\n    return toPipeline(query._query, query.firestore);\n  }\n\n  _validateReference(reference: CollectionReference | DocumentReference): void {\n    const refDbId = reference.firestore._databaseId;\n    if (!refDbId.isEqual(this.databaseId)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid ${\n          reference instanceof CollectionReference\n            ? 'CollectionReference'\n            : 'DocumentReference'\n        }. ` +\n          `The project ID (\"${refDbId.projectId}\") or the database (\"${refDbId.database}\") does not match ` +\n          `the project ID (\"${this.databaseId.projectId}\") and database (\"${this.databaseId.database}\") of the target database of this Pipeline.`\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ObjectValue } from '../model/object_value';\nimport { firestoreV1ApiClientInterfaces } from '../protos/firestore_proto_api';\nimport { isOptionalEqual } from '../util/misc';\n\nimport { Field, isField } from './expressions';\nimport { FieldPath } from './field_path';\nimport { Pipeline } from './pipeline';\nimport { DocumentData, DocumentReference, refEqual } from './reference';\nimport { Timestamp } from './timestamp';\nimport { fieldPathFromArgument } from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * @beta\n * Represents the results of a Firestore pipeline execution.\n *\n * A `PipelineSnapshot` contains zero or more {@link @firebase/firestore/pipelines#PipelineResult} objects\n * representing the documents returned by a pipeline query. It provides methods\n * to iterate over the documents and access metadata about the query results.\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await firestore\n *   .pipeline()\n *   .collection('myCollection')\n *   .where(field('value').greaterThan(10))\n *   .execute();\n *\n * snapshot.results.forEach(doc => {\n *   console.log(doc.id, '=>', doc.data());\n * });\n * ```\n */\nexport class PipelineSnapshot {\n  private readonly _pipeline: Pipeline;\n  private readonly _executionTime: Timestamp | undefined;\n  private readonly _results: PipelineResult[];\n  constructor(\n    pipeline: Pipeline,\n    results: PipelineResult[],\n    executionTime?: Timestamp\n  ) {\n    this._pipeline = pipeline;\n    this._executionTime = executionTime;\n    this._results = results;\n  }\n\n  /**\n   * @beta An array of all the results in the `PipelineSnapshot`.\n   */\n  get results(): PipelineResult[] {\n    return this._results;\n  }\n\n  /**\n   * @beta\n   * The time at which the pipeline producing this result is executed.\n   *\n   * @readonly\n   *\n   */\n  get executionTime(): Timestamp {\n    if (this._executionTime === undefined) {\n      throw new Error(\n        \"'executionTime' is expected to exist, but it is undefined\"\n      );\n    }\n    return this._executionTime;\n  }\n}\n\n/**\n * @beta\n *\n * A PipelineResult contains data read from a Firestore Pipeline. The data can be extracted with the\n * {@link @firebase/firestore/pipelines#PipelineResult.data} or {@link @firebase/firestore/pipelines#PipelineResult.(get:1)} methods.\n *\n * <p>If the PipelineResult represents a non-document result, `ref` will return a undefined\n * value.\n */\nexport class PipelineResult<AppModelType = DocumentData> {\n  private readonly _userDataWriter: AbstractUserDataWriter;\n\n  private readonly _createTime: Timestamp | undefined;\n  private readonly _updateTime: Timestamp | undefined;\n\n  /**\n   * @internal\n   * @private\n   */\n  readonly _ref: DocumentReference | undefined;\n\n  /**\n   * @internal\n   * @private\n   */\n  readonly _fields: ObjectValue;\n\n  /**\n   * @private\n   * @internal\n   *\n   * @param userDataWriter - The serializer used to encode/decode protobuf.\n   * @param ref - The reference to the document.\n   * @param fields - The fields of the Firestore `Document` Protobuf backing\n   * this document.\n   * @param createTime - The time when the document was created if the result is a document, undefined otherwise.\n   * @param updateTime - The time when the document was last updated if the result is a document, undefined otherwise.\n   */\n  constructor(\n    userDataWriter: AbstractUserDataWriter,\n    fields: ObjectValue,\n    ref?: DocumentReference,\n    createTime?: Timestamp,\n    updateTime?: Timestamp\n  ) {\n    this._ref = ref;\n    this._userDataWriter = userDataWriter;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n    this._fields = fields;\n  }\n\n  /**\n   * @beta\n   * The reference of the document, if it is a document; otherwise `undefined`.\n   */\n  get ref(): DocumentReference | undefined {\n    return this._ref;\n  }\n\n  /**\n   * @beta\n   * The ID of the document for which this PipelineResult contains data, if it is a document; otherwise `undefined`.\n   *\n   * @readonly\n   *\n   */\n  get id(): string | undefined {\n    return this._ref?.id;\n  }\n\n  /**\n   * @beta\n   * The time the document was created. Undefined if this result is not a document.\n   *\n   * @readonly\n   */\n  get createTime(): Timestamp | undefined {\n    return this._createTime;\n  }\n\n  /**\n   * @beta\n   * The time the document was last updated (at the time the snapshot was\n   * generated). Undefined if this result is not a document.\n   *\n   * @readonly\n   */\n  get updateTime(): Timestamp | undefined {\n    return this._updateTime;\n  }\n\n  /**\n   * @beta\n   * Retrieves all fields in the result as an object.\n   *\n   * @returns An object containing all fields in the document or\n   * 'undefined' if the document doesn't exist.\n   *\n   * @example\n   * ```\n   * let p = firestore.pipeline().collection('col');\n   *\n   * p.execute().then(results => {\n   *   let data = results[0].data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   * ```\n   */\n  data(): AppModelType {\n    return this._userDataWriter.convertValue(\n      this._fields.value\n    ) as AppModelType;\n  }\n\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the result as a proto value.\n   *\n   * @returns An `Object` containing all fields in the result.\n   */\n  _fieldsProto(): { [key: string]: firestoreV1ApiClientInterfaces.Value } {\n    // Return a cloned value to prevent manipulation of the Snapshot's data\n    return this._fields.clone().value.mapValue.fields!;\n  }\n\n  /**\n   * @beta\n   * Retrieves the field specified by `field`.\n   *\n   * @param field - The field path\n   * (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns The data at the specified field location or `undefined` if no\n   * such field exists.\n   *\n   * @example\n   * ```\n   * let p = firestore.pipeline().collection('col');\n   *\n   * p.execute().then(results => {\n   *   let field = results[0].get('a.b');\n   *   console.log(`Retrieved field value: ${field}`);\n   * });\n   * ```\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(fieldPath: string | FieldPath | Field): any {\n    if (this._fields === undefined) {\n      return undefined;\n    }\n    if (isField(fieldPath)) {\n      fieldPath = fieldPath.fieldName;\n    }\n\n    const value = this._fields.field(\n      fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n    );\n    if (value !== null) {\n      return this._userDataWriter.convertValue(value);\n    }\n  }\n}\n\n/**\n * @beta\n * Test equality of two PipelineResults.\n * @param left - First PipelineResult to compare.\n * @param right - Second PipelineResult to compare.\n */\nexport function pipelineResultEqual(\n  left: PipelineResult,\n  right: PipelineResult\n): boolean {\n  if (left === right) {\n    return true;\n  }\n\n  return (\n    isOptionalEqual(left._ref, right._ref, refEqual) &&\n    isOptionalEqual(left._fields, right._fields, (l, r) => l.isEqual(r))\n  );\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirestoreError, vector } from '../api';\nimport {\n  _constant,\n  AggregateFunction,\n  AliasedAggregate,\n  array,\n  constant,\n  Expression,\n  AliasedExpression,\n  field,\n  Field,\n  map,\n  Selectable\n} from '../lite-api/expressions';\nimport { VectorValue } from '../lite-api/vector_value';\n\nimport { fail } from './assert';\nimport { isPlainObject } from './input_validation';\nimport { isFirestoreValue } from './proto';\nimport { isString } from './types';\n\nexport function selectablesToMap(\n  selectables: Array<Selectable | string>\n): Map<string, Expression> {\n  const result = new Map<string, Expression>();\n  for (const selectable of selectables) {\n    let alias: string;\n    let expression: Expression;\n    if (typeof selectable === 'string') {\n      alias = selectable as string;\n      expression = field(selectable);\n    } else if (selectable instanceof Field) {\n      alias = selectable.alias;\n      expression = selectable.expr;\n    } else if (selectable instanceof AliasedExpression) {\n      alias = selectable.alias;\n      expression = selectable.expr;\n    } else {\n      fail(0x5319, '`selectable` has an unsupported type', { selectable });\n    }\n\n    if (result.get(alias) !== undefined) {\n      throw new FirestoreError(\n        'invalid-argument',\n        `Duplicate alias or field '${alias}'`\n      );\n    }\n\n    result.set(alias, expression);\n  }\n  return result;\n}\n\nexport function aliasedAggregateToMap(\n  aliasedAggregatees: AliasedAggregate[]\n): Map<string, AggregateFunction> {\n  return aliasedAggregatees.reduce(\n    (map: Map<string, AggregateFunction>, selectable: AliasedAggregate) => {\n      if (map.get(selectable.alias) !== undefined) {\n        throw new FirestoreError(\n          'invalid-argument',\n          `Duplicate alias or field '${selectable.alias}'`\n        );\n      }\n\n      map.set(selectable.alias, selectable.aggregate as AggregateFunction);\n      return map;\n    },\n    new Map() as Map<string, AggregateFunction>\n  );\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nexport function vectorToExpr(\n  value: VectorValue | number[] | Expression\n): Expression {\n  if (value instanceof Expression) {\n    return value;\n  } else if (value instanceof VectorValue) {\n    const result = constant(value);\n    return result;\n  } else if (Array.isArray(value)) {\n    const result = constant(vector(value));\n    return result;\n  } else {\n    throw new Error('Unsupported value: ' + typeof value);\n  }\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n * If the input is a string, it is assumed to be a field name, and a\n * field(value) is returned.\n *\n * @private\n * @internal\n * @param value\n */\nexport function fieldOrExpression(value: unknown): Expression {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return valueToDefaultExpr(value);\n  }\n}\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nexport function valueToDefaultExpr(value: unknown): Expression {\n  let result: Expression | undefined;\n  if (isFirestoreValue(value)) {\n    return constant(value);\n  }\n  if (value instanceof Expression) {\n    return value;\n  } else if (isPlainObject(value)) {\n    result = map(value as Record<string, unknown>);\n  } else if (value instanceof Array) {\n    result = array(value);\n  } else {\n    result = _constant(value, undefined);\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Pipeline as ProtoPipeline,\n  Stage as ProtoStage\n} from '../protos/firestore_proto_api';\nimport { JsonProtoSerializer, ProtoSerializable } from '../remote/serializer';\nimport { isPlainObject } from '../util/input_validation';\nimport {\n  aliasedAggregateToMap,\n  fieldOrExpression,\n  selectablesToMap,\n  vectorToExpr\n} from '../util/pipeline_util';\nimport { isNumber, isString } from '../util/types';\n\nimport { Firestore } from './database';\nimport {\n  _mapValue,\n  AggregateFunction,\n  AliasedAggregate,\n  BooleanExpression,\n  _constant,\n  Expression,\n  Field,\n  field,\n  Ordering,\n  Selectable,\n  _field,\n  isSelectable,\n  isField,\n  isBooleanExpr,\n  isAliasedAggregate,\n  toField,\n  isOrdering,\n  isExpr\n} from './expressions';\nimport {\n  AddFields,\n  Aggregate,\n  Distinct,\n  FindNearest,\n  RawStage,\n  Limit,\n  Offset,\n  RemoveFields,\n  Replace,\n  Sample,\n  Select,\n  Sort,\n  Stage,\n  Union,\n  Unnest,\n  Where\n} from './stage';\nimport {\n  AddFieldsStageOptions,\n  AggregateStageOptions,\n  DistinctStageOptions,\n  FindNearestStageOptions,\n  LimitStageOptions,\n  OffsetStageOptions,\n  RemoveFieldsStageOptions,\n  ReplaceWithStageOptions,\n  SampleStageOptions,\n  SelectStageOptions,\n  SortStageOptions,\n  StageOptions,\n  UnionStageOptions,\n  UnnestStageOptions,\n  WhereStageOptions\n} from './stage_options';\nimport { UserDataReader, UserDataSource } from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * @beta\n *\n * The Pipeline class provides a flexible and expressive framework for building complex data\n * transformation and query pipelines for Firestore.\n *\n * A pipeline takes data sources, such as Firestore collections or collection groups, and applies\n * a series of stages that are chained together. Each stage takes the output from the previous stage\n * (or the data source) and produces an output for the next stage (or as the final output of the\n * pipeline).\n *\n * Expressions can be used within each stage to filter and transform data through the stage.\n *\n * NOTE: The chained stages do not prescribe exactly how Firestore will execute the pipeline.\n * Instead, Firestore only guarantees that the result is the same as if the chained stages were\n * executed in order.\n *\n * Usage Examples:\n *\n * @example\n * ```typescript\n * const db: Firestore; // Assumes a valid firestore instance.\n *\n * // Example 1: Select specific fields and rename 'rating' to 'bookRating'\n * const results1 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .select(\"title\", \"author\", field(\"rating\").as(\"bookRating\")));\n *\n * // Example 2: Filter documents where 'genre' is \"Science Fiction\" and 'published' is after 1950\n * const results2 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .where(and(field(\"genre\").eq(\"Science Fiction\"), field(\"published\").gt(1950))));\n *\n * // Example 3: Calculate the average rating of books published after 1980\n * const results3 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .where(field(\"published\").gt(1980))\n *     .aggregate(avg(field(\"rating\")).as(\"averageRating\")));\n * ```\n */\nexport class Pipeline implements ProtoSerializable<ProtoPipeline> {\n  /**\n   * @internal\n   * @private\n   * @param _db\n   * @param userDataReader\n   * @param _userDataWriter\n   * @param stages\n   */\n  constructor(\n    /**\n     * @internal\n     * @private\n     */\n    public _db: Firestore,\n    /**\n     * @internal\n     * @private\n     */\n    private userDataReader: UserDataReader,\n    /**\n     * @internal\n     * @private\n     */\n    public _userDataWriter: AbstractUserDataWriter,\n    /**\n     * @internal\n     * @private\n     */\n    private stages: Stage[]\n  ) {}\n\n  /**\n   * @beta\n   * Adds new fields to outputs from previous stages.\n   *\n   * This stage allows you to compute values on-the-fly based on existing data from previous\n   * stages or constants. You can use this to create new fields or overwrite existing ones (if there\n   * is name overlaps).\n   *\n   * The added fields are defined using {@link @firebase/firestore/pipelines#Selectable}s, which can be:\n   *\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#Expression}: Either a literal value (see {@link @firebase/firestore/pipelines#(constant:1)}) or a computed value\n   *   with an assigned alias using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .addFields(\n   *     field(\"rating\").as(\"bookRating\"), // Rename 'rating' to 'bookRating'\n   *     add(5, field(\"quantity\")).as(\"totalCost\")  // Calculate 'totalCost'\n   *   );\n   * ```\n   *\n   * @param field - The first field to add to the documents, specified as a {@link @firebase/firestore/pipelines#Selectable}.\n   * @param additionalFields - Optional additional fields to add to the documents, specified as {@link @firebase/firestore/pipelines#Selectable}s.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  addFields(field: Selectable, ...additionalFields: Selectable[]): Pipeline;\n  /**\n   * @beta\n   * Adds new fields to outputs from previous stages.\n   *\n   * This stage allows you to compute values on-the-fly based on existing data from previous\n   * stages or constants. You can use this to create new fields or overwrite existing ones (if there\n   * is name overlaps).\n   *\n   * The added fields are defined using {@link @firebase/firestore/pipelines#Selectable}s, which can be:\n   *\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#Expression}: Either a literal value (see {@link @firebase/firestore/pipelines#(constant:1)}) or a computed value\n   *   with an assigned alias using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .addFields(\n   *     field(\"rating\").as(\"bookRating\"), // Rename 'rating' to 'bookRating'\n   *     add(5, field(\"quantity\")).as(\"totalCost\")  // Calculate 'totalCost'\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  addFields(options: AddFieldsStageOptions): Pipeline;\n  addFields(\n    fieldOrOptions: Selectable | AddFieldsStageOptions,\n    ...additionalFields: Selectable[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    let fields: Selectable[];\n    let options: {};\n    if (isSelectable(fieldOrOptions)) {\n      fields = [fieldOrOptions, ...additionalFields];\n      options = {};\n    } else {\n      ({ fields, ...options } = fieldOrOptions);\n    }\n\n    // Convert user land convenience types to internal types\n    const normalizedFields: Map<string, Expression> = selectablesToMap(fields);\n\n    // Create stage object\n    const stage = new AddFields(normalizedFields, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'addFields'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Remove fields from outputs of previous stages.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection('books')\n   *   // removes field 'rating' and 'cost' from the previous stage outputs.\n   *   .removeFields(\n   *     field('rating'),\n   *     'cost'\n   *   );\n   * ```\n   *\n   * @param fieldValue - The first field to remove.\n   * @param additionalFields - Optional additional fields to remove.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  removeFields(\n    fieldValue: Field | string,\n    ...additionalFields: Array<Field | string>\n  ): Pipeline;\n  /**\n   * @beta\n   * Remove fields from outputs of previous stages.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection('books')\n   *   // removes field 'rating' and 'cost' from the previous stage outputs.\n   *   .removeFields(\n   *     field('rating'),\n   *     'cost'\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  removeFields(options: RemoveFieldsStageOptions): Pipeline;\n  removeFields(\n    fieldValueOrOptions: Field | string | RemoveFieldsStageOptions,\n    ...additionalFields: Array<Field | string>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isField(fieldValueOrOptions) || isString(fieldValueOrOptions)\n        ? {}\n        : fieldValueOrOptions;\n    const fields: Array<Field | string> =\n      isField(fieldValueOrOptions) || isString(fieldValueOrOptions)\n        ? [fieldValueOrOptions, ...additionalFields]\n        : fieldValueOrOptions.fields;\n\n    // Convert user land convenience types to internal types\n    const convertedFields: Field[] = fields.map(f =>\n      isString(f) ? field(f) : (f as Field)\n    );\n\n    // Create stage object\n    const stage = new RemoveFields(convertedFields, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    stage._readUserData(\n      this.userDataReader.createContext(UserDataSource.Argument, 'removeFields')\n    );\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Selects or creates a set of fields from the outputs of previous stages.\n   *\n   * <p>The selected fields are defined using {@link @firebase/firestore/pipelines#Selectable} expressions, which can be:\n   *\n   * <ul>\n   *   <li>`string` : Name of an existing field</li>\n   *   <li>{@link @firebase/firestore/pipelines#Field}: References an existing field.</li>\n   *   <li>{@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name using\n   *       {@link @firebase/firestore/pipelines#Expression.(as:1)}</li>\n   * </ul>\n   *\n   * <p>If no selections are provided, the output of this stage is empty. Use {@link\n   * @firebase/firestore/pipelines#Pipeline.(addFields:1)} instead if only additions are\n   * desired.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * db.pipeline().collection(\"books\")\n   *   .select(\n   *     \"firstName\",\n   *     field(\"lastName\"),\n   *     field(\"address\").toUppercase().as(\"upperAddress\"),\n   *   );\n   * ```\n   *\n   * @param selection - The first field to include in the output documents, specified as {@link\n   *     @firebase/firestore/pipelines#Selectable} expression or string value representing the field name.\n   * @param additionalSelections - Optional additional fields to include in the output documents, specified as {@link\n   *     @firebase/firestore/pipelines#Selectable} expressions or `string` values representing field names.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  select(\n    selection: Selectable | string,\n    ...additionalSelections: Array<Selectable | string>\n  ): Pipeline;\n  /**\n   * @beta\n   * Selects or creates a set of fields from the outputs of previous stages.\n   *\n   * <p>The selected fields are defined using {@link @firebase/firestore/pipelines#Selectable} expressions, which can be:\n   *\n   * <ul>\n   *   <li>`string`: Name of an existing field</li>\n   *   <li>{@link @firebase/firestore/pipelines#Field}: References an existing field.</li>\n   *   <li>{@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name using\n   *       {@link @firebase/firestore/pipelines#Expression.(as:1)}</li>\n   * </ul>\n   *\n   * <p>If no selections are provided, the output of this stage is empty. Use {@link\n   * @firebase/firestore/pipelines#Pipeline.(addFields:1)} instead if only additions are\n   * desired.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * db.pipeline().collection(\"books\")\n   *   .select(\n   *     \"firstName\",\n   *     field(\"lastName\"),\n   *     field(\"address\").toUppercase().as(\"upperAddress\"),\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  select(options: SelectStageOptions): Pipeline;\n  select(\n    selectionOrOptions: Selectable | string | SelectStageOptions,\n    ...additionalSelections: Array<Selectable | string>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isSelectable(selectionOrOptions) || isString(selectionOrOptions)\n        ? {}\n        : selectionOrOptions;\n\n    const selections: Array<Selectable | string> =\n      isSelectable(selectionOrOptions) || isString(selectionOrOptions)\n        ? [selectionOrOptions, ...additionalSelections]\n        : selectionOrOptions.selections;\n\n    // Convert user land convenience types to internal types\n    const normalizedSelections: Map<string, Expression> =\n      selectablesToMap(selections);\n\n    // Create stage object\n    const stage = new Select(normalizedSelections, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'select'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Filters the documents from previous stages to only include those matching the specified {@link\n   * @firebase/firestore/pipelines#BooleanExpression}.\n   *\n   * <p>This stage allows you to apply conditions to the data, similar to a \"WHERE\" clause in SQL.\n   * You can filter documents based on their field values, using implementations of {@link\n   * @firebase/firestore/pipelines#BooleanExpression}, typically including but not limited to:\n   *\n   * <ul>\n   *   <li>field comparators: {@link @firebase/firestore/pipelines#Expression.(equal:1)}, {@link @firebase/firestore/pipelines#Expression.(lessThan:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(greaterThan:1)}, etc.</li>\n   *   <li>logical operators: {@link @firebase/firestore/pipelines#Expression.(and:1)}, {@link @firebase/firestore/pipelines#Expression.(or:1)}, {@link @firebase/firestore/pipelines#Expression.(not:1)}, etc.</li>\n   *   <li>advanced functions: {@link @firebase/firestore/pipelines#Expression.(regexMatch:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(arrayContains:1)}, etc.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .where(\n   *     and(\n   *         gt(field(\"rating\"), 4.0),   // Filter for ratings greater than 4.0\n   *         field(\"genre\").eq(\"Science Fiction\") // Equivalent to gt(\"genre\", \"Science Fiction\")\n   *     )\n   *   );\n   * ```\n   *\n   * @param condition - The {@link @firebase/firestore/pipelines#BooleanExpression} to apply.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  where(condition: BooleanExpression): Pipeline;\n  /**\n   * @beta\n   * Filters the documents from previous stages to only include those matching the specified {@link\n   * @firebase/firestore/pipelines#BooleanExpression}.\n   *\n   * <p>This stage allows you to apply conditions to the data, similar to a \"WHERE\" clause in SQL.\n   * You can filter documents based on their field values, using implementations of {@link\n   * @firebase/firestore/pipelines#BooleanExpression}, typically including but not limited to:\n   *\n   * <ul>\n   *   <li>field comparators: {@link @firebase/firestore/pipelines#Expression.(eq:1)}, {@link @firebase/firestore/pipelines#Expression.(lt:1)} (less than), {@link\n   *       @firebase/firestore/pipelines#Expression.(greaterThan:1)}, etc.</li>\n   *   <li>logical operators: {@link @firebase/firestore/pipelines#Expression.(and:1)}, {@link @firebase/firestore/pipelines#Expression.(or:1)}, {@link @firebase/firestore/pipelines#Expression.(not:1)}, etc.</li>\n   *   <li>advanced functions: {@link @firebase/firestore/pipelines#Expression.(regexMatch:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(arrayContains:1)}, etc.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .where(\n   *     and(\n   *         gt(field(\"rating\"), 4.0),   // Filter for ratings greater than 4.0\n   *         field(\"genre\").eq(\"Science Fiction\") // Equivalent to gt(\"genre\", \"Science Fiction\")\n   *     )\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  where(options: WhereStageOptions): Pipeline;\n  where(conditionOrOptions: BooleanExpression | WhereStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isBooleanExpr(conditionOrOptions) ? {} : conditionOrOptions;\n    const condition: BooleanExpression = isBooleanExpr(conditionOrOptions)\n      ? conditionOrOptions\n      : conditionOrOptions.condition;\n\n    // Create stage object\n    const stage = new Where(condition, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'where'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Skips the first `offset` number of documents from the results of previous stages.\n   *\n   * <p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve\n   * results in chunks. It is typically used in conjunction with {@link @firebase/firestore/pipelines#Pipeline.limit} to control the\n   * size of each page.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page of 20 results\n   * firestore.pipeline().collection('books')\n   *     .sort(field('published').descending())\n   *     .offset(20)  // Skip the first 20 results\n   *     .limit(20);   // Take the next 20 results\n   * ```\n   *\n   * @param offset - The number of documents to skip.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  offset(offset: number): Pipeline;\n  /**\n   * @beta\n   * Skips the first `offset` number of documents from the results of previous stages.\n   *\n   * <p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve\n   * results in chunks. It is typically used in conjunction with {@link @firebase/firestore/pipelines#Pipeline.limit} to control the\n   * size of each page.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page of 20 results\n   * firestore.pipeline().collection('books')\n   *     .sort(field('published').descending())\n   *     .offset(20)  // Skip the first 20 results\n   *     .limit(20);   // Take the next 20 results\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  offset(options: OffsetStageOptions): Pipeline;\n  offset(offsetOrOptions: number | OffsetStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let offset: number;\n    if (isNumber(offsetOrOptions)) {\n      options = {};\n      offset = offsetOrOptions;\n    } else {\n      options = offsetOrOptions;\n      offset = offsetOrOptions.offset;\n    }\n\n    // Create stage object\n    const stage = new Offset(offset, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'offset'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Limits the maximum number of documents returned by previous stages to `limit`.\n   *\n   * <p>This stage is particularly useful when you want to retrieve a controlled subset of data from\n   * a potentially large result set. It's often used for:\n   *\n   * <ul>\n   *   <li>**Pagination:** In combination with {@link @firebase/firestore/pipelines#Pipeline.offset} to retrieve specific pages of\n   *       results.</li>\n   *   <li>**Limiting Data Retrieval:** To prevent excessive data transfer and improve performance,\n   *       especially when dealing with large collections.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Limit the results to the top 10 highest-rated books\n   * firestore.pipeline().collection('books')\n   *     .sort(field('rating').descending())\n   *     .limit(10);\n   * ```\n   *\n   * @param limit - The maximum number of documents to return.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  limit(limit: number): Pipeline;\n  /**\n   * @beta\n   * Limits the maximum number of documents returned by previous stages to `limit`.\n   *\n   * <p>This stage is particularly useful when you want to retrieve a controlled subset of data from\n   * a potentially large result set. It's often used for:\n   *\n   * <ul>\n   *   <li>**Pagination:** In combination with {@link @firebase/firestore/pipelines#Pipeline.offset} to retrieve specific pages of\n   *       results.</li>\n   *   <li>**Limiting Data Retrieval:** To prevent excessive data transfer and improve performance,\n   *       especially when dealing with large collections.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Limit the results to the top 10 highest-rated books\n   * firestore.pipeline().collection('books')\n   *     .sort(field('rating').descending())\n   *     .limit(10);\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  limit(options: LimitStageOptions): Pipeline;\n  limit(limitOrOptions: number | LimitStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isNumber(limitOrOptions) ? {} : limitOrOptions;\n    const limit: number = isNumber(limitOrOptions)\n      ? limitOrOptions\n      : limitOrOptions.limit;\n\n    // Create stage object\n    const stage = new Limit(limit, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'limit'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Returns a set of distinct values from the inputs to this stage.\n   *\n   * This stage runs through the results from previous stages to include only results with\n   * unique combinations of {@link @firebase/firestore/pipelines#Expression} values ({@link @firebase/firestore/pipelines#Field}, {@link @firebase/firestore/pipelines#AliasedExpression}, etc).\n   *\n   * The parameters to this stage are defined using {@link @firebase/firestore/pipelines#Selectable} expressions or strings:\n   *\n   * - `string`: Name of an existing field\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name\n   *   using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Get a list of unique author names in uppercase and genre combinations.\n   * firestore.pipeline().collection(\"books\")\n   *     .distinct(toUppercase(field(\"author\")).as(\"authorName\"), field(\"genre\"), \"publishedAt\")\n   *     .select(\"authorName\");\n   * ```\n   *\n   * @param group - The {@link @firebase/firestore/pipelines#Selectable} expression or field name to consider when determining\n   *     distinct value combinations.\n   * @param additionalGroups - Optional additional {@link @firebase/firestore/pipelines#Selectable} expressions to consider when determining distinct\n   *     value combinations or strings representing field names.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  distinct(\n    group: string | Selectable,\n    ...additionalGroups: Array<string | Selectable>\n  ): Pipeline;\n  /**\n   * @beta\n   * Returns a set of distinct values from the inputs to this stage.\n   *\n   * This stage runs through the results from previous stages to include only results with\n   * unique combinations of {@link @firebase/firestore/pipelines#Expression} values ({@link @firebase/firestore/pipelines#Field}, {@link @firebase/firestore/pipelines#AliasedExpression}, etc).\n   *\n   * The parameters to this stage are defined using {@link @firebase/firestore/pipelines#Selectable} expressions or strings:\n   *\n   * - `string`: Name of an existing field\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name\n   *   using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Get a list of unique author names in uppercase and genre combinations.\n   * firestore.pipeline().collection(\"books\")\n   *     .distinct(toUppercase(field(\"author\")).as(\"authorName\"), field(\"genre\"), \"publishedAt\")\n   *     .select(\"authorName\");\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  distinct(options: DistinctStageOptions): Pipeline;\n  distinct(\n    groupOrOptions: string | Selectable | DistinctStageOptions,\n    ...additionalGroups: Array<string | Selectable>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(groupOrOptions) || isSelectable(groupOrOptions)\n        ? {}\n        : groupOrOptions;\n    const groups: Array<string | Selectable> =\n      isString(groupOrOptions) || isSelectable(groupOrOptions)\n        ? [groupOrOptions, ...additionalGroups]\n        : groupOrOptions.groups;\n\n    // Convert user land convenience types to internal types\n    const convertedGroups: Map<string, Expression> = selectablesToMap(groups);\n\n    // Create stage object\n    const stage = new Distinct(convertedGroups, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'distinct'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs aggregation operations on the documents from previous stages.\n   *\n   * <p>This stage allows you to calculate aggregate values over a set of documents. You define the\n   * aggregations to perform using {@link @firebase/firestore/pipelines#AliasedAggregate} expressions which are typically results of\n   * calling {@link @firebase/firestore/pipelines#Expression.(as:1)} on {@link @firebase/firestore/pipelines#AggregateFunction} instances.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average rating and the total number of books\n   * firestore.pipeline().collection(\"books\")\n   *     .aggregate(\n   *         field(\"rating\").avg().as(\"averageRating\"),\n   *         countAll().as(\"totalBooks\")\n   *     );\n   * ```\n   *\n   * @param accumulator - The first {@link @firebase/firestore/pipelines#AliasedAggregate}, wrapping an {@link @firebase/firestore/pipelines#AggregateFunction}\n   *     and providing a name for the accumulated results.\n   * @param additionalAccumulators - Optional additional {@link @firebase/firestore/pipelines#AliasedAggregate}, each wrapping an {@link @firebase/firestore/pipelines#AggregateFunction}\n   *     and providing a name for the accumulated results.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  aggregate(\n    accumulator: AliasedAggregate,\n    ...additionalAccumulators: AliasedAggregate[]\n  ): Pipeline;\n  /**\n   * @beta\n   * Performs optionally grouped aggregation operations on the documents from previous stages.\n   *\n   * <p>This stage allows you to calculate aggregate values over a set of documents, optionally\n   * grouped by one or more fields or functions. You can specify:\n   *\n   * <ul>\n   *   <li>**Grouping Fields or Functions:** One or more fields or functions to group the documents\n   *       by. For each distinct combination of values in these fields, a separate group is created.\n   *       If no grouping fields are provided, a single group containing all documents is used. Not\n   *       specifying groups is the same as putting the entire inputs into one group.</li>\n   *   <li>**Accumulators:** One or more accumulation operations to perform within each group. These\n   *       are defined using {@link @firebase/firestore/pipelines#AliasedAggregate} expressions, which are typically created by\n   *       calling {@link @firebase/firestore/pipelines#Expression.(as:1)} on {@link @firebase/firestore/pipelines#AggregateFunction} instances. Each aggregation\n   *       calculates a value (e.g., sum, average, count) based on the documents within its group.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average rating for each genre.\n   * firestore.pipeline().collection(\"books\")\n   *   .aggregate({\n   *       accumulators: [avg(field(\"rating\")).as(\"avg_rating\")]\n   *       groups: [\"genre\"]\n   *       });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage\n   * list.\n   */\n  aggregate(options: AggregateStageOptions): Pipeline;\n  aggregate(\n    targetOrOptions: AliasedAggregate | AggregateStageOptions,\n    ...rest: AliasedAggregate[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isAliasedAggregate(targetOrOptions) ? {} : targetOrOptions;\n    const accumulators: AliasedAggregate[] = isAliasedAggregate(targetOrOptions)\n      ? [targetOrOptions, ...rest]\n      : targetOrOptions.accumulators;\n    const groups: Array<Selectable | string> = isAliasedAggregate(\n      targetOrOptions\n    )\n      ? []\n      : targetOrOptions.groups ?? [];\n\n    // Convert user land convenience types to internal types\n    const convertedAccumulators: Map<string, AggregateFunction> =\n      aliasedAggregateToMap(accumulators);\n    const convertedGroups: Map<string, Expression> = selectablesToMap(groups);\n\n    // Create stage object\n    const stage = new Aggregate(\n      convertedGroups,\n      convertedAccumulators,\n      options\n    );\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'aggregate'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs a vector proximity search on the documents from the previous stage, returning the\n   * K-nearest documents based on the specified query `vectorValue` and `distanceMeasure`. The\n   * returned documents will be sorted in order from nearest to furthest from the query `vectorValue`.\n   *\n   * <p>Example:\n   *\n   * ```typescript\n   * // Find the 10 most similar books based on the book description.\n   * const bookDescription = \"Lorem ipsum...\";\n   * const queryVector: number[] = ...; // compute embedding of `bookDescription`\n   *\n   * firestore.pipeline().collection(\"books\")\n   *     .findNearest({\n   *       field: 'embedding',\n   *       vectorValue: queryVector,\n   *       distanceMeasure: 'euclidean',\n   *       limit: 10,                        // optional\n   *       distanceField: 'computedDistance' // optional\n   *     });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  findNearest(options: FindNearestStageOptions): Pipeline {\n    // Convert user land convenience types to internal types\n    const field = toField(options.field);\n    const vectorValue = vectorToExpr(options.vectorValue);\n    const distanceField = options.distanceField\n      ? toField(options.distanceField)\n      : undefined;\n    const internalOptions = {\n      distanceField,\n      limit: options.limit,\n      rawOptions: options.rawOptions\n    };\n\n    // Create stage object\n    const stage = new FindNearest(\n      vectorValue,\n      field,\n      options.distanceMeasure,\n      internalOptions\n    );\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'addFields'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Sorts the documents from previous stages based on one or more {@link @firebase/firestore/pipelines#Ordering} criteria.\n   *\n   * <p>This stage allows you to order the results of your pipeline. You can specify multiple {@link\n   * @firebase/firestore/pipelines#Ordering} instances to sort by multiple fields in ascending or descending order. If documents\n   * have the same value for a field used for sorting, the next specified ordering will be used. If\n   * all orderings result in equal comparison, the documents are considered equal and the order is\n   * unspecified.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Sort books by rating in descending order, and then by title in ascending order for books\n   * // with the same rating\n   * firestore.pipeline().collection(\"books\")\n   *     .sort(\n   *         Ordering.of(field(\"rating\")).descending(),\n   *         Ordering.of(field(\"title\"))  // Ascending order is the default\n   *     );\n   * ```\n   *\n   * @param ordering - The first {@link @firebase/firestore/pipelines#Ordering} instance specifying the sorting criteria.\n   * @param additionalOrderings - Optional additional {@link @firebase/firestore/pipelines#Ordering} instances specifying the additional sorting criteria.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sort(ordering: Ordering, ...additionalOrderings: Ordering[]): Pipeline;\n  /**\n   * @beta\n   * Sorts the documents from previous stages based on one or more {@link @firebase/firestore/pipelines#Ordering} criteria.\n   *\n   * <p>This stage allows you to order the results of your pipeline. You can specify multiple {@link\n   * @firebase/firestore/pipelines#Ordering} instances to sort by multiple fields in ascending or descending order. If documents\n   * have the same value for a field used for sorting, the next specified ordering will be used. If\n   * all orderings result in equal comparison, the documents are considered equal and the order is\n   * unspecified.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Sort books by rating in descending order, and then by title in ascending order for books\n   * // with the same rating\n   * firestore.pipeline().collection(\"books\")\n   *     .sort(\n   *         Ordering.of(field(\"rating\")).descending(),\n   *         Ordering.of(field(\"title\"))  // Ascending order is the default\n   *     );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sort(options: SortStageOptions): Pipeline;\n  sort(\n    orderingOrOptions: Ordering | SortStageOptions,\n    ...additionalOrderings: Ordering[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isOrdering(orderingOrOptions) ? {} : orderingOrOptions;\n    const orderings: Ordering[] = isOrdering(orderingOrOptions)\n      ? [orderingOrOptions, ...additionalOrderings]\n      : orderingOrOptions.orderings;\n\n    // Create stage object\n    const stage = new Sort(orderings, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'sort'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a nested map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith('parents');\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param fieldName - The {@link @firebase/firestore/pipelines#Field} field containing the nested map.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(fieldName: string): Pipeline;\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith(map({\n   *   foo: 'bar',\n   *   info: {\n   *     name: field('name')\n   *   }\n   * }));\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param expr - An {@link @firebase/firestore/pipelines#Expression} that when returned evaluates to a map.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(expr: Expression): Pipeline;\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith(map({\n   *   foo: 'bar',\n   *   info: {\n   *     name: field('name')\n   *   }\n   * }));\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(options: ReplaceWithStageOptions): Pipeline;\n  replaceWith(\n    valueOrOptions: Expression | string | ReplaceWithStageOptions\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(valueOrOptions) || isExpr(valueOrOptions) ? {} : valueOrOptions;\n    const fieldNameOrExpr: string | Expression =\n      isString(valueOrOptions) || isExpr(valueOrOptions)\n        ? valueOrOptions\n        : valueOrOptions.map;\n\n    // Convert user land convenience types to internal types\n    const mapExpr = fieldOrExpression(fieldNameOrExpr);\n\n    // Create stage object\n    const stage = new Replace(mapExpr, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'replaceWith'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs a pseudo-random sampling of the documents from the previous stage.\n   *\n   * <p>This stage will filter documents pseudo-randomly. The parameter specifies how number of\n   * documents to be returned.\n   *\n   * <p>Examples:\n   *\n   * @example\n   * ```typescript\n   * // Sample 25 books, if available.\n   * firestore.pipeline().collection('books')\n   *     .sample(25);\n   * ```\n   *\n   * @param documents - The number of documents to sample.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sample(documents: number): Pipeline;\n\n  /**\n   * @beta\n   * Performs a pseudo-random sampling of the documents from the previous stage.\n   *\n   * <p>This stage will filter documents pseudo-randomly. The 'options' parameter specifies how\n   * sampling will be performed. See {@link @firebase/firestore/pipelines#SampleStageOptions} for more information.\n   *\n   * @example\n   * ```typescript\n   * // Sample 10 books, if available.\n   * firestore.pipeline().collection(\"books\")\n   *     .sample({ documents: 10 });\n   *\n   * // Sample 50% of books.\n   * firestore.pipeline().collection(\"books\")\n   *     .sample({ percentage: 0.5 });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sample(options: SampleStageOptions): Pipeline;\n  sample(documentsOrOptions: number | SampleStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isNumber(documentsOrOptions) ? {} : documentsOrOptions;\n    let rate: number;\n    let mode: 'documents' | 'percent';\n    if (isNumber(documentsOrOptions)) {\n      rate = documentsOrOptions;\n      mode = 'documents';\n    } else if (isNumber(documentsOrOptions.documents)) {\n      rate = documentsOrOptions.documents;\n      mode = 'documents';\n    } else {\n      rate = documentsOrOptions.percentage!;\n      mode = 'percent';\n    }\n\n    // Create stage object\n    const stage = new Sample(rate, mode, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'sample'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs union of all documents from two pipelines, including duplicates.\n   *\n   * <p>This stage will pass through documents from previous stage, and also pass through documents\n   * from previous stage of the `other` {@link @firebase/firestore/pipelines#Pipeline} given in parameter. The order of documents\n   * emitted from this stage is undefined.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Emit documents from books collection and magazines collection.\n   * firestore.pipeline().collection('books')\n   *     .union(firestore.pipeline().collection('magazines'));\n   * ```\n   *\n   * @param other - The other {@link @firebase/firestore/pipelines#Pipeline} that is part of union.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  union(other: Pipeline): Pipeline;\n  /**\n   * @beta\n   * Performs union of all documents from two pipelines, including duplicates.\n   *\n   * <p>This stage will pass through documents from previous stage, and also pass through documents\n   * from previous stage of the `other` {@link @firebase/firestore/pipelines#Pipeline} given in parameter. The order of documents\n   * emitted from this stage is undefined.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Emit documents from books collection and magazines collection.\n   * firestore.pipeline().collection('books')\n   *     .union(firestore.pipeline().collection('magazines'));\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  union(options: UnionStageOptions): Pipeline;\n  union(otherOrOptions: Pipeline | UnionStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let otherPipeline: Pipeline;\n    if (isPipeline(otherOrOptions)) {\n      options = {};\n      otherPipeline = otherOrOptions;\n    } else {\n      ({ other: otherPipeline, ...options } = otherOrOptions);\n    }\n\n    // Create stage object\n    const stage = new Union(otherPipeline, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'union'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Produces a document for each element in an input array.\n   *\n   * For each previous stage document, this stage will emit zero or more augmented documents. The\n   * input array specified by the `selectable` parameter, will emit an augmented document for each input array element. The input array element will\n   * augment the previous stage document by setting the `alias` field  with the array element value.\n   *\n   * When `selectable` evaluates to a non-array value (ex: number, null, absent), then the stage becomes a no-op for\n   * the current input document, returning it as is with the `alias` field absent.\n   *\n   * No documents are emitted when `selectable` evaluates to an empty array.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Input:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tags\": [ \"comedy\", \"space\", \"adventure\" ], ... }\n   *\n   * // Emit a book document for each tag of the book.\n   * firestore.pipeline().collection(\"books\")\n   *     .unnest(field(\"tags\").as('tag'), 'tagIndex');\n   *\n   * // Output:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"comedy\", \"tagIndex\": 0, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"space\", \"tagIndex\": 1, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"adventure\", \"tagIndex\": 2, ... }\n   * ```\n   *\n   * @param selectable - A selectable expression defining the field to unnest and the alias to use for each un-nested element in the output documents.\n   * @param indexField - An optional string value specifying the field path to write the offset (starting at zero) into the array the un-nested element is from\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  unnest(selectable: Selectable, indexField?: string): Pipeline;\n  /**\n   * @beta\n   * Produces a document for each element in an input array.\n   *\n   * For each previous stage document, this stage will emit zero or more augmented documents. The\n   * input array specified by the `selectable` parameter, will emit an augmented document for each input array element. The input array element will\n   * augment the previous stage document by setting the `alias` field  with the array element value.\n   *\n   * When `selectable` evaluates to a non-array value (ex: number, null, absent), then the stage becomes a no-op for\n   * the current input document, returning it as is with the `alias` field absent.\n   *\n   * No documents are emitted when `selectable` evaluates to an empty array.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Input:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tags\": [ \"comedy\", \"space\", \"adventure\" ], ... }\n   *\n   * // Emit a book document for each tag of the book.\n   * firestore.pipeline().collection(\"books\")\n   *     .unnest(field(\"tags\").as('tag'), 'tagIndex');\n   *\n   * // Output:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"comedy\", \"tagIndex\": 0, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"space\", \"tagIndex\": 1, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"adventure\", \"tagIndex\": 2, ... }\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  unnest(options: UnnestStageOptions): Pipeline;\n  unnest(\n    selectableOrOptions: Selectable | UnnestStageOptions,\n    indexField?: string\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: { indexField?: Field } & StageOptions;\n    let selectable: Selectable;\n    let indexFieldName: string | undefined;\n    if (isSelectable(selectableOrOptions)) {\n      options = {};\n      selectable = selectableOrOptions;\n      indexFieldName = indexField;\n    } else {\n      ({\n        selectable,\n        indexField: indexFieldName,\n        ...options\n      } = selectableOrOptions);\n    }\n\n    // Convert user land convenience types to internal types\n    const alias = selectable.alias;\n    const expr = selectable.expr as Expression;\n    if (isString(indexFieldName)) {\n      options.indexField = _field(indexFieldName, 'unnest');\n    }\n\n    // Create stage object\n    const stage = new Unnest(alias, expr, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'unnest'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Adds a raw stage to the pipeline.\n   *\n   * <p>This method provides a flexible way to extend the pipeline's functionality by adding custom\n   * stages. Each raw stage is defined by a unique `name` and a set of `params` that control its\n   * behavior.\n   *\n   * <p>Example (Assuming there is no 'where' stage available in SDK):\n   *\n   * @example\n   * ```typescript\n   * // Assume we don't have a built-in 'where' stage\n   * firestore.pipeline().collection('books')\n   *     .rawStage('where', [field('published').lt(1900)]) // Custom 'where' stage\n   *     .select('title', 'author');\n   * ```\n   *\n   * @param name - The unique name of the raw stage to add.\n   * @param params - A list of parameters to configure the raw stage's behavior.\n   * @param options - An object of key value pairs that specifies optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  rawStage(\n    name: string,\n    params: unknown[],\n    options?: { [key: string]: Expression | unknown }\n  ): Pipeline {\n    // Convert user land convenience types to internal types\n    const expressionParams = params.map((value: unknown) => {\n      if (value instanceof Expression) {\n        return value;\n      } else if (value instanceof AggregateFunction) {\n        return value;\n      } else if (isPlainObject(value)) {\n        return _mapValue(value as Record<string, unknown>);\n      } else {\n        return _constant(value, 'rawStage');\n      }\n    });\n\n    // Create stage object\n    const stage = new RawStage(name, expressionParams, options ?? {});\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'rawStage'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(jsonProtoSerializer: JsonProtoSerializer): ProtoPipeline {\n    const stages: ProtoStage[] = this.stages.map(stage =>\n      stage._toProto(jsonProtoSerializer)\n    );\n    return { stages };\n  }\n\n  private _addStage(stage: Stage): Pipeline {\n    const copy = this.stages.map(s => s);\n    copy.push(stage);\n    return this.newPipeline(\n      this._db,\n      this.userDataReader,\n      this._userDataWriter,\n      copy\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   * @param db\n   * @param userDataReader\n   * @param userDataWriter\n   * @param stages\n   * @protected\n   */\n  protected newPipeline(\n    db: Firestore,\n    userDataReader: UserDataReader,\n    userDataWriter: AbstractUserDataWriter,\n    stages: Stage[]\n  ): Pipeline {\n    return new Pipeline(db, userDataReader, userDataWriter, stages);\n  }\n}\n\nexport function isPipeline(val: unknown): val is Pipeline {\n  return val instanceof Pipeline;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  StructuredPipeline,\n  StructuredPipelineOptions\n} from '../core/structured_pipeline';\nimport { invokeExecutePipeline } from '../remote/datastore';\n\nimport { getDatastore } from './components';\nimport { Firestore } from './database';\nimport { Pipeline } from './pipeline';\nimport { PipelineResult, PipelineSnapshot } from './pipeline-result';\nimport { PipelineSource } from './pipeline-source';\nimport { DocumentReference } from './reference';\nimport { LiteUserDataWriter } from './reference_impl';\nimport { Stage } from './stage';\nimport {\n  newUserDataReader,\n  UserDataReader,\n  UserDataSource\n} from './user_data_reader';\n\ndeclare module './database' {\n  interface Firestore {\n    /**\n     * @beta\n     * Creates and returns a new PipelineSource, which allows specifying the source stage of a {@link @firebase/firestore/pipelines#Pipeline}.\n     *\n     * @example\n     * ```\n     * let myPipeline: Pipeline = firestore.pipeline().collection('books');\n     * ```\n     */\n    pipeline(): PipelineSource<Pipeline>;\n  }\n}\n\n/**\n * @beta\n * Executes this pipeline and returns a Promise to represent the asynchronous operation.\n *\n * The returned Promise can be used to track the progress of the pipeline execution\n * and retrieve the results (or handle any errors) asynchronously.\n *\n * The pipeline results are returned as a {@link @firebase/firestore/pipelines#PipelineSnapshot} that contains\n * a list of {@link @firebase/firestore/pipelines#PipelineResult} objects. Each {@link @firebase/firestore/pipelines#PipelineResult} typically\n * represents a single key/value map that has passed through all the\n * stages of the pipeline, however this might differ depending on the stages involved in the\n * pipeline. For example:\n *\n * <ul>\n *   <li>If there are no stages or only transformation stages, each {@link @firebase/firestore/pipelines#PipelineResult}\n *       represents a single document.</li>\n *   <li>If there is an aggregation, only a single {@link @firebase/firestore/pipelines#PipelineResult} is returned,\n *       representing the aggregated results over the entire dataset .</li>\n *   <li>If there is an aggregation stage with grouping, each {@link @firebase/firestore/pipelines#PipelineResult} represents a\n *       distinct group and its associated aggregated values.</li>\n * </ul>\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await execute(firestore.pipeline().collection(\"books\")\n *     .where(gt(field(\"rating\"), 4.5))\n *     .select(\"title\", \"author\", \"rating\"));\n *\n * const results: PipelineResults = snapshot.results;\n * ```\n *\n * @param pipeline - The pipeline to execute.\n * @returns A Promise representing the asynchronous pipeline execution.\n */\nexport function execute(pipeline: Pipeline): Promise<PipelineSnapshot> {\n  const datastore = getDatastore(pipeline._db);\n\n  const udr = new UserDataReader(\n    pipeline._db._databaseId,\n    /* ignoreUndefinedProperties */ true\n  );\n  const context = udr.createContext(UserDataSource.Argument, 'execute');\n\n  const structuredPipelineOptions = new StructuredPipelineOptions({}, {});\n  structuredPipelineOptions._readUserData(context);\n\n  const structuredPipeline: StructuredPipeline = new StructuredPipeline(\n    pipeline,\n    structuredPipelineOptions\n  );\n\n  return invokeExecutePipeline(datastore, structuredPipeline).then(result => {\n    // Get the execution time from the first result.\n    // firestoreClientExecutePipeline returns at least one PipelineStreamElement\n    // even if the returned document set is empty.\n    const executionTime =\n      result.length > 0 ? result[0].executionTime?.toTimestamp() : undefined;\n\n    const docs = result\n      // Currently ignore any response from ExecutePipeline that does\n      // not contain any document data in the `fields` property.\n      .filter(element => !!element.fields)\n      .map(\n        element =>\n          new PipelineResult(\n            pipeline._userDataWriter,\n            element.fields!,\n            element.key?.path\n              ? new DocumentReference(pipeline._db, null, element.key)\n              : undefined,\n            element.createTime?.toTimestamp(),\n            element.updateTime?.toTimestamp()\n          )\n      );\n\n    return new PipelineSnapshot(pipeline, docs, executionTime);\n  });\n}\n\n/**\n * @beta\n * Creates and returns a new PipelineSource, which allows specifying the source stage of a {@link @firebase/firestore/pipelines#Pipeline}.\n *\n * @example\n * ```\n * let myPipeline: Pipeline = firestore.pipeline().collection('books');\n * ```\n */\nFirestore.prototype.pipeline = function (): PipelineSource<Pipeline> {\n  const userDataWriter = new LiteUserDataWriter(this);\n  const userDataReader = newUserDataReader(this);\n  return new PipelineSource<Pipeline>(\n    this._databaseId,\n    userDataReader,\n    (stages: Stage[]) => {\n      return new Pipeline(this, userDataReader, userDataWriter, stages);\n    }\n  );\n};\n"],"names":["valueToDefaultExpr","vectorToExpr","fieldOrExpression","documentIdFieldPath","FieldFilterInternal","CompositeFilterInternal"],"mappings":"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"}