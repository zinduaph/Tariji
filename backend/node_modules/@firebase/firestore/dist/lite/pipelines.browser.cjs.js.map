{"version":3,"file":"pipelines.browser.cjs.js","sources":["../../src/core/options_util.ts","../../src/core/structured_pipeline.ts","../../src/util/proto.ts","../../src/lite-api/expressions.ts","../../src/core/pipeline-util.ts","../../src/lite-api/stage.ts","../../src/lite-api/pipeline-source.ts","../../src/lite-api/pipeline-result.ts","../../src/util/pipeline_util.ts","../../src/lite-api/pipeline.ts","../../src/lite-api/pipeline_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParseContext } from '../api/parse_context';\nimport { parseData } from '../lite-api/user_data_reader';\nimport { ObjectValue } from '../model/object_value';\nimport { FieldPath } from '../model/path';\nimport { ApiClientObjectMap, Value } from '../protos/firestore_proto_api';\nimport { isPlainObject } from '../util/input_validation';\nimport { mapToArray } from '../util/obj';\nexport type OptionsDefinitions = Record<string, OptionDefinition>;\nexport interface OptionDefinition {\n  serverName: string;\n  nestedOptions?: OptionsDefinitions;\n}\n\nexport class OptionsUtil {\n  constructor(private optionDefinitions: OptionsDefinitions) {}\n\n  private _getKnownOptions(\n    options: Record<string, unknown>,\n    context: ParseContext\n  ): ObjectValue {\n    const knownOptions: ObjectValue = ObjectValue.empty();\n\n    // SERIALIZE KNOWN OPTIONS\n    for (const knownOptionKey in this.optionDefinitions) {\n      if (this.optionDefinitions.hasOwnProperty(knownOptionKey)) {\n        const optionDefinition: OptionDefinition =\n          this.optionDefinitions[knownOptionKey];\n\n        if (knownOptionKey in options) {\n          const optionValue: unknown = options[knownOptionKey];\n          let protoValue: Value | undefined = undefined;\n\n          if (optionDefinition.nestedOptions && isPlainObject(optionValue)) {\n            const nestedUtil = new OptionsUtil(optionDefinition.nestedOptions);\n            protoValue = {\n              mapValue: {\n                fields: nestedUtil.getOptionsProto(context, optionValue)\n              }\n            };\n          } else if (optionValue) {\n            protoValue = parseData(optionValue, context) ?? undefined;\n          }\n\n          if (protoValue) {\n            knownOptions.set(\n              FieldPath.fromServerFormat(optionDefinition.serverName),\n              protoValue\n            );\n          }\n        }\n      }\n    }\n\n    return knownOptions;\n  }\n\n  getOptionsProto(\n    context: ParseContext,\n    knownOptions: Record<string, unknown>,\n    optionsOverride?: Record<string, unknown>\n  ): ApiClientObjectMap<Value> | undefined {\n    const result: ObjectValue = this._getKnownOptions(knownOptions, context);\n\n    // APPLY OPTIONS OVERRIDES\n    if (optionsOverride) {\n      const optionsMap = new Map(\n        mapToArray(optionsOverride, (value, key) => [\n          FieldPath.fromServerFormat(key),\n          value !== undefined ? parseData(value, context) : null\n        ])\n      );\n      result.setAll(optionsMap);\n    }\n\n    // Return MapValue from `result` or empty map value\n    return result.value.mapValue.fields ?? {};\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParseContext } from '../api/parse_context';\nimport { UserData } from '../lite-api/user_data_reader';\nimport {\n  ApiClientObjectMap,\n  firestoreV1ApiClientInterfaces,\n  Pipeline as PipelineProto,\n  StructuredPipeline as StructuredPipelineProto\n} from '../protos/firestore_proto_api';\nimport { JsonProtoSerializer, ProtoSerializable } from '../remote/serializer';\n\nimport { OptionsUtil } from './options_util';\n\nexport class StructuredPipelineOptions implements UserData {\n  proto: ApiClientObjectMap<firestoreV1ApiClientInterfaces.Value> | undefined;\n\n  readonly optionsUtil = new OptionsUtil({\n    indexMode: {\n      serverName: 'index_mode'\n    }\n  });\n\n  constructor(\n    private _userOptions: Record<string, unknown> = {},\n    private _optionsOverride: Record<string, unknown> = {}\n  ) {}\n\n  _readUserData(context: ParseContext): void {\n    this.proto = this.optionsUtil.getOptionsProto(\n      context,\n      this._userOptions,\n      this._optionsOverride\n    );\n  }\n}\n\nexport class StructuredPipeline\n  implements ProtoSerializable<StructuredPipelineProto>\n{\n  constructor(\n    private pipeline: ProtoSerializable<PipelineProto>,\n    private options: StructuredPipelineOptions\n  ) {}\n\n  _toProto(serializer: JsonProtoSerializer): StructuredPipelineProto {\n    return {\n      pipeline: this.pipeline._toProto(serializer),\n      options: this.options.proto\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ArrayValue as ProtoArrayValue,\n  Function as ProtoFunction,\n  LatLng as ProtoLatLng,\n  MapValue as ProtoMapValue,\n  Pipeline as ProtoPipeline,\n  Timestamp as ProtoTimestamp,\n  Value as ProtoValue\n} from '../protos/firestore_proto_api';\n\nimport { isPlainObject } from './input_validation';\n\n/* eslint @typescript-eslint/no-explicit-any: 0 */\n\nfunction isITimestamp(obj: any): obj is ProtoTimestamp {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'seconds' in obj &&\n    (obj.seconds === null ||\n      typeof obj.seconds === 'number' ||\n      typeof obj.seconds === 'string') &&\n    'nanos' in obj &&\n    (obj.nanos === null || typeof obj.nanos === 'number')\n  ) {\n    return true;\n  }\n\n  return false;\n}\nfunction isILatLng(obj: any): obj is ProtoLatLng {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'latitude' in obj &&\n    (obj.latitude === null || typeof obj.latitude === 'number') &&\n    'longitude' in obj &&\n    (obj.longitude === null || typeof obj.longitude === 'number')\n  ) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIArrayValue(obj: any): obj is ProtoArrayValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('values' in obj && (obj.values === null || Array.isArray(obj.values))) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIMapValue(obj: any): obj is ProtoMapValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('fields' in obj && (obj.fields === null || isPlainObject(obj.fields))) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIFunction(obj: any): obj is ProtoFunction {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'name' in obj &&\n    (obj.name === null || typeof obj.name === 'string') &&\n    'args' in obj &&\n    (obj.args === null || Array.isArray(obj.args))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isIPipeline(obj: any): obj is ProtoPipeline {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('stages' in obj && (obj.stages === null || Array.isArray(obj.stages))) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isFirestoreValue(obj: any): obj is ProtoValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n\n  // Check optional properties and their types\n  if (\n    ('nullValue' in obj &&\n      (obj.nullValue === null || obj.nullValue === 'NULL_VALUE')) ||\n    ('booleanValue' in obj &&\n      (obj.booleanValue === null || typeof obj.booleanValue === 'boolean')) ||\n    ('integerValue' in obj &&\n      (obj.integerValue === null ||\n        typeof obj.integerValue === 'number' ||\n        typeof obj.integerValue === 'string')) ||\n    ('doubleValue' in obj &&\n      (obj.doubleValue === null || typeof obj.doubleValue === 'number')) ||\n    ('timestampValue' in obj &&\n      (obj.timestampValue === null || isITimestamp(obj.timestampValue))) ||\n    ('stringValue' in obj &&\n      (obj.stringValue === null || typeof obj.stringValue === 'string')) ||\n    ('bytesValue' in obj &&\n      (obj.bytesValue === null || obj.bytesValue instanceof Uint8Array)) ||\n    ('referenceValue' in obj &&\n      (obj.referenceValue === null ||\n        typeof obj.referenceValue === 'string')) ||\n    ('geoPointValue' in obj &&\n      (obj.geoPointValue === null || isILatLng(obj.geoPointValue))) ||\n    ('arrayValue' in obj &&\n      (obj.arrayValue === null || isIArrayValue(obj.arrayValue))) ||\n    ('mapValue' in obj &&\n      (obj.mapValue === null || isIMapValue(obj.mapValue))) ||\n    ('fieldReferenceValue' in obj &&\n      (obj.fieldReferenceValue === null ||\n        typeof obj.fieldReferenceValue === 'string')) ||\n    ('functionValue' in obj &&\n      (obj.functionValue === null || isIFunction(obj.functionValue))) ||\n    ('pipelineValue' in obj &&\n      (obj.pipelineValue === null || isIPipeline(obj.pipelineValue)))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirestoreError } from '../api';\nimport { ParseContext } from '../api/parse_context';\nimport {\n  DOCUMENT_KEY_NAME,\n  FieldPath as InternalFieldPath\n} from '../model/path';\nimport { Value as ProtoValue } from '../protos/firestore_proto_api';\nimport {\n  JsonProtoSerializer,\n  ProtoValueSerializable,\n  toMapValue,\n  toStringValue\n} from '../remote/serializer';\nimport { hardAssert } from '../util/assert';\nimport { isPlainObject } from '../util/input_validation';\nimport { isFirestoreValue } from '../util/proto';\nimport { isString } from '../util/types';\n\nimport { Bytes } from './bytes';\nimport { documentId as documentIdFieldPath, FieldPath } from './field_path';\nimport { vector } from './field_value_impl';\nimport { GeoPoint } from './geo_point';\nimport { DocumentReference } from './reference';\nimport { Timestamp } from './timestamp';\nimport { fieldPathFromArgument, parseData, UserData } from './user_data_reader';\nimport { VectorValue } from './vector_value';\n\n/**\n * @beta\n *\n * An enumeration of the different types of expressions.\n */\nexport type ExpressionType =\n  | 'Field'\n  | 'Constant'\n  | 'Function'\n  | 'AggregateFunction'\n  | 'ListOfExpressions'\n  | 'AliasedExpression';\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nfunction valueToDefaultExpr(value: unknown): Expression {\n  let result: Expression | undefined;\n  if (value instanceof Expression) {\n    return value;\n  } else if (isPlainObject(value)) {\n    result = _map(value as Record<string, unknown>, undefined);\n  } else if (value instanceof Array) {\n    result = array(value);\n  } else {\n    result = _constant(value, undefined);\n  }\n\n  return result;\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nfunction vectorToExpr(value: VectorValue | number[] | Expression): Expression {\n  if (value instanceof Expression) {\n    return value;\n  } else if (value instanceof VectorValue) {\n    return constant(value);\n  } else if (Array.isArray(value)) {\n    return constant(vector(value));\n  } else {\n    throw new Error('Unsupported value: ' + typeof value);\n  }\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n * If the input is a string, it is assumed to be a field name, and a\n * field(value) is returned.\n *\n * @private\n * @internal\n * @param value\n */\nfunction fieldOrExpression(value: unknown): Expression {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return valueToDefaultExpr(value);\n  }\n}\n\n/**\n * @beta\n *\n * Represents an expression that can be evaluated to a value within the execution of a {@link\n * @firebase/firestore/pipelines#Pipeline}.\n *\n * Expressions are the building blocks for creating complex queries and transformations in\n * Firestore pipelines. They can represent:\n *\n * - **Field references:** Access values from document fields.\n * - **Literals:** Represent constant values (strings, numbers, booleans).\n * - **Function calls:** Apply functions to one or more expressions.\n *\n * The `Expression` class provides a fluent API for building expressions. You can chain together\n * method calls to create complex expressions.\n */\nexport abstract class Expression implements ProtoValueSerializable, UserData {\n  abstract readonly expressionType: ExpressionType;\n\n  abstract readonly _methodName?: string;\n\n  /**\n   * @private\n   * @internal\n   */\n  abstract _toProto(serializer: JsonProtoSerializer): ProtoValue;\n  _protoValueType = 'ProtoValue' as const;\n\n  /**\n   * @private\n   * @internal\n   */\n  abstract _readUserData(context: ParseContext): void;\n\n  /**\n   * Creates an expression that adds this expression to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Add the value of the 'quantity' field and the 'reserve' field.\n   * field(\"quantity\").add(field(\"reserve\"));\n   * ```\n   *\n   * @param second - The expression or literal to add to this expression.\n   * @param others - Optional additional expressions or literals to add to this expression.\n   * @returns A new `Expression` representing the addition operation.\n   */\n  add(second: Expression | unknown): FunctionExpression {\n    return new FunctionExpression(\n      'add',\n      [this, valueToDefaultExpr(second)],\n      'add'\n    );\n  }\n\n  /**\n   * @beta\n   * Wraps the expression in a [BooleanExpression].\n   *\n   * @returns A [BooleanExpression] representing the same expression.\n   */\n  asBoolean(): BooleanExpression {\n    if (this instanceof BooleanExpression) {\n      return this;\n    } else if (this instanceof Constant) {\n      return new BooleanConstant(this);\n    } else if (this instanceof Field) {\n      return new BooleanField(this);\n    } else if (this instanceof FunctionExpression) {\n      return new BooleanFunctionExpression(this);\n    } else {\n      throw new FirestoreError(\n        'invalid-argument',\n        `Conversion of type ${typeof this} to BooleanExpression not supported.`\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that subtracts another expression from this expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract the 'discount' field from the 'price' field\n   * field(\"price\").subtract(field(\"discount\"));\n   * ```\n   *\n   * @param subtrahend - The expression to subtract from this expression.\n   * @returns A new `Expression` representing the subtraction operation.\n   */\n  subtract(subtrahend: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a constant value from this expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract 20 from the value of the 'total' field\n   * field(\"total\").subtract(20);\n   * ```\n   *\n   * @param subtrahend - The constant value to subtract.\n   * @returns A new `Expression` representing the subtraction operation.\n   */\n  subtract(subtrahend: number): FunctionExpression;\n  subtract(subtrahend: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'subtract',\n      [this, valueToDefaultExpr(subtrahend)],\n      'subtract'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that multiplies this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Multiply the 'quantity' field by the 'price' field\n   * field(\"quantity\").multiply(field(\"price\"));\n   * ```\n   *\n   * @param second - The second expression or literal to multiply by.\n   * @param others - Optional additional expressions or literals to multiply by.\n   * @returns A new `Expression` representing the multiplication operation.\n   */\n  multiply(second: Expression | number): FunctionExpression {\n    return new FunctionExpression(\n      'multiply',\n      [this, valueToDefaultExpr(second)],\n      'multiply'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that divides this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Divide the 'total' field by the 'count' field\n   * field(\"total\").divide(field(\"count\"));\n   * ```\n   *\n   * @param divisor - The expression to divide by.\n   * @returns A new `Expression` representing the division operation.\n   */\n  divide(divisor: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that divides this expression by a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Divide the 'value' field by 10\n   * field(\"value\").divide(10);\n   * ```\n   *\n   * @param divisor - The constant value to divide by.\n   * @returns A new `Expression` representing the division operation.\n   */\n  divide(divisor: number): FunctionExpression;\n  divide(divisor: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'divide',\n      [this, valueToDefaultExpr(divisor)],\n      'divide'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the modulo (remainder) of dividing this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the remainder of dividing the 'value' field by the 'divisor' field\n   * field(\"value\").mod(field(\"divisor\"));\n   * ```\n   *\n   * @param expression - The expression to divide by.\n   * @returns A new `Expression` representing the modulo operation.\n   */\n  mod(expression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that calculates the modulo (remainder) of dividing this expression by a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the remainder of dividing the 'value' field by 10\n   * field(\"value\").mod(10);\n   * ```\n   *\n   * @param value - The constant value to divide by.\n   * @returns A new `Expression` representing the modulo operation.\n   */\n  mod(value: number): FunctionExpression;\n  mod(other: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'mod',\n      [this, valueToDefaultExpr(other)],\n      'mod'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is equal to 21\n   * field(\"age\").equal(21);\n   * ```\n   *\n   * @param expression - The expression to compare for equality.\n   * @returns A new `Expression` representing the equality comparison.\n   */\n  equal(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'city' field is equal to \"London\"\n   * field(\"city\").equal(\"London\");\n   * ```\n   *\n   * @param value - The constant value to compare for equality.\n   * @returns A new `Expression` representing the equality comparison.\n   */\n  equal(value: unknown): BooleanExpression;\n  equal(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'equal',\n      [this, valueToDefaultExpr(other)],\n      'equal'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is not equal to \"completed\"\n   * field(\"status\").notEqual(\"completed\");\n   * ```\n   *\n   * @param expression - The expression to compare for inequality.\n   * @returns A new `Expression` representing the inequality comparison.\n   */\n  notEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'country' field is not equal to \"USA\"\n   * field(\"country\").notEqual(\"USA\");\n   * ```\n   *\n   * @param value - The constant value to compare for inequality.\n   * @returns A new `Expression` representing the inequality comparison.\n   */\n  notEqual(value: unknown): BooleanExpression;\n  notEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'not_equal',\n      [this, valueToDefaultExpr(other)],\n      'notEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is less than 'limit'\n   * field(\"age\").lessThan(field('limit'));\n   * ```\n   *\n   * @param experession - The expression to compare for less than.\n   * @returns A new `Expression` representing the less than comparison.\n   */\n  lessThan(experession: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is less than 50\n   * field(\"price\").lessThan(50);\n   * ```\n   *\n   * @param value - The constant value to compare for less than.\n   * @returns A new `Expression` representing the less than comparison.\n   */\n  lessThan(value: unknown): BooleanExpression;\n  lessThan(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'less_than',\n      [this, valueToDefaultExpr(other)],\n      'lessThan'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than or equal to another\n   * expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'quantity' field is less than or equal to 20\n   * field(\"quantity\").lessThan(constant(20));\n   * ```\n   *\n   * @param expression - The expression to compare for less than or equal to.\n   * @returns A new `Expression` representing the less than or equal to comparison.\n   */\n  lessThanOrEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than or equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'score' field is less than or equal to 70\n   * field(\"score\").lessThan(70);\n   * ```\n   *\n   * @param value - The constant value to compare for less than or equal to.\n   * @returns A new `Expression` representing the less than or equal to comparison.\n   */\n  lessThanOrEqual(value: unknown): BooleanExpression;\n  lessThanOrEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'less_than_or_equal',\n      [this, valueToDefaultExpr(other)],\n      'lessThanOrEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is greater than the 'limit' field\n   * field(\"age\").greaterThan(field(\"limit\"));\n   * ```\n   *\n   * @param expression - The expression to compare for greater than.\n   * @returns A new `Expression` representing the greater than comparison.\n   */\n  greaterThan(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is greater than 100\n   * field(\"price\").greaterThan(100);\n   * ```\n   *\n   * @param value - The constant value to compare for greater than.\n   * @returns A new `Expression` representing the greater than comparison.\n   */\n  greaterThan(value: unknown): BooleanExpression;\n  greaterThan(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'greater_than',\n      [this, valueToDefaultExpr(other)],\n      'greaterThan'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than or equal to another\n   * expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'quantity' field is greater than or equal to field 'requirement' plus 1\n   * field(\"quantity\").greaterThanOrEqual(field('requirement').add(1));\n   * ```\n   *\n   * @param expression - The expression to compare for greater than or equal to.\n   * @returns A new `Expression` representing the greater than or equal to comparison.\n   */\n  greaterThanOrEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than or equal to a constant\n   * value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'score' field is greater than or equal to 80\n   * field(\"score\").greaterThanOrEqual(80);\n   * ```\n   *\n   * @param value - The constant value to compare for greater than or equal to.\n   * @returns A new `Expression` representing the greater than or equal to comparison.\n   */\n  greaterThanOrEqual(value: unknown): BooleanExpression;\n  greaterThanOrEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'greater_than_or_equal',\n      [this, valueToDefaultExpr(other)],\n      'greaterThanOrEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates an array expression with one or more other arrays.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'items' array with another array field.\n   * field(\"items\").arrayConcat(field(\"otherItems\"));\n   * ```\n   * @param secondArray - Second array expression or array literal to concatenate.\n   * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n   * @returns A new `Expression` representing the concatenated array.\n   */\n  arrayConcat(\n    secondArray: Expression | unknown[],\n    ...otherArrays: Array<Expression | unknown[]>\n  ): FunctionExpression {\n    const elements = [secondArray, ...otherArrays];\n    const exprValues = elements.map(value => valueToDefaultExpr(value));\n    return new FunctionExpression(\n      'array_concat',\n      [this, ...exprValues],\n      'arrayConcat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains a specific element.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'sizes' array contains the value from the 'selectedSize' field\n   * field(\"sizes\").arrayContains(field(\"selectedSize\"));\n   * ```\n   *\n   * @param expression - The element to search for in the array.\n   * @returns A new `Expression` representing the 'array_contains' comparison.\n   */\n  arrayContains(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains a specific value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'colors' array contains \"red\"\n   * field(\"colors\").arrayContains(\"red\");\n   * ```\n   *\n   * @param value - The element to search for in the array.\n   * @returns A new `Expression` representing the 'array_contains' comparison.\n   */\n  arrayContains(value: unknown): BooleanExpression;\n  arrayContains(element: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'array_contains',\n      [this, valueToDefaultExpr(element)],\n      'arrayContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains all the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'tags' array contains both the value in field \"tag1\" and the literal value \"tag2\"\n   * field(\"tags\").arrayContainsAll([field(\"tag1\"), \"tag2\"]);\n   * ```\n   *\n   * @param values - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_all' comparison.\n   */\n  arrayContainsAll(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains all the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'tags' array contains both of the values from field \"tag1\" and the literal value \"tag2\"\n   * field(\"tags\").arrayContainsAll(array([field(\"tag1\"), \"tag2\"]));\n   * ```\n   *\n   * @param arrayExpression - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_all' comparison.\n   */\n  arrayContainsAll(arrayExpression: Expression): BooleanExpression;\n  arrayContainsAll(values: unknown[] | Expression): BooleanExpression {\n    const normalizedExpr = Array.isArray(values)\n      ? new ListOfExprs(values.map(valueToDefaultExpr), 'arrayContainsAll')\n      : values;\n    return new FunctionExpression(\n      'array_contains_all',\n      [this, normalizedExpr],\n      'arrayContainsAll'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains any of the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'categories' array contains either values from field \"cate1\" or \"cate2\"\n   * field(\"categories\").arrayContainsAny([field(\"cate1\"), field(\"cate2\")]);\n   * ```\n   *\n   * @param values - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_any' comparison.\n   */\n  arrayContainsAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains any of the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'groups' array contains either the value from the 'userGroup' field\n   * // or the value \"guest\"\n   * field(\"groups\").arrayContainsAny(array([field(\"userGroup\"), \"guest\"]));\n   * ```\n   *\n   * @param arrayExpression - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_any' comparison.\n   */\n  arrayContainsAny(arrayExpression: Expression): BooleanExpression;\n  arrayContainsAny(\n    values: Array<unknown | Expression> | Expression\n  ): BooleanExpression {\n    const normalizedExpr = Array.isArray(values)\n      ? new ListOfExprs(values.map(valueToDefaultExpr), 'arrayContainsAny')\n      : values;\n    return new FunctionExpression(\n      'array_contains_any',\n      [this, normalizedExpr],\n      'arrayContainsAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses an array.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myArray' field.\n   * field(\"myArray\").arrayReverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n   */\n  arrayReverse(): FunctionExpression {\n    return new FunctionExpression('array_reverse', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of an array.\n   *\n   * @example\n   * ```typescript\n   * // Get the number of items in the 'cart' array\n   * field(\"cart\").arrayLength();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the array.\n   */\n  arrayLength(): FunctionExpression {\n    return new FunctionExpression('array_length', [this], 'arrayLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n   * field(\"category\").equalAny(\"Electronics\", field(\"primaryType\"));\n   * ```\n   *\n   * @param values - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'IN' comparison.\n   */\n  equalAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n   * field(\"category\").equalAny(array([\"Electronics\", field(\"primaryType\")]));\n   * ```\n   *\n   * @param arrayExpression - An expression that evaluates to an array of values to check against.\n   * @returns A new `Expression` representing the 'IN' comparison.\n   */\n  equalAny(arrayExpression: Expression): BooleanExpression;\n  equalAny(others: unknown[] | Expression): BooleanExpression {\n    const exprOthers = Array.isArray(others)\n      ? new ListOfExprs(others.map(valueToDefaultExpr), 'equalAny')\n      : others;\n    return new FunctionExpression(\n      'equal_any',\n      [this, exprOthers],\n      'equalAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n   * field(\"status\").notEqualAny([\"pending\", field(\"rejectedStatus\")]);\n   * ```\n   *\n   * @param values - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'notEqualAny' comparison.\n   */\n  notEqualAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to any of the values in the evaluated expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is not equal to any value in the field 'rejectedStatuses'\n   * field(\"status\").notEqualAny(field('rejectedStatuses'));\n   * ```\n   *\n   * @param arrayExpression - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'notEqualAny' comparison.\n   */\n  notEqualAny(arrayExpression: Expression): BooleanExpression;\n  notEqualAny(others: unknown[] | Expression): BooleanExpression {\n    const exprOthers = Array.isArray(others)\n      ? new ListOfExprs(others.map(valueToDefaultExpr), 'notEqualAny')\n      : others;\n    return new FunctionExpression(\n      'not_equal_any',\n      [this, exprOthers],\n      'notEqualAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a field exists in the document.\n   *\n   * @example\n   * ```typescript\n   * // Check if the document has a field named \"phoneNumber\"\n   * field(\"phoneNumber\").exists();\n   * ```\n   *\n   * @returns A new `Expression` representing the 'exists' check.\n   */\n  exists(): BooleanExpression {\n    return new FunctionExpression('exists', [this], 'exists').asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the character length of a string in UTF-8.\n   *\n   * @example\n   * ```typescript\n   * // Get the character length of the 'name' field in its UTF-8 form.\n   * field(\"name\").charLength();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the string.\n   */\n  charLength(): FunctionExpression {\n    return new FunctionExpression('char_length', [this], 'charLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that performs a case-sensitive string comparison.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'title' field contains the word \"guide\" (case-sensitive)\n   * field(\"title\").like(\"%guide%\");\n   * ```\n   *\n   * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n   * @returns A new `Expression` representing the 'like' comparison.\n   */\n  like(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that performs a case-sensitive string comparison.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'title' field contains the word \"guide\" (case-sensitive)\n   * field(\"title\").like(\"%guide%\");\n   * ```\n   *\n   * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n   * @returns A new `Expression` representing the 'like' comparison.\n   */\n  like(pattern: Expression): BooleanExpression;\n  like(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'like',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'like'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified regular expression as a\n   * substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains \"example\" (case-insensitive)\n   * field(\"description\").regexContains(\"(?i)example\");\n   * ```\n   *\n   * @param pattern - The regular expression to use for the search.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  regexContains(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified regular expression as a\n   * substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains the regular expression stored in field 'regex'\n   * field(\"description\").regexContains(field(\"regex\"));\n   * ```\n   *\n   * @param pattern - The regular expression to use for the search.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  regexContains(pattern: Expression): BooleanExpression;\n  regexContains(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'regex_contains',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string matches a specified regular expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'email' field matches a valid email pattern\n   * field(\"email\").regexMatch(\"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n   * ```\n   *\n   * @param pattern - The regular expression to use for the match.\n   * @returns A new `Expression` representing the regular expression match.\n   */\n  regexMatch(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string matches a specified regular expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'email' field matches a regular expression stored in field 'regex'\n   * field(\"email\").regexMatch(field(\"regex\"));\n   * ```\n   *\n   * @param pattern - The regular expression to use for the match.\n   * @returns A new `Expression` representing the regular expression match.\n   */\n  regexMatch(pattern: Expression): BooleanExpression;\n  regexMatch(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'regex_match',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexMatch'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains \"example\".\n   * field(\"description\").stringContains(\"example\");\n   * ```\n   *\n   * @param substring - The substring to search for.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  stringContains(substring: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains the string represented by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains the value of the 'keyword' field.\n   * field(\"description\").stringContains(field(\"keyword\"));\n   * ```\n   *\n   * @param expr - The expression representing the substring to search for.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  stringContains(expr: Expression): BooleanExpression;\n  stringContains(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'string_contains',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'stringContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string starts with a given prefix.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'name' field starts with \"Mr.\"\n   * field(\"name\").startsWith(\"Mr.\");\n   * ```\n   *\n   * @param prefix - The prefix to check for.\n   * @returns A new `Expression` representing the 'starts with' comparison.\n   */\n  startsWith(prefix: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string starts with a given prefix (represented as an\n   * expression).\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'fullName' field starts with the value of the 'firstName' field\n   * field(\"fullName\").startsWith(field(\"firstName\"));\n   * ```\n   *\n   * @param prefix - The prefix expression to check for.\n   * @returns A new `Expression` representing the 'starts with' comparison.\n   */\n  startsWith(prefix: Expression): BooleanExpression;\n  startsWith(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'starts_with',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'startsWith'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string ends with a given postfix.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'filename' field ends with \".txt\"\n   * field(\"filename\").endsWith(\".txt\");\n   * ```\n   *\n   * @param suffix - The postfix to check for.\n   * @returns A new `Expression` representing the 'ends with' comparison.\n   */\n  endsWith(suffix: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string ends with a given postfix (represented as an\n   * expression).\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'url' field ends with the value of the 'extension' field\n   * field(\"url\").endsWith(field(\"extension\"));\n   * ```\n   *\n   * @param suffix - The postfix expression to check for.\n   * @returns A new `Expression` representing the 'ends with' comparison.\n   */\n  endsWith(suffix: Expression): BooleanExpression;\n  endsWith(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'ends_with',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'endsWith'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts a string to lowercase.\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'name' field to lowercase\n   * field(\"name\").toLower();\n   * ```\n   *\n   * @returns A new `Expression` representing the lowercase string.\n   */\n  toLower(): FunctionExpression {\n    return new FunctionExpression('to_lower', [this], 'toLower');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts a string to uppercase.\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'title' field to uppercase\n   * field(\"title\").toUpper();\n   * ```\n   *\n   * @returns A new `Expression` representing the uppercase string.\n   */\n  toUpper(): FunctionExpression {\n    return new FunctionExpression('to_upper', [this], 'toUpper');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that removes leading and trailing characters from a string or byte array.\n   *\n   * @example\n   * ```typescript\n   * // Trim whitespace from the 'userInput' field\n   * field(\"userInput\").trim();\n   *\n   * // Trim quotes from the 'userInput' field\n   * field(\"userInput\").trim('\"');\n   * ```\n   * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n   * trimmed from the input. If not specified, then whitespace will be trimmed.\n   * @returns A new `Expression` representing the trimmed string or byte array.\n   */\n  trim(valueToTrim?: string | Expression | Bytes): FunctionExpression {\n    const args: Expression[] = [this];\n    if (valueToTrim) {\n      args.push(valueToDefaultExpr(valueToTrim));\n    }\n    return new FunctionExpression('trim', args, 'trim');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates string expressions together.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n   * field(\"firstName\").stringConcat(constant(\" \"), field(\"lastName\"));\n   * ```\n   *\n   * @param secondString - The additional expression or string literal to concatenate.\n   * @param otherStrings - Optional additional expressions or string literals to concatenate.\n   * @returns A new `Expression` representing the concatenated string.\n   */\n  stringConcat(\n    secondString: Expression | string,\n    ...otherStrings: Array<Expression | string>\n  ): FunctionExpression {\n    const elements = [secondString, ...otherStrings];\n    const exprs = elements.map(valueToDefaultExpr);\n    return new FunctionExpression(\n      'string_concat',\n      [this, ...exprs],\n      'stringConcat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates expression results together.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'firstName', ' ', and 'lastName' fields into a single value.\n   * field(\"firstName\").concat(constant(\" \"), field(\"lastName\"));\n   * ```\n   *\n   * @param second - The additional expression or literal to concatenate.\n   * @param others - Optional additional expressions or literals to concatenate.\n   * @returns A new `Expression` representing the concatenated value.\n   */\n  concat(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const elements = [second, ...others];\n    const exprs = elements.map(valueToDefaultExpr);\n    return new FunctionExpression('concat', [this, ...exprs], 'concat');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses this string expression.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myString' field.\n   * field(\"myString\").reverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n   */\n  reverse(): FunctionExpression {\n    return new FunctionExpression('reverse', [this], 'reverse');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of this string expression in bytes.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the length of the 'myString' field in bytes.\n   * field(\"myString\").byteLength();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n   */\n  byteLength(): FunctionExpression {\n    return new FunctionExpression('byte_length', [this], 'byteLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the ceiling of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the ceiling of the 'price' field.\n   * field(\"price\").ceil();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n   */\n  ceil(): FunctionExpression {\n    return new FunctionExpression('ceil', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the floor of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the floor of the 'price' field.\n   * field(\"price\").floor();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n   */\n  floor(): FunctionExpression {\n    return new FunctionExpression('floor', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the absolute value of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the absolute value of the 'price' field.\n   * field(\"price\").abs();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n   */\n  abs(): FunctionExpression {\n    return new FunctionExpression('abs', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes e to the power of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Compute e to the power of the 'value' field.\n   * field(\"value\").exp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n   */\n  exp(): FunctionExpression {\n    return new FunctionExpression('exp', [this]);\n  }\n\n  /**\n   * @beta\n   * Accesses a value from a map (object) field using the provided key.\n   *\n   * @example\n   * ```typescript\n   * // Get the 'city' value from the 'address' map field\n   * field(\"address\").mapGet(\"city\");\n   * ```\n   *\n   * @param subfield - The key to access in the map.\n   * @returns A new `Expression` representing the value associated with the given key in the map.\n   */\n  mapGet(subfield: string): FunctionExpression {\n    return new FunctionExpression(\n      'map_get',\n      [this, constant(subfield)],\n      'mapGet'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that counts the number of stage inputs with valid evaluations of the\n   * expression or field.\n   *\n   * @example\n   * ```typescript\n   * // Count the total number of products\n   * field(\"productId\").count().as(\"totalProducts\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'count' aggregation.\n   */\n  count(): AggregateFunction {\n    return AggregateFunction._create('count', [this], 'count');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that calculates the sum of a numeric field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the total revenue from a set of orders\n   * field(\"orderAmount\").sum().as(\"totalRevenue\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'sum' aggregation.\n   */\n  sum(): AggregateFunction {\n    return AggregateFunction._create('sum', [this], 'sum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that calculates the average (mean) of a numeric field across multiple\n   * stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average age of users\n   * field(\"age\").average().as(\"averageAge\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'average' aggregation.\n   */\n  average(): AggregateFunction {\n    return AggregateFunction._create('average', [this], 'average');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the minimum value of a field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the lowest price of all products\n   * field(\"price\").minimum().as(\"lowestPrice\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'minimum' aggregation.\n   */\n  minimum(): AggregateFunction {\n    return AggregateFunction._create('minimum', [this], 'minimum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the maximum value of a field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the highest score in a leaderboard\n   * field(\"score\").maximum().as(\"highestScore\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'maximum' aggregation.\n   */\n  maximum(): AggregateFunction {\n    return AggregateFunction._create('maximum', [this], 'maximum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that counts the number of distinct values of the expression or field.\n   *\n   * @example\n   * ```typescript\n   * // Count the distinct number of products\n   * field(\"productId\").countDistinct().as(\"distinctProducts\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'count_distinct' aggregation.\n   */\n  countDistinct(): AggregateFunction {\n    return AggregateFunction._create('count_distinct', [this], 'countDistinct');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the larger value between this expression and another expression, based on Firestore's value type ordering.\n   *\n   * @example\n   * ```typescript\n   * // Returns the larger value between the 'timestamp' field and the current timestamp.\n   * field(\"timestamp\").logicalMaximum(Function.currentTimestamp());\n   * ```\n   *\n   * @param second - The second expression or literal to compare with.\n   * @param others - Optional additional expressions or literals to compare with.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n   */\n  logicalMaximum(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const values = [second, ...others];\n    return new FunctionExpression(\n      'maximum',\n      [this, ...values.map(valueToDefaultExpr)],\n      'logicalMaximum'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the smaller value between this expression and another expression, based on Firestore's value type ordering.\n   *\n   * @example\n   * ```typescript\n   * // Returns the smaller value between the 'timestamp' field and the current timestamp.\n   * field(\"timestamp\").logicalMinimum(Function.currentTimestamp());\n   * ```\n   *\n   * @param second - The second expression or literal to compare with.\n   * @param others - Optional additional expressions or literals to compare with.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n   */\n  logicalMinimum(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const values = [second, ...others];\n    return new FunctionExpression(\n      'minimum',\n      [this, ...values.map(valueToDefaultExpr)],\n      'minimum'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length (number of dimensions) of this Firestore Vector expression.\n   *\n   * @example\n   * ```typescript\n   * // Get the vector length (dimension) of the field 'embedding'.\n   * field(\"embedding\").vectorLength();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the vector.\n   */\n  vectorLength(): FunctionExpression {\n    return new FunctionExpression('vector_length', [this], 'vectorLength');\n  }\n\n  /**\n   * @beta\n   * Calculates the cosine distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n   * field(\"userVector\").cosineDistance(field(\"itemVector\"));\n   * ```\n   *\n   * @param vectorExpression - The other vector (represented as an Expression) to compare against.\n   * @returns A new `Expression` representing the cosine distance between the two vectors.\n   */\n  cosineDistance(vectorExpression: Expression): FunctionExpression;\n  /**\n   * @beta\n   * Calculates the Cosine distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Cosine distance between the 'location' field and a target location\n   * field(\"location\").cosineDistance(new VectorValue([37.7749, -122.4194]));\n   * ```\n   *\n   * @param vector - The other vector (as a VectorValue) to compare against.\n   * @returns A new `Expression` representing the Cosine* distance between the two vectors.\n   */\n  cosineDistance(vector: VectorValue | number[]): FunctionExpression;\n  cosineDistance(\n    other: Expression | VectorValue | number[]\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'cosine_distance',\n      [this, vectorToExpr(other)],\n      'cosineDistance'\n    );\n  }\n\n  /**\n   * @beta\n   * Calculates the dot product between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the dot product between a feature vector and a target vector\n   * field(\"features\").dotProduct([0.5, 0.8, 0.2]);\n   * ```\n   *\n   * @param vectorExpression - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the dot product between the two vectors.\n   */\n  dotProduct(vectorExpression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Calculates the dot product between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the dot product between a feature vector and a target vector\n   * field(\"features\").dotProduct(new VectorValue([0.5, 0.8, 0.2]));\n   * ```\n   *\n   * @param vector - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the dot product between the two vectors.\n   */\n  dotProduct(vector: VectorValue | number[]): FunctionExpression;\n  dotProduct(other: Expression | VectorValue | number[]): FunctionExpression {\n    return new FunctionExpression(\n      'dot_product',\n      [this, vectorToExpr(other)],\n      'dotProduct'\n    );\n  }\n\n  /**\n   * @beta\n   * Calculates the Euclidean distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Euclidean distance between the 'location' field and a target location\n   * field(\"location\").euclideanDistance([37.7749, -122.4194]);\n   * ```\n   *\n   * @param vectorExpression - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the Euclidean distance between the two vectors.\n   */\n  euclideanDistance(vectorExpression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Calculates the Euclidean distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Euclidean distance between the 'location' field and a target location\n   * field(\"location\").euclideanDistance(new VectorValue([37.7749, -122.4194]));\n   * ```\n   *\n   * @param vector - The other vector (as a VectorValue) to compare against.\n   * @returns A new `Expression` representing the Euclidean distance between the two vectors.\n   */\n  euclideanDistance(vector: VectorValue | number[]): FunctionExpression;\n  euclideanDistance(\n    other: Expression | VectorValue | number[]\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'euclidean_distance',\n      [this, vectorToExpr(other)],\n      'euclideanDistance'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'microseconds' field as microseconds since epoch.\n   * field(\"microseconds\").unixMicrosToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixMicrosToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_micros_to_timestamp',\n      [this],\n      'unixMicrosToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to microseconds since epoch.\n   * field(\"timestamp\").timestampToUnixMicros();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n   */\n  timestampToUnixMicros(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_micros',\n      [this],\n      'timestampToUnixMicros'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'milliseconds' field as milliseconds since epoch.\n   * field(\"milliseconds\").unixMillisToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixMillisToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_millis_to_timestamp',\n      [this],\n      'unixMillisToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to milliseconds since epoch.\n   * field(\"timestamp\").timestampToUnixMillis();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n   */\n  timestampToUnixMillis(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_millis',\n      [this],\n      'timestampToUnixMillis'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'seconds' field as seconds since epoch.\n   * field(\"seconds\").unixSecondsToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixSecondsToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_seconds_to_timestamp',\n      [this],\n      'unixSecondsToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to seconds since epoch.\n   * field(\"timestamp\").timestampToUnixSeconds();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n   */\n  timestampToUnixSeconds(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_seconds',\n      [this],\n      'timestampToUnixSeconds'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that adds a specified amount of time to this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Add some duration determined by field 'unit' and 'amount' to the 'timestamp' field.\n   * field(\"timestamp\").timestampAdd(field(\"unit\"), field(\"amount\"));\n   * ```\n   *\n   * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n   * @param amount - The expression evaluates to amount of the unit.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampAdd(unit: Expression, amount: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that adds a specified amount of time to this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Add 1 day to the 'timestamp' field.\n   * field(\"timestamp\").timestampAdd(\"day\", 1);\n   * ```\n   *\n   * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n   * @param amount - The amount of time to add.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampAdd(\n    unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n    amount: number\n  ): FunctionExpression;\n  timestampAdd(\n    unit:\n      | Expression\n      | 'microsecond'\n      | 'millisecond'\n      | 'second'\n      | 'minute'\n      | 'hour'\n      | 'day',\n    amount: Expression | number\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_add',\n      [this, valueToDefaultExpr(unit), valueToDefaultExpr(amount)],\n      'timestampAdd'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a specified amount of time from this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract some duration determined by field 'unit' and 'amount' from the 'timestamp' field.\n   * field(\"timestamp\").timestampSubtract(field(\"unit\"), field(\"amount\"));\n   * ```\n   *\n   * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n   * @param amount - The expression evaluates to amount of the unit.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampSubtract(unit: Expression, amount: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a specified amount of time from this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract 1 day from the 'timestamp' field.\n   * field(\"timestamp\").timestampSubtract(\"day\", 1);\n   * ```\n   *\n   * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n   * @param amount - The amount of time to subtract.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampSubtract(\n    unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n    amount: number\n  ): FunctionExpression;\n  timestampSubtract(\n    unit:\n      | Expression\n      | 'microsecond'\n      | 'millisecond'\n      | 'second'\n      | 'minute'\n      | 'hour'\n      | 'day',\n    amount: Expression | number\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_subtract',\n      [this, valueToDefaultExpr(unit), valueToDefaultExpr(amount)],\n      'timestampSubtract'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the document ID from a path.\n   *\n   * @example\n   * ```typescript\n   * // Get the document ID from a path.\n   * field(\"__path__\").documentId();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n   */\n  documentId(): FunctionExpression {\n    return new FunctionExpression('document_id', [this], 'documentId');\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns a substring of the results of this expression.\n   *\n   * @param position - Index of the first character of the substring.\n   * @param length - Length of the substring. If not provided, the substring will\n   * end at the end of the input.\n   */\n  substring(position: number, length?: number): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns a substring of the results of this expression.\n   *\n   * @param position - An expression returning the index of the first character of the substring.\n   * @param length - An expression returning the length of the substring. If not provided the\n   * substring will end at the end of the input.\n   */\n  substring(position: Expression, length?: Expression): FunctionExpression;\n  substring(\n    position: Expression | number,\n    length?: Expression | number\n  ): FunctionExpression {\n    const positionExpr = valueToDefaultExpr(position);\n    if (length === undefined) {\n      return new FunctionExpression(\n        'substring',\n        [this, positionExpr],\n        'substring'\n      );\n    } else {\n      return new FunctionExpression(\n        'substring',\n        [this, positionExpr, valueToDefaultExpr(length)],\n        'substring'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that indexes into an array from the beginning or end\n   * and returns the element. If the offset exceeds the array length, an error is\n   * returned. A negative offset, starts from the end.\n   *\n   * @example\n   * ```typescript\n   * // Return the value in the 'tags' field array at index `1`.\n   * field('tags').arrayGet(1);\n   * ```\n   *\n   * @param offset - The index of the element to return.\n   * @returns A new `Expression` representing the 'arrayGet' operation.\n   */\n  arrayGet(offset: number): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that indexes into an array from the beginning or end\n   * and returns the element. If the offset exceeds the array length, an error is\n   * returned. A negative offset, starts from the end.\n   *\n   * @example\n   * ```typescript\n   * // Return the value in the tags field array at index specified by field\n   * // 'favoriteTag'.\n   * field('tags').arrayGet(field('favoriteTag'));\n   * ```\n   *\n   * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n   * @returns A new `Expression` representing the 'arrayGet' operation.\n   */\n  arrayGet(offsetExpr: Expression): FunctionExpression;\n  arrayGet(offset: Expression | number): FunctionExpression {\n    return new FunctionExpression(\n      'array_get',\n      [this, valueToDefaultExpr(offset)],\n      'arrayGet'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that checks if a given expression produces an error.\n   *\n   * @example\n   * ```typescript\n   * // Check if the result of a calculation is an error\n   * field(\"title\").arrayContains(1).isError();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#BooleanExpression} representing the 'isError' check.\n   */\n  isError(): BooleanExpression {\n    return new FunctionExpression('is_error', [this], 'isError').asBoolean();\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the result of the `catchExpr` argument\n   * if there is an error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Returns the first item in the title field arrays, or returns\n   * // the entire title field if the array is empty or the field is another type.\n   * field(\"title\").arrayGet(0).ifError(field(\"title\"));\n   * ```\n   *\n   * @param catchExpr - The catch expression that will be evaluated and\n   * returned if this expression produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchExpr: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Returns the first item in the title field arrays, or returns\n   * // \"Default Title\"\n   * field(\"title\").arrayGet(0).ifError(\"Default Title\");\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: unknown): FunctionExpression;\n  ifError(catchValue: unknown): FunctionExpression | BooleanExpression {\n    const result = new FunctionExpression(\n      'if_error',\n      [this, valueToDefaultExpr(catchValue)],\n      'ifError'\n    );\n\n    return catchValue instanceof BooleanExpression\n      ? result.asBoolean()\n      : result;\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns `true` if the result of this expression\n   * is absent. Otherwise, returns `false` even if the value is `null`.\n   *\n   * @example\n   * ```typescript\n   * // Check if the field `value` is absent.\n   * field(\"value\").isAbsent();\n   * @example\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#BooleanExpression} representing the 'isAbsent' check.\n   */\n  isAbsent(): BooleanExpression {\n    return new FunctionExpression('is_absent', [this], 'isAbsent').asBoolean();\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that removes a key from the map produced by evaluating this expression.\n   *\n   * @example\n   * ```\n   * // Removes the key 'baz' from the input map.\n   * map({foo: 'bar', baz: true}).mapRemove('baz');\n   * ```\n   *\n   * @param key - The name of the key to remove from the input map.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapRemove' operation.\n   */\n  mapRemove(key: string): FunctionExpression;\n  /**\n   * @beta\n   *\n   * Creates an expression that removes a key from the map produced by evaluating this expression.\n   *\n   * @example\n   * ```\n   * // Removes the key 'baz' from the input map.\n   * map({foo: 'bar', baz: true}).mapRemove(constant('baz'));\n   * @example\n   * ```\n   *\n   * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapRemove' operation.\n   */\n  mapRemove(keyExpr: Expression): FunctionExpression;\n  mapRemove(stringExpr: Expression | string): FunctionExpression {\n    return new FunctionExpression(\n      'map_remove',\n      [this, valueToDefaultExpr(stringExpr)],\n      'mapRemove'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that merges multiple map values.\n   *\n   * @example\n   * ```\n   * // Merges the map in the settings field with, a map literal, and a map in\n   * // that is conditionally returned by another expression\n   * field('settings').mapMerge({ enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n   * ```\n   *\n   * @param secondMap - A required second map to merge. Represented as a literal or\n   * an expression that returns a map.\n   * @param otherMaps - Optional additional maps to merge. Each map is represented\n   * as a literal or an expression that returns a map.\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapMerge' operation.\n   */\n  mapMerge(\n    secondMap: Record<string, unknown> | Expression,\n    ...otherMaps: Array<Record<string, unknown> | Expression>\n  ): FunctionExpression {\n    const secondMapExpr = valueToDefaultExpr(secondMap);\n    const otherMapExprs = otherMaps.map(valueToDefaultExpr);\n    return new FunctionExpression(\n      'map_merge',\n      [this, secondMapExpr, ...otherMapExprs],\n      'mapMerge'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the value of this expression raised to the power of another expression.\n   *\n   * @example\n   * ```typescript\n   * // Raise the value of the 'base' field to the power of the 'exponent' field.\n   * field(\"base\").pow(field(\"exponent\"));\n   * ```\n   *\n   * @param exponent - The expression to raise this expression to the power of.\n   * @returns A new `Expression` representing the power operation.\n   */\n  pow(exponent: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the value of this expression raised to the power of a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Raise the value of the 'base' field to the power of 2.\n   * field(\"base\").pow(2);\n   * ```\n   *\n   * @param exponent - The constant value to raise this expression to the power of.\n   * @returns A new `Expression` representing the power operation.\n   */\n  pow(exponent: number): FunctionExpression;\n  pow(exponent: number | Expression): FunctionExpression {\n    return new FunctionExpression('pow', [this, valueToDefaultExpr(exponent)]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the nearest whole number.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field.\n   * field(\"price\").round();\n   * ```\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(): FunctionExpression;\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field to two decimal places.\n   * field(\"price\").round(2);\n   * ```\n   *\n   * @param decimalPlaces - A constant specifying the rounding precision in decimal places.\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(decimalPlaces: number): FunctionExpression;\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field to two decimal places.\n   * field(\"price\").round(constant(2));\n   * ```\n   *\n   * @param decimalPlaces - An expression specifying the rounding precision in decimal places.\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(decimalPlaces: Expression): FunctionExpression;\n  round(decimalPlaces?: number | Expression): FunctionExpression {\n    if (decimalPlaces === undefined) {\n      return new FunctionExpression('round', [this]);\n    } else {\n      return new FunctionExpression(\n        'round',\n        [this, valueToDefaultExpr(decimalPlaces)],\n        'round'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the collection ID from a path.\n   *\n   * @example\n   * ```typescript\n   * // Get the collection ID from a path.\n   * field(\"__path__\").collectionId();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n   */\n  collectionId(): FunctionExpression {\n    return new FunctionExpression('collection_id', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n   *\n   * @example\n   * ```typescript\n   * // Get the length of the 'name' field.\n   * field(\"name\").length();\n   *\n   * // Get the number of items in the 'cart' array.\n   * field(\"cart\").length();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n   */\n  length(): FunctionExpression {\n    return new FunctionExpression('length', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the natural logarithm of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the natural logarithm of the 'value' field.\n   * field(\"value\").ln();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the natural logarithm of the numeric value.\n   */\n  ln(): FunctionExpression {\n    return new FunctionExpression('ln', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the square root of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the square root of the 'value' field.\n   * field(\"value\").sqrt();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n   */\n  sqrt(): FunctionExpression {\n    return new FunctionExpression('sqrt', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses a string.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myString' field.\n   * field(\"myString\").stringReverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n   */\n  stringReverse(): FunctionExpression {\n    return new FunctionExpression('string_reverse', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the `elseValue` argument if this expression results in an absent value, else\n   * return the result of the this expression evaluation.\n   *\n   * @example\n   * ```typescript\n   * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n   * // if the field is absent.\n   * field(\"optional_field\").ifAbsent(\"default_value\")\n   * ```\n   *\n   * @param elseValue - The value that will be returned if this Expression evaluates to an absent value.\n   * @returns A new [Expression] representing the ifAbsent operation.\n   */\n  ifAbsent(elseValue: unknown): Expression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the `elseValue` argument if this expression results in an absent value, else\n   * return the result of this expression evaluation.\n   *\n   * ```typescript\n   * // Returns the value of the optional field 'optional_field', or if that is\n   * // absent, then returns the value of the field `\n   * field(\"optional_field\").ifAbsent(field('default_field'))\n   * ```\n   *\n   * @param elseExpression - The Expression that will be evaluated if this Expression evaluates to an absent value.\n   * @returns A new [Expression] representing the ifAbsent operation.\n   */\n  ifAbsent(elseExpression: unknown): Expression;\n\n  ifAbsent(elseValueOrExpression: Expression | unknown): Expression {\n    return new FunctionExpression(\n      'if_absent',\n      [this, valueToDefaultExpr(elseValueOrExpression)],\n      'ifAbsent'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that joins the elements of an array into a string.\n   *\n   * @example\n   * ```typescript\n   * // Join the elements of the 'tags' field with the delimiter from the 'separator' field.\n   * field(\"tags\").join(field(\"separator\"))\n   * ```\n   *\n   * @param delimiterExpression - The expression that evaluates to the delimiter string.\n   * @returns A new Expression representing the join operation.\n   */\n  join(delimiterExpression: Expression): Expression;\n\n  /**\n   * @beta\n   * Creates an expression that joins the elements of an array field into a string.\n   *\n   * @example\n   * ```typescript\n   * // Join the elements of the 'tags' field with a comma and space.\n   * field(\"tags\").join(\", \")\n   * ```\n   *\n   * @param delimiter - The string to use as a delimiter.\n   * @returns A new Expression representing the join operation.\n   */\n  join(delimiter: string): Expression;\n\n  join(delimeterValueOrExpression: string | Expression): Expression {\n    return new FunctionExpression(\n      'join',\n      [this, valueToDefaultExpr(delimeterValueOrExpression)],\n      'join'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the base-10 logarithm of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the base-10 logarithm of the 'value' field.\n   * field(\"value\").log10();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the base-10 logarithm of the numeric value.\n   */\n  log10(): FunctionExpression {\n    return new FunctionExpression('log10', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the sum of the elements in an array.\n   *\n   * @example\n   * ```typescript\n   * // Compute the sum of the elements in the 'scores' field.\n   * field(\"scores\").arraySum();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the sum of the elements in the array.\n   */\n  arraySum(): FunctionExpression {\n    return new FunctionExpression('sum', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that splits the result of this expression into an\n   * array of substrings based on the provided delimiter.\n   *\n   * @example\n   * ```typescript\n   * // Split the 'scoresCsv' field on delimiter ','\n   * field('scoresCsv').split(',')\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n   */\n  split(delimiter: string): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that splits the result of this expression into an\n   * array of substrings based on the provided delimiter.\n   *\n   * @example\n   * ```typescript\n   * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n   * field('scores').split(conditional(field('format').equal('csv'), constant(','), constant(':'))\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n   */\n  split(delimiter: Expression): FunctionExpression;\n  split(delimiter: string | Expression): FunctionExpression {\n    return new FunctionExpression('split', [\n      this,\n      valueToDefaultExpr(delimiter)\n    ]);\n  }\n\n  /**\n   * Creates an expression that truncates a timestamp to a specified granularity.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'createdAt' timestamp to the beginning of the day.\n   * field('createdAt').timestampTruncate('day')\n   * ```\n   *\n   * @param granularity - The granularity to truncate to.\n   * @param timezone - The timezone to use for truncation. Valid values are from\n   * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n   * @returns A new `Expression` representing the truncated timestamp.\n   */\n  timestampTruncate(\n    granularity: TimeGranularity,\n    timezone?: string | Expression\n  ): FunctionExpression;\n\n  /**\n   * Creates an expression that truncates a timestamp to a specified granularity.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n   * field('createdAt').timestampTruncate(field('granularity'))\n   * ```\n   *\n   * @param granularity - The granularity to truncate to.\n   * @param timezone - The timezone to use for truncation. Valid values are from\n   * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n   * @returns A new `Expression` representing the truncated timestamp.\n   */\n  timestampTruncate(\n    granularity: Expression,\n    timezone?: string | Expression\n  ): FunctionExpression;\n  timestampTruncate(\n    granularity: TimeGranularity | Expression,\n    timezone?: string | Expression\n  ): FunctionExpression {\n    const internalGranularity = isString(granularity)\n      ? granularity.toLowerCase()\n      : granularity;\n\n    const args = [this, valueToDefaultExpr(internalGranularity)];\n    if (timezone) {\n      args.push(valueToDefaultExpr(timezone));\n    }\n    return new FunctionExpression('timestamp_trunc', args);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the data type of this expression's result, as a string.\n   *\n   * @example\n   * ```typescript\n   * // Get the data type of the value in field 'title'\n   * field('title').type()\n   * ```\n   *\n   * @returns A new `Expression` representing the data type.\n   */\n  type(): FunctionExpression {\n    return new FunctionExpression('type', [this]);\n  }\n\n  // TODO(new-expression): Add new expression method definitions above this line\n\n  /**\n   * @beta\n   * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on this expression.\n   *\n   * @example\n   * ```typescript\n   * // Sort documents by the 'name' field in ascending order\n   * pipeline().collection(\"users\")\n   *   .sort(field(\"name\").ascending());\n   * ```\n   *\n   * @returns A new `Ordering` for ascending sorting.\n   */\n  ascending(): Ordering {\n    return ascending(this);\n  }\n\n  /**\n   * @beta\n   * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on this expression.\n   *\n   * @example\n   * ```typescript\n   * // Sort documents by the 'createdAt' field in descending order\n   * firestore.pipeline().collection(\"users\")\n   *   .sort(field(\"createdAt\").descending());\n   * ```\n   *\n   * @returns A new `Ordering` for descending sorting.\n   */\n  descending(): Ordering {\n    return descending(this);\n  }\n\n  /**\n   * @beta\n   * Assigns an alias to this expression.\n   *\n   * Aliases are useful for renaming fields in the output of a stage or for giving meaningful\n   * names to calculated values.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the total price and assign it the alias \"totalPrice\" and add it to the output.\n   * firestore.pipeline().collection(\"items\")\n   *   .addFields(field(\"price\").multiply(field(\"quantity\")).as(\"totalPrice\"));\n   * ```\n   *\n   * @param name - The alias to assign to this expression.\n   * @returns A new {@link @firebase/firestore/pipelines#AliasedExpression} that wraps this\n   *     expression and associates it with the provided alias.\n   */\n  as(name: string): AliasedExpression {\n    return new AliasedExpression(this, name, 'as');\n  }\n}\n\n/**\n * @beta\n * Specify time granularity for expressions.\n */\nexport type TimeGranularity =\n  | 'microsecond'\n  | 'millisecond'\n  | 'second'\n  | 'minute'\n  | 'hour'\n  | 'day'\n  | 'week'\n  | 'week(monday)'\n  | 'week(tuesday)'\n  | 'week(wednesday)'\n  | 'week(thursday)'\n  | 'week(friday)'\n  | 'week(saturday)'\n  | 'week(sunday)'\n  | 'isoWeek'\n  | 'month'\n  | 'quarter'\n  | 'year'\n  | 'isoYear';\n\n/**\n * @beta\n *\n * An interface that represents a selectable expression.\n */\nexport interface Selectable {\n  selectable: true;\n  /**\n   * @private\n   * @internal\n   */\n  readonly alias: string;\n  /**\n   * @private\n   * @internal\n   */\n  readonly expr: Expression;\n}\n\n/**\n * @beta\n *\n * A class that represents an aggregate function.\n */\nexport class AggregateFunction implements ProtoValueSerializable, UserData {\n  exprType: ExpressionType = 'AggregateFunction';\n\n  /**\n   * @internal\n   */\n  _methodName?: string;\n\n  constructor(private name: string, private params: Expression[]) {}\n\n  /**\n   * @internal\n   * @private\n   */\n  static _create(\n    name: string,\n    params: Expression[],\n    methodName: string\n  ): AggregateFunction {\n    const af = new AggregateFunction(name, params);\n    af._methodName = methodName;\n\n    return af;\n  }\n\n  /**\n   * @beta\n   * Assigns an alias to this AggregateFunction. The alias specifies the name that\n   * the aggregated value will have in the output document.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average price of all items and assign it the alias \"averagePrice\".\n   * firestore.pipeline().collection(\"items\")\n   *   .aggregate(field(\"price\").average().as(\"averagePrice\"));\n   * ```\n   *\n   * @param name - The alias to assign to this AggregateFunction.\n   * @returns A new {@link @firebase/firestore/pipelines#AliasedAggregate} that wraps this\n   *     AggregateFunction and associates it with the provided alias.\n   */\n  as(name: string): AliasedAggregate {\n    return new AliasedAggregate(this, name, 'as');\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      functionValue: {\n        name: this.name,\n        args: this.params.map(p => p._toProto(serializer))\n      }\n    };\n  }\n\n  _protoValueType = 'ProtoValue' as const;\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.params.forEach(expr => {\n      return expr._readUserData(context);\n    });\n  }\n}\n\n/**\n * @beta\n *\n * An AggregateFunction with alias.\n */\nexport class AliasedAggregate implements UserData {\n  constructor(\n    readonly aggregate: AggregateFunction,\n    readonly alias: string,\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.aggregate._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class AliasedExpression implements Selectable, UserData {\n  exprType: ExpressionType = 'AliasedExpression';\n  selectable = true as const;\n\n  constructor(\n    readonly expr: Expression,\n    readonly alias: string,\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.expr._readUserData(context);\n  }\n}\n\n/**\n * @internal\n */\nclass ListOfExprs extends Expression implements UserData {\n  expressionType: ExpressionType = 'ListOfExpressions';\n\n  constructor(\n    private exprs: Expression[],\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      arrayValue: {\n        values: this.exprs.map(p => p._toProto(serializer)!)\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.exprs.forEach((expr: Expression) => expr._readUserData(context));\n  }\n}\n\n/**\n * @beta\n *\n * Represents a reference to a field in a Firestore document, or outputs of a {@link @firebase/firestore/pipelines#Pipeline} stage.\n *\n * <p>Field references are used to access document field values in expressions and to specify fields\n * for sorting, filtering, and projecting data in Firestore pipelines.\n *\n * <p>You can create a `Field` instance using the static {@link @firebase/firestore/pipelines#field} method:\n *\n * @example\n * ```typescript\n * // Create a Field instance for the 'name' field\n * const nameField = field(\"name\");\n *\n * // Create a Field instance for a nested field 'address.city'\n * const cityField = field(\"address.city\");\n * ```\n */\nexport class Field extends Expression implements Selectable {\n  readonly expressionType: ExpressionType = 'Field';\n  selectable = true as const;\n\n  /**\n   * @internal\n   * @private\n   * @hideconstructor\n   * @param fieldPath\n   */\n  constructor(\n    private fieldPath: InternalFieldPath,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  get fieldName(): string {\n    return this.fieldPath.canonicalString();\n  }\n\n  get alias(): string {\n    return this.fieldName;\n  }\n\n  get expr(): Expression {\n    return this;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      fieldReferenceValue: this.fieldPath.canonicalString()\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {}\n}\n\n/**\n * @beta\n * Creates a {@link @firebase/firestore/pipelines#Field} instance representing the field at the given path.\n *\n * The path can be a simple field name (e.g., \"name\") or a dot-separated path to a nested field\n * (e.g., \"address.city\").\n *\n * @example\n * ```typescript\n * // Create a Field instance for the 'title' field\n * const titleField = field(\"title\");\n *\n * // Create a Field instance for a nested field 'author.firstName'\n * const authorFirstNameField = field(\"author.firstName\");\n * ```\n *\n * @param name - The path to the field.\n * @returns A new {@link @firebase/firestore/pipelines#Field} instance representing the specified field.\n */\nexport function field(name: string): Field;\n\n/**\n * @beta\n * Creates a {@link @firebase/firestore/pipelines#Field} instance representing the field at the given path.\n *\n * @param path - A FieldPath specifying the field.\n * @returns A new {@link @firebase/firestore/pipelines#Field} instance representing the specified field.\n */\nexport function field(path: FieldPath): Field;\nexport function field(nameOrPath: string | FieldPath): Field {\n  return _field(nameOrPath, 'field');\n}\n\nexport function _field(\n  nameOrPath: string | FieldPath,\n  methodName: string | undefined\n): Field {\n  if (typeof nameOrPath === 'string') {\n    if (DOCUMENT_KEY_NAME === nameOrPath) {\n      return new Field(documentIdFieldPath()._internalPath, methodName);\n    }\n    return new Field(fieldPathFromArgument('field', nameOrPath), methodName);\n  } else {\n    return new Field(nameOrPath._internalPath, methodName);\n  }\n}\n\n/**\n * @internal\n *\n * Represents a constant value that can be used in a Firestore pipeline expression.\n *\n * You can create a `Constant` instance using the static {@link @firebase/firestore/pipelines#field} method:\n *\n * @example\n * ```typescript\n * // Create a Constant instance for the number 10\n * const ten = constant(10);\n *\n * // Create a Constant instance for the string \"hello\"\n * const hello = constant(\"hello\");\n * ```\n */\nexport class Constant extends Expression {\n  readonly expressionType: ExpressionType = 'Constant';\n\n  private _protoValue?: ProtoValue;\n\n  /**\n   * @private\n   * @internal\n   * @hideconstructor\n   * @param value - The value of the constant.\n   */\n  constructor(\n    private value: unknown,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  static _fromProto(value: ProtoValue): Constant {\n    const result = new Constant(value, undefined);\n    result._protoValue = value;\n    return result;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(_: JsonProtoSerializer): ProtoValue {\n    hardAssert(\n      this._protoValue !== undefined,\n      0x00ed,\n      'Value of this constant has not been serialized to proto value'\n    );\n    return this._protoValue;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    if (isFirestoreValue(this._protoValue)) {\n      return;\n    } else {\n      this._protoValue = parseData(this.value, context)!;\n    }\n  }\n}\n\n/**\n * @beta\n * Creates a `Constant` instance for a number value.\n *\n * @param value - The number value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: number): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a string value.\n *\n * @param value - The string value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: string): Expression;\n\n/**\n * @beta\n * Creates a `BooleanExpression` instance for a boolean value.\n *\n * @param value - The boolean value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: boolean): BooleanExpression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a null value.\n *\n * @param value - The null value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: null): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a GeoPoint value.\n *\n * @param value - The GeoPoint value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: GeoPoint): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Timestamp value.\n *\n * @param value - The Timestamp value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Timestamp): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Date value.\n *\n * @param value - The Date value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Date): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Bytes value.\n *\n * @param value - The Bytes value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Bytes): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a DocumentReference value.\n *\n * @param value - The DocumentReference value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: DocumentReference): Expression;\n\n/**\n * Creates a `Constant` instance for a Firestore proto value.\n * For internal use only.\n * @private\n * @internal\n * @param value - The Firestore proto value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: ProtoValue): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a VectorValue value.\n *\n * @param value - The VectorValue value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: VectorValue): Expression;\n\nexport function constant(value: unknown): Expression | BooleanExpression {\n  return _constant(value, 'constant');\n}\n\n/**\n * @internal\n * @private\n * @param value\n * @param methodName\n */\nexport function _constant(\n  value: unknown,\n  methodName: string | undefined\n): Constant | BooleanExpression {\n  const c = new Constant(value, methodName);\n  if (typeof value === 'boolean') {\n    return new BooleanConstant(c);\n  } else {\n    return c;\n  }\n}\n\n/**\n * Internal only\n * @internal\n * @private\n */\nexport class MapValue extends Expression {\n  constructor(\n    private plainObject: Map<string, Expression>,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  expressionType: ExpressionType = 'Constant';\n\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.plainObject.forEach(expr => {\n      expr._readUserData(context);\n    });\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return toMapValue(serializer, this.plainObject);\n  }\n}\n\n/**\n * @beta\n *\n * This class defines the base class for Firestore {@link @firebase/firestore/pipelines#Pipeline} functions, which can be evaluated within pipeline\n * execution.\n *\n * Typically, you would not use this class or its children directly. Use either the functions like {@link @firebase/firestore/pipelines#and}, {@link @firebase/firestore/pipelines#(equal:1)},\n * or the methods on {@link @firebase/firestore/pipelines#Expression} ({@link @firebase/firestore/pipelines#Expression.(equal:1)}, {@link @firebase/firestore/pipelines#Expression.(lessThan:1)}, etc.) to construct new Function instances.\n */\nexport class FunctionExpression extends Expression {\n  readonly expressionType: ExpressionType = 'Function';\n\n  constructor(name: string, params: Expression[]);\n  constructor(\n    name: string,\n    params: Expression[],\n    _methodName: string | undefined\n  );\n  constructor(\n    private name: string,\n    private params: Expression[],\n    readonly _methodName?: string\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      functionValue: {\n        name: this.name,\n        args: this.params.map(p => p._toProto(serializer))\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.params.forEach(expr => {\n      return expr._readUserData(context);\n    });\n  }\n}\n\n/**\n * @beta\n *\n * An interface that represents a filter condition.\n */\nexport abstract class BooleanExpression extends Expression {\n  abstract get _expr(): Expression;\n\n  get _methodName(): string | undefined {\n    return this._expr._methodName;\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the count of input documents satisfying\n   * this boolean expression.\n   *\n   * @example\n   * ```typescript\n   * // Find the count of documents with a score greater than 90\n   * field(\"score\").greaterThan(90).countIf().as(\"highestScore\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'countIf' aggregation.\n   */\n  countIf(): AggregateFunction {\n    return AggregateFunction._create('count_if', [this], 'countIf');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that negates this boolean expression.\n   *\n   * @example\n   * ```typescript\n   * // Find documents where the 'tags' field does not contain 'completed'\n   * field(\"tags\").arrayContains(\"completed\").not();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the negated filter condition.\n   */\n  not(): BooleanExpression {\n    return new FunctionExpression('not', [this], 'not').asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates a conditional expression that evaluates to the 'then' expression\n   * if `this` expression evaluates to `true`,\n   * or evaluates to the 'else' expression if `this` expressions evaluates `false`.\n   *\n   * @example\n   * ```typescript\n   * // If 'age' is greater than 18, return \"Adult\"; otherwise, return \"Minor\".\n   * field(\"age\").greaterThanOrEqual(18).conditional(constant(\"Adult\"), constant(\"Minor\"));\n   * ```\n   *\n   * @param thenExpr - The expression to evaluate if the condition is true.\n   * @param elseExpr - The expression to evaluate if the condition is false.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the conditional expression.\n   */\n  conditional(thenExpr: Expression, elseExpr: Expression): FunctionExpression {\n    return new FunctionExpression(\n      'conditional',\n      [this, thenExpr, elseExpr],\n      'conditional'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error\n   * // but always returns a boolean expression.\n   * constant(50).divide('length').gt(1).ifError(constant(false));\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: BooleanExpression): BooleanExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error\n   * // but always returns a boolean expression.\n   * constant(50).divide('length').gt(1).ifError(false);\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: boolean): BooleanExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error.\n   * constant(50).divide('length').gt(1).ifError(constant(0));\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error.\n   * constant(50).divide('length').gt(1).ifError(0);\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: unknown): FunctionExpression;\n  ifError(catchValue: unknown): unknown {\n    const normalizedCatchValue = valueToDefaultExpr(catchValue);\n    const expr = new FunctionExpression(\n      'if_error',\n      [this, normalizedCatchValue],\n      'ifError'\n    );\n\n    return normalizedCatchValue instanceof BooleanExpression\n      ? expr.asBoolean()\n      : expr;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return this._expr._toProto(serializer);\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this._expr._readUserData(context);\n  }\n}\n\nexport class BooleanFunctionExpression extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Function';\n  constructor(readonly _expr: FunctionExpression) {\n    super();\n  }\n}\n\nexport class BooleanConstant extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Constant';\n  constructor(readonly _expr: Constant) {\n    super();\n  }\n}\n\nexport class BooleanField extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Field';\n  constructor(readonly _expr: Field) {\n    super();\n  }\n}\n\n/**\n * @beta\n * Creates an aggregation that counts the number of stage inputs where the provided\n * boolean expression evaluates to true.\n *\n * @example\n * ```typescript\n * // Count the number of documents where 'is_active' field equals true\n * countIf(field(\"is_active\").equal(true)).as(\"numActiveDocuments\");\n * ```\n *\n * @param booleanExpr - The boolean expression to evaluate on each input.\n * @returns A new `AggregateFunction` representing the 'countIf' aggregation.\n */\nexport function countIf(booleanExpr: BooleanExpression): AggregateFunction {\n  return booleanExpr.countIf();\n}\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index 1.\n * arrayGet('tags', 1);\n * ```\n *\n * @param arrayField - The name of the array field.\n * @param offset - The index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayField: string,\n  offset: number\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index specified by field\n * // 'favoriteTag'.\n * arrayGet('tags', field('favoriteTag'));\n * ```\n *\n * @param arrayField - The name of the array field.\n * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayField: string,\n  offsetExpr: Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index 1.\n * arrayGet(field('tags'), 1);\n * ```\n *\n * @param arrayExpression - An `Expression` evaluating to an array.\n * @param offset - The index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayExpression: Expression,\n  offset: number\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index specified by field\n * // 'favoriteTag'.\n * arrayGet(field('tags'), field('favoriteTag'));\n * ```\n *\n * @param arrayExpression - An `Expression` evaluating to an array.\n * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayExpression: Expression,\n  offsetExpr: Expression\n): FunctionExpression;\nexport function arrayGet(\n  array: Expression | string,\n  offset: Expression | number\n): FunctionExpression {\n  return fieldOrExpression(array).arrayGet(valueToDefaultExpr(offset));\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a given expression produces an error.\n *\n * @example\n * ```typescript\n * // Check if the result of a calculation is an error\n * isError(field(\"title\").arrayContains(1));\n * ```\n *\n * @param value - The expression to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isError' check.\n */\nexport function isError(value: Expression): BooleanExpression {\n  return value.isError().asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * This overload is useful when a BooleanExpression is required.\n *\n * @example\n * ```typescript\n * // Create an expression that protects against a divide by zero error\n * // but always returns a boolean expression.\n * ifError(constant(50).divide('length').gt(1), constant(false));\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchExpr - The catch expression that will be evaluated and\n * returned if the tryExpr produces an error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: BooleanExpression,\n  catchExpr: BooleanExpression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the first item in the title field arrays, or returns\n * // the entire title field if the array is empty or the field is another type.\n * ifError(field(\"title\").arrayGet(0), field(\"title\"));\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchExpr - The catch expression that will be evaluated and\n * returned if the tryExpr produces an error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: Expression,\n  catchExpr: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the first item in the title field arrays, or returns\n * // \"Default Title\"\n * ifError(field(\"title\").arrayGet(0), \"Default Title\");\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchValue - The value that will be returned if the tryExpr produces an\n * error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: Expression,\n  catchValue: unknown\n): FunctionExpression;\n\nexport function ifError(\n  tryExpr: Expression,\n  catchValue: unknown\n): FunctionExpression | BooleanExpression {\n  if (\n    tryExpr instanceof BooleanExpression &&\n    catchValue instanceof BooleanExpression\n  ) {\n    return tryExpr.ifError(catchValue).asBoolean();\n  } else {\n    return tryExpr.ifError(valueToDefaultExpr(catchValue));\n  }\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns `true` if a value is absent. Otherwise,\n * returns `false` even if the value is `null`.\n *\n * @example\n * ```typescript\n * // Check if the field `value` is absent.\n * isAbsent(field(\"value\"));\n * ```\n *\n * @param value - The expression to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isAbsent' check.\n */\nexport function isAbsent(value: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns `true` if a field is absent. Otherwise,\n * returns `false` even if the field value is `null`.\n *\n * @example\n * ```typescript\n * // Check if the field `value` is absent.\n * isAbsent(\"value\");\n * ```\n *\n * @param field - The field to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isAbsent' check.\n */\nexport function isAbsent(field: string): BooleanExpression;\nexport function isAbsent(value: Expression | string): BooleanExpression {\n  return fieldOrExpression(value).isAbsent();\n}\n\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map at the specified field name.\n *\n * @example\n * ```\n * // Removes the key 'city' field from the map in the address field of the input document.\n * mapRemove('address', 'city');\n * ```\n *\n * @param mapField - The name of a field containing a map value.\n * @param key - The name of the key to remove from the input map.\n */\nexport function mapRemove(mapField: string, key: string): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map produced by evaluating an expression.\n *\n * @example\n * ```\n * // Removes the key 'baz' from the input map.\n * mapRemove(map({foo: 'bar', baz: true}), 'baz');\n * @example\n * ```\n *\n * @param mapExpr - An expression return a map value.\n * @param key - The name of the key to remove from the input map.\n */\nexport function mapRemove(mapExpr: Expression, key: string): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map at the specified field name.\n *\n * @example\n * ```\n * // Removes the key 'city' field from the map in the address field of the input document.\n * mapRemove('address', constant('city'));\n * ```\n *\n * @param mapField - The name of a field containing a map value.\n * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n */\nexport function mapRemove(\n  mapField: string,\n  keyExpr: Expression\n): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map produced by evaluating an expression.\n *\n * @example\n * ```\n * // Removes the key 'baz' from the input map.\n * mapRemove(map({foo: 'bar', baz: true}), constant('baz'));\n * @example\n * ```\n *\n * @param mapExpr - An expression return a map value.\n * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n */\nexport function mapRemove(\n  mapExpr: Expression,\n  keyExpr: Expression\n): FunctionExpression;\n\nexport function mapRemove(\n  mapExpr: Expression | string,\n  stringExpr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(mapExpr).mapRemove(valueToDefaultExpr(stringExpr));\n}\n\n/**\n * @beta\n *\n * Creates an expression that merges multiple map values.\n *\n * @example\n * ```\n * // Merges the map in the settings field with, a map literal, and a map in\n * // that is conditionally returned by another expression\n * mapMerge('settings', { enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n * ```\n *\n * @param mapField - Name of a field containing a map value that will be merged.\n * @param secondMap - A required second map to merge. Represented as a literal or\n * an expression that returns a map.\n * @param otherMaps - Optional additional maps to merge. Each map is represented\n * as a literal or an expression that returns a map.\n */\nexport function mapMerge(\n  mapField: string,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that merges multiple map values.\n *\n * @example\n * ```\n * // Merges the map in the settings field with, a map literal, and a map in\n * // that is conditionally returned by another expression\n * mapMerge(field('settings'), { enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n * ```\n *\n * @param firstMap - An expression or literal map value that will be merged.\n * @param secondMap - A required second map to merge. Represented as a literal or\n * an expression that returns a map.\n * @param otherMaps - Optional additional maps to merge. Each map is represented\n * as a literal or an expression that returns a map.\n */\nexport function mapMerge(\n  firstMap: Record<string, unknown> | Expression,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression;\n\nexport function mapMerge(\n  firstMap: string | Record<string, unknown> | Expression,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression {\n  const secondMapExpr = valueToDefaultExpr(secondMap);\n  const otherMapExprs = otherMaps.map(valueToDefaultExpr);\n  return fieldOrExpression(firstMap).mapMerge(secondMapExpr, ...otherMapExprs);\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the document ID from a path.\n *\n * @example\n * ```typescript\n * // Get the document ID from a path.\n * documentId(myDocumentReference);\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n */\nexport function documentId(\n  documentPath: string | DocumentReference\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the document ID from a path.\n *\n * @example\n * ```typescript\n * // Get the document ID from a path.\n * documentId(field(\"__path__\"));\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n */\nexport function documentId(documentPathExpr: Expression): FunctionExpression;\n\nexport function documentId(\n  documentPath: Expression | string | DocumentReference\n): FunctionExpression {\n  // @ts-ignore\n  const documentPathExpr = valueToDefaultExpr(documentPath);\n  return documentPathExpr.documentId();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param field - The name of a field containing a string or byte array to compute the substring from.\n * @param position - Index of the first character of the substring.\n * @param length - Length of the substring.\n */\nexport function substring(\n  field: string,\n  position: number,\n  length?: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param input - An expression returning a string or byte array to compute the substring from.\n * @param position - Index of the first character of the substring.\n * @param length - Length of the substring.\n */\nexport function substring(\n  input: Expression,\n  position: number,\n  length?: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param field - The name of a field containing a string or byte array to compute the substring from.\n * @param position - An expression that returns the index of the first character of the substring.\n * @param length - An expression that returns the length of the substring.\n */\nexport function substring(\n  field: string,\n  position: Expression,\n  length?: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param input - An expression returning a string or byte array to compute the substring from.\n * @param position - An expression that returns the index of the first character of the substring.\n * @param length - An expression that returns the length of the substring.\n */\nexport function substring(\n  input: Expression,\n  position: Expression,\n  length?: Expression\n): FunctionExpression;\n\nexport function substring(\n  field: Expression | string,\n  position: Expression | number,\n  length?: Expression | number\n): FunctionExpression {\n  const fieldExpr = fieldOrExpression(field);\n  const positionExpr = valueToDefaultExpr(position);\n  const lengthExpr =\n    length === undefined ? undefined : valueToDefaultExpr(length);\n  return fieldExpr.substring(positionExpr, lengthExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that adds two expressions together.\n *\n * @example\n * ```typescript\n * // Add the value of the 'quantity' field and the 'reserve' field.\n * add(field(\"quantity\"), field(\"reserve\"));\n * ```\n *\n * @param first - The first expression to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the addition operation.\n */\nexport function add(\n  first: Expression,\n  second: Expression | unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a field's value to an expression.\n *\n * @example\n * ```typescript\n * // Add the value of the 'quantity' field and the 'reserve' field.\n * add(\"quantity\", field(\"reserve\"));\n * ```\n *\n * @param fieldName - The name of the field containing the value to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the addition operation.\n */\nexport function add(\n  fieldName: string,\n  second: Expression | unknown\n): FunctionExpression;\n\nexport function add(\n  first: Expression | string,\n  second: Expression | unknown\n): FunctionExpression {\n  return fieldOrExpression(first).add(valueToDefaultExpr(second));\n}\n\n/**\n * @beta\n *\n * Creates an expression that subtracts two expressions.\n *\n * @example\n * ```typescript\n * // Subtract the 'discount' field from the 'price' field\n * subtract(field(\"price\"), field(\"discount\"));\n * ```\n *\n * @param left - The expression to subtract from.\n * @param right - The expression to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  left: Expression,\n  right: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a constant value from an expression.\n *\n * @example\n * ```typescript\n * // Subtract the constant value 2 from the 'value' field\n * subtract(field(\"value\"), 2);\n * ```\n *\n * @param expression - The expression to subtract from.\n * @param value - The constant value to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  expression: Expression,\n  value: unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts an expression from a field's value.\n *\n * @example\n * ```typescript\n * // Subtract the 'discount' field from the 'price' field\n * subtract(\"price\", field(\"discount\"));\n * ```\n *\n * @param fieldName - The field name to subtract from.\n * @param expression - The expression to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  fieldName: string,\n  expression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a constant value from a field's value.\n *\n * @example\n * ```typescript\n * // Subtract 20 from the value of the 'total' field\n * subtract(\"total\", 20);\n * ```\n *\n * @param fieldName - The field name to subtract from.\n * @param value - The constant value to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(fieldName: string, value: unknown): FunctionExpression;\nexport function subtract(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.subtract(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that multiplies two expressions together.\n *\n * @example\n * ```typescript\n * // Multiply the 'quantity' field by the 'price' field\n * multiply(field(\"quantity\"), field(\"price\"));\n * ```\n *\n * @param first - The first expression to multiply.\n * @param second - The second expression or literal to multiply.\n * @param others - Optional additional expressions or literals to multiply.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the multiplication operation.\n */\nexport function multiply(\n  first: Expression,\n  second: Expression | unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that multiplies a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Multiply the 'quantity' field by the 'price' field\n * multiply(\"quantity\", field(\"price\"));\n * ```\n *\n * @param fieldName - The name of the field containing the value to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the multiplication operation.\n */\nexport function multiply(\n  fieldName: string,\n  second: Expression | unknown\n): FunctionExpression;\n\nexport function multiply(\n  first: Expression | string,\n  second: Expression | unknown\n): FunctionExpression {\n  return fieldOrExpression(first).multiply(valueToDefaultExpr(second));\n}\n\n/**\n * @beta\n *\n * Creates an expression that divides two expressions.\n *\n * @example\n * ```typescript\n * // Divide the 'total' field by the 'count' field\n * divide(field(\"total\"), field(\"count\"));\n * ```\n *\n * @param left - The expression to be divided.\n * @param right - The expression to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(left: Expression, right: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides an expression by a constant value.\n *\n * @example\n * ```typescript\n * // Divide the 'value' field by 10\n * divide(field(\"value\"), 10);\n * ```\n *\n * @param expression - The expression to be divided.\n * @param value - The constant value to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(\n  expression: Expression,\n  value: unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Divide the 'total' field by the 'count' field\n * divide(\"total\", field(\"count\"));\n * ```\n *\n * @param fieldName - The field name to be divided.\n * @param expressions - The expression to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(\n  fieldName: string,\n  expressions: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides a field's value by a constant value.\n *\n * @example\n * ```typescript\n * // Divide the 'value' field by 10\n * divide(\"value\", 10);\n * ```\n *\n * @param fieldName - The field name to be divided.\n * @param value - The constant value to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(fieldName: string, value: unknown): FunctionExpression;\nexport function divide(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.divide(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing two expressions.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 'field2'.\n * mod(field(\"field1\"), field(\"field2\"));\n * ```\n *\n * @param left - The dividend expression.\n * @param right - The divisor expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(left: Expression, right: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing an expression by a constant.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 5.\n * mod(field(\"field1\"), 5);\n * ```\n *\n * @param expression - The dividend expression.\n * @param value - The divisor constant.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(expression: Expression, value: unknown): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 'field2'.\n * mod(\"field1\", field(\"field2\"));\n * ```\n *\n * @param fieldName - The dividend field name.\n * @param expression - The divisor expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(\n  fieldName: string,\n  expression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing a field's value by a constant.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 5.\n * mod(\"field1\", 5);\n * ```\n *\n * @param fieldName - The dividend field name.\n * @param value - The divisor constant.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(fieldName: string, value: unknown): FunctionExpression;\nexport function mod(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.mod(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that creates a Firestore map value from an input object.\n *\n * @example\n * ```typescript\n * // Create a map from the input object and reference the 'baz' field value from the input document.\n * map({foo: 'bar', baz: Field.of('baz')}).as('data');\n * ```\n *\n * @param elements - The input map to evaluate in the expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the map function.\n */\nexport function map(elements: Record<string, unknown>): FunctionExpression {\n  return _map(elements, 'map');\n}\nexport function _map(\n  elements: Record<string, unknown>,\n  methodName: string | undefined\n): FunctionExpression {\n  const result: Expression[] = [];\n  for (const key in elements) {\n    if (Object.prototype.hasOwnProperty.call(elements, key)) {\n      const value = elements[key];\n      result.push(constant(key));\n      result.push(valueToDefaultExpr(value));\n    }\n  }\n  return new FunctionExpression('map', result, 'map');\n}\n\n/**\n * Internal use only\n * Converts a plainObject to a mapValue in the proto representation,\n * rather than a functionValue+map that is the result of the map(...) function.\n * This behaves different from constant(plainObject) because it\n * traverses the input object, converts values in the object to expressions,\n * and calls _readUserData on each of these expressions.\n * @private\n * @internal\n * @param plainObject\n */\nexport function _mapValue(plainObject: Record<string, unknown>): MapValue {\n  const result: Map<string, Expression> = new Map<string, Expression>();\n  for (const key in plainObject) {\n    if (Object.prototype.hasOwnProperty.call(plainObject, key)) {\n      const value = plainObject[key];\n      result.set(key, valueToDefaultExpr(value));\n    }\n  }\n  return new MapValue(result, undefined);\n}\n\n/**\n * @beta\n *\n * Creates an expression that creates a Firestore array value from an input array.\n *\n * @example\n * ```typescript\n * // Create an array value from the input array and reference the 'baz' field value from the input document.\n * array(['bar', Field.of('baz')]).as('foo');\n * ```\n *\n * @param elements - The input array to evaluate in the expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the array function.\n */\nexport function array(elements: unknown[]): FunctionExpression {\n  return _array(elements, 'array');\n}\nexport function _array(\n  elements: unknown[],\n  methodName: string | undefined\n): FunctionExpression {\n  return new FunctionExpression(\n    'array',\n    elements.map(element => valueToDefaultExpr(element)),\n    methodName\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if two expressions are equal.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to an expression\n * equal(field(\"age\"), field(\"minAge\").add(10));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(left: Expression, right: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to 21\n * equal(field(\"age\"), 21);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to the 'limit' field\n * equal(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'city' field is equal to string constant \"London\"\n * equal(\"city\", \"London\");\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(fieldName: string, value: unknown): BooleanExpression;\nexport function equal(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.equal(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if two expressions are not equal.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to field 'finalState'\n * notEqual(field(\"status\"), field(\"finalState\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to \"completed\"\n * notEqual(field(\"status\"), \"completed\");\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to the value of 'expectedStatus'\n * notEqual(\"status\", field(\"expectedStatus\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'country' field is not equal to \"USA\"\n * notEqual(\"country\", \"USA\");\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(fieldName: string, value: unknown): BooleanExpression;\nexport function notEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.notEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is less than the second expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than 30\n * lessThan(field(\"age\"), field(\"limit\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is less than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than 30\n * lessThan(field(\"age\"), 30);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than the 'limit' field\n * lessThan(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is less than 50\n * lessThan(\"price\", 50);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(fieldName: string, value: unknown): BooleanExpression;\nexport function lessThan(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.lessThan(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is less than or equal to the second\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to 20\n * lessThan(field(\"quantity\"), field(\"limit\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is less than or equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to 20\n * lessThan(field(\"quantity\"), 20);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n * Creates an expression that checks if a field's value is less than or equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to the 'limit' field\n * lessThan(\"quantity\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than or equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'score' field is less than or equal to 70\n * lessThan(\"score\", 70);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function lessThanOrEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.lessThanOrEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is greater than the second\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18\n * greaterThan(field(\"age\"), Constant(9).add(9));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is greater than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18\n * greaterThan(field(\"age\"), 18);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than an expression.\n *\n * @example\n * ```typescript\n * // Check if the value of field 'age' is greater than the value of field 'limit'\n * greaterThan(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is greater than 100\n * greaterThan(\"price\", 100);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function greaterThan(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.greaterThan(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is greater than or equal to the\n * second expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is greater than or equal to the field \"threshold\"\n * greaterThanOrEqual(field(\"quantity\"), field(\"threshold\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is greater than or equal to a constant\n * value.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is greater than or equal to 10\n * greaterThanOrEqual(field(\"quantity\"), 10);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than or equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the value of field 'age' is greater than or equal to the value of field 'limit'\n * greaterThanOrEqual(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The expression to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  fieldName: string,\n  value: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than or equal to a constant\n * value.\n *\n * @example\n * ```typescript\n * // Check if the 'score' field is greater than or equal to 80\n * greaterThanOrEqual(\"score\", 80);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function greaterThanOrEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.greaterThanOrEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that concatenates an array expression with other arrays.\n *\n * @example\n * ```typescript\n * // Combine the 'items' array with two new item arrays\n * arrayConcat(field(\"items\"), [field(\"newItems\"), field(\"otherItems\")]);\n * ```\n *\n * @param firstArray - The first array expression to concatenate to.\n * @param secondArray - The second array expression or array literal to concatenate to.\n * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated array.\n */\nexport function arrayConcat(\n  firstArray: Expression,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that concatenates a field's array value with other arrays.\n *\n * @example\n * ```typescript\n * // Combine the 'items' array with two new item arrays\n * arrayConcat(\"items\", [field(\"newItems\"), field(\"otherItems\")]);\n * ```\n *\n * @param firstArrayField - The first array to concatenate to.\n * @param secondArray - The second array expression or array literal to concatenate to.\n * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated array.\n */\nexport function arrayConcat(\n  firstArrayField: string,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression;\n\nexport function arrayConcat(\n  firstArray: Expression | string,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression {\n  const exprValues = otherArrays.map(element => valueToDefaultExpr(element));\n  return fieldOrExpression(firstArray).arrayConcat(\n    fieldOrExpression(secondArray),\n    ...exprValues\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains the value of field 'selectedColor'\n * arrayContains(field(\"colors\"), field(\"selectedColor\"));\n * ```\n *\n * @param array - The array expression to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  array: Expression,\n  element: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains \"red\"\n * arrayContains(field(\"colors\"), \"red\");\n * ```\n *\n * @param array - The array expression to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  array: Expression,\n  element: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains the value of field 'selectedColor'\n * arrayContains(\"colors\", field(\"selectedColor\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  fieldName: string,\n  element: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains a specific value.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains \"red\"\n * arrayContains(\"colors\", \"red\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  fieldName: string,\n  element: unknown\n): BooleanExpression;\nexport function arrayContains(\n  array: Expression | string,\n  element: unknown\n): BooleanExpression {\n  const arrayExpr = fieldOrExpression(array);\n  const elementExpr = valueToDefaultExpr(element);\n  return arrayExpr.arrayContains(elementExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'categories' array contains either values from field \"cate1\" or \"Science\"\n * arrayContainsAny(field(\"categories\"), [field(\"cate1\"), \"Science\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  array: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'groups' array contains either the value from the 'userGroup' field\n * // or the value \"guest\"\n * arrayContainsAny(\"categories\", [field(\"cate1\"), \"Science\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'categories' array contains either values from field \"cate1\" or \"Science\"\n * arrayContainsAny(field(\"categories\"), array([field(\"cate1\"), \"Science\"]));\n * ```\n *\n * @param array - The array expression to check.\n * @param values - An expression that evaluates to an array, whose elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  array: Expression,\n  values: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'groups' array contains either the value from the 'userGroup' field\n * // or the value \"guest\"\n * arrayContainsAny(\"categories\", array([field(\"cate1\"), \"Science\"]));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - An expression that evaluates to an array, whose elements to check for in the array field.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  fieldName: string,\n  values: Expression\n): BooleanExpression;\nexport function arrayContainsAny(\n  array: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(array).arrayContainsAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains all the specified elements.\n *\n * @example\n * ```typescript\n * // Check if the \"tags\" array contains all of the values: \"SciFi\", \"Adventure\", and the value from field \"tag1\"\n * arrayContainsAll(field(\"tags\"), [field(\"tag1\"), constant(\"SciFi\"), \"Adventure\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  array: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains all the specified values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'tags' array contains both of the values from field 'tag1', the value \"SciFi\", and \"Adventure\"\n * arrayContainsAll(\"tags\", [field(\"tag1\"), \"SciFi\", \"Adventure\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains all the specified elements.\n *\n * @example\n * ```typescript\n * // Check if the \"tags\" array contains all of the values: \"SciFi\", \"Adventure\", and the value from field \"tag1\"\n * arrayContainsAll(field(\"tags\"), [field(\"tag1\"), constant(\"SciFi\"), \"Adventure\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param arrayExpression - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  array: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains all the specified values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'tags' array contains both of the values from field 'tag1', the value \"SciFi\", and \"Adventure\"\n * arrayContainsAll(\"tags\", [field(\"tag1\"), \"SciFi\", \"Adventure\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param arrayExpression - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\nexport function arrayContainsAll(\n  array: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(array).arrayContainsAll(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of an array in a specified field.\n *\n * @example\n * ```typescript\n * // Get the number of items in field 'cart'\n * arrayLength('cart');\n * ```\n *\n * @param fieldName - The name of the field containing an array to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function arrayLength(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of an array expression.\n *\n * @example\n * ```typescript\n * // Get the number of items in the 'cart' array\n * arrayLength(field(\"cart\"));\n * ```\n *\n * @param array - The array expression to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function arrayLength(array: Expression): FunctionExpression;\nexport function arrayLength(array: Expression | string): FunctionExpression {\n  return fieldOrExpression(array).arrayLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression, when evaluated, is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(field(\"category\"), [constant(\"Electronics\"), field(\"primaryType\")]);\n * ```\n *\n * @param expression - The expression whose results to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  expression: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is equal to any of the provided values.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is set to a value in the disabledCategories field\n * equalAny(field(\"category\"), field('disabledCategories'));\n * ```\n *\n * @param expression - The expression whose results to compare.\n * @param arrayExpression - An expression that evaluates to an array, whose elements to check for equality to the input.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  expression: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(\"category\", [constant(\"Electronics\"), field(\"primaryType\")]);\n * ```\n *\n * @param fieldName - The field to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(\"category\", [\"Electronics\", field(\"primaryType\")]);\n * ```\n *\n * @param fieldName - The field to compare.\n * @param arrayExpression - An expression that evaluates to an array, whose elements to check for equality to the input field.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\nexport function equalAny(\n  element: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(element).equalAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n * notEqualAny(field(\"status\"), [\"pending\", field(\"rejectedStatus\")]);\n * ```\n *\n * @param element - The expression to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  element: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n * notEqualAny(\"status\", [constant(\"pending\"), field(\"rejectedStatus\")]);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of the field 'rejectedStatus'\n * notEqualAny(field(\"status\"), [\"pending\", field(\"rejectedStatus\")]);\n * ```\n *\n * @param element - The expression to compare.\n * @param arrayExpression - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  element: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to any of the values in the evaluated expression.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to any value in the field 'rejectedStatuses'\n * notEqualAny(\"status\", field(\"rejectedStatuses\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param arrayExpression - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\n\nexport function notEqualAny(\n  element: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(element).notEqualAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'XOR' (exclusive OR) operation on multiple BooleanExpressions.\n *\n * @example\n * ```typescript\n * // Check if only one of the conditions is true: 'age' greater than 18, 'city' is \"London\",\n * // or 'status' is \"active\".\n * const condition = xor(\n *     greaterThan(\"age\", 18),\n *     equal(\"city\", \"London\"),\n *     equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first condition.\n * @param second - The second condition.\n * @param additionalConditions - Additional conditions to 'XOR' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'XOR' operation.\n */\nexport function xor(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...additionalConditions: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'xor',\n    [first, second, ...additionalConditions],\n    'xor'\n  ).asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates a conditional expression that evaluates to a 'then' expression if a condition is true\n * and an 'else' expression if the condition is false.\n *\n * @example\n * ```typescript\n * // If 'age' is greater than 18, return \"Adult\"; otherwise, return \"Minor\".\n * conditional(\n *     greaterThan(\"age\", 18), constant(\"Adult\"), constant(\"Minor\"));\n * ```\n *\n * @param condition - The condition to evaluate.\n * @param thenExpr - The expression to evaluate if the condition is true.\n * @param elseExpr - The expression to evaluate if the condition is false.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the conditional expression.\n */\nexport function conditional(\n  condition: BooleanExpression,\n  thenExpr: Expression,\n  elseExpr: Expression\n): FunctionExpression {\n  return new FunctionExpression(\n    'conditional',\n    [condition, thenExpr, elseExpr],\n    'conditional'\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that negates a filter condition.\n *\n * @example\n * ```typescript\n * // Find documents where the 'completed' field is NOT true\n * not(equal(\"completed\", true));\n * ```\n *\n * @param booleanExpr - The filter condition to negate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the negated filter condition.\n */\nexport function not(booleanExpr: BooleanExpression): BooleanExpression {\n  return booleanExpr.not();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the largest value between multiple input\n * expressions or literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the largest value between the 'field1' field, the 'field2' field,\n * // and 1000\n * logicalMaximum(field(\"field1\"), field(\"field2\"), 1000);\n * ```\n *\n * @param first - The first operand expression.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n */\nexport function logicalMaximum(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the largest value between multiple input\n * expressions or literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the largest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMaximum(\"field1\", field(\"field2\"), 1000);\n * ```\n *\n * @param fieldName - The first operand field name.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n */\nexport function logicalMaximum(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function logicalMaximum(\n  first: Expression | string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return fieldOrExpression(first).logicalMaximum(\n    valueToDefaultExpr(second),\n    ...others.map(value => valueToDefaultExpr(value))\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the smallest value between multiple input\n * expressions and literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the smallest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMinimum(field(\"field1\"), field(\"field2\"), 1000);\n * ```\n *\n * @param first - The first operand expression.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n */\nexport function logicalMinimum(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the smallest value between a field's value\n * and other input expressions or literal values.\n * Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the smallest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMinimum(\"field1\", field(\"field2\"), 1000);\n * ```\n *\n * @param fieldName - The first operand field name.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n */\nexport function logicalMinimum(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function logicalMinimum(\n  first: Expression | string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return fieldOrExpression(first).logicalMinimum(\n    valueToDefaultExpr(second),\n    ...others.map(value => valueToDefaultExpr(value))\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field exists.\n *\n * @example\n * ```typescript\n * // Check if the document has a field named \"phoneNumber\"\n * exists(field(\"phoneNumber\"));\n * ```\n *\n * @param value - An expression evaluates to the name of the field to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'exists' check.\n */\nexport function exists(value: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field exists.\n *\n * @example\n * ```typescript\n * // Check if the document has a field named \"phoneNumber\"\n * exists(\"phoneNumber\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'exists' check.\n */\nexport function exists(fieldName: string): BooleanExpression;\nexport function exists(valueOrField: Expression | string): BooleanExpression {\n  return fieldOrExpression(valueOrField).exists();\n}\n\n/**\n * @beta\n *\n * Creates an expression that reverses a string.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * reverse(field(\"myString\"));\n * ```\n *\n * @param stringExpression - An expression evaluating to a string value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function reverse(stringExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that reverses a string value in the specified field.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * reverse(\"myString\");\n * ```\n *\n * @param field - The name of the field representing the string to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function reverse(field: string): FunctionExpression;\nexport function reverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).reverse();\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the byte length of a string in UTF-8, or just the length of a Blob.\n *\n * @example\n * ```typescript\n * // Calculate the length of the 'myString' field in bytes.\n * byteLength(field(\"myString\"));\n * ```\n *\n * @param expr - The expression representing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n */\nexport function byteLength(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a string represented by a field in UTF-8 bytes, or just the length of a Blob.\n *\n * @example\n * ```typescript\n * // Calculate the length of the 'myString' field in bytes.\n * byteLength(\"myString\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n */\nexport function byteLength(fieldName: string): FunctionExpression;\nexport function byteLength(expr: Expression | string): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.byteLength();\n}\n\n/**\n * @beta\n * Creates an expression that reverses an array.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myArray' field.\n * arrayReverse(\"myArray\");\n * ```\n *\n * @param fieldName - The name of the field to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n */\nexport function arrayReverse(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that reverses an array.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myArray' field.\n * arrayReverse(field(\"myArray\"));\n * ```\n *\n * @param arrayExpression - An expression evaluating to an array value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n */\nexport function arrayReverse(arrayExpression: Expression): FunctionExpression;\nexport function arrayReverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).arrayReverse();\n}\n\n/**\n * @beta\n * Creates an expression that computes e to the power of the expression's result.\n *\n * @example\n * ```typescript\n * // Compute e to the power of 2.\n * exp(constant(2));\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n */\nexport function exp(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes e to the power of the expression's result.\n *\n * @example\n * ```typescript\n * // Compute e to the power of the 'value' field.\n * exp('value');\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n */\nexport function exp(fieldName: string): FunctionExpression;\n\nexport function exp(\n  expressionOrFieldName: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expressionOrFieldName).exp();\n}\n\n/**\n * @beta\n * Creates an expression that computes the ceiling of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the ceiling of the 'price' field.\n * ceil(\"price\");\n * ```\n *\n * @param fieldName - The name of the field to compute the ceiling of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n */\nexport function ceil(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the ceiling of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the ceiling of the 'price' field.\n * ceil(field(\"price\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the ceiling will be computed for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n */\nexport function ceil(expression: Expression): FunctionExpression;\nexport function ceil(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).ceil();\n}\n\n/**\n * @beta\n * Creates an expression that computes the floor of a numeric value.\n *\n * @param expr - The expression to compute the floor of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n */\nexport function floor(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the floor of a numeric value.\n *\n * @param fieldName - The name of the field to compute the floor of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n */\nexport function floor(fieldName: string): FunctionExpression;\nexport function floor(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).floor();\n}\n\n/**\n * @beta\n * Creates an aggregation that counts the number of distinct values of a field.\n *\n * @param expr - The expression or field to count distinct values of.\n * @returns A new `AggregateFunction` representing the 'count_distinct' aggregation.\n */\nexport function countDistinct(expr: Expression | string): AggregateFunction {\n  return fieldOrExpression(expr).countDistinct();\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the character length of a string field in UTF8.\n *\n * @example\n * ```typescript\n * // Get the character length of the 'name' field in UTF-8.\n * strLength(\"name\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string.\n */\nexport function charLength(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the character length of a string expression in UTF-8.\n *\n * @example\n * ```typescript\n * // Get the character length of the 'name' field in UTF-8.\n * strLength(field(\"name\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string.\n */\nexport function charLength(stringExpression: Expression): FunctionExpression;\nexport function charLength(value: Expression | string): FunctionExpression {\n  const valueExpr = fieldOrExpression(value);\n  return valueExpr.charLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison against a\n * field.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(\"title\", \"%guide%\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(fieldName: string, pattern: string): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison against a\n * field.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(\"title\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(fieldName: string, pattern: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(field(\"title\"), \"%guide%\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(field(\"title\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function like(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.like(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified regular expression as\n * a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(\"description\", \"(?i)example\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  fieldName: string,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified regular expression as\n * a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(\"description\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  fieldName: string,\n  pattern: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified regular\n * expression as a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(field(\"description\"), \"(?i)example\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified regular\n * expression as a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(field(\"description\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function regexContains(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexContains(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field matches a specified regular expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(\"email\", \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  fieldName: string,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field matches a specified regular expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(\"email\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  fieldName: string,\n  pattern: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression matches a specified regular\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(field(\"email\"), \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n * ```\n *\n * @param stringExpression - The expression representing the string to match against.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression matches a specified regular\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(field(\"email\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to match against.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function regexMatch(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexMatch(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\".\n * stringContains(\"description\", \"example\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param substring - The substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  fieldName: string,\n  substring: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a substring specified by an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains the value of the 'keyword' field.\n * stringContains(\"description\", field(\"keyword\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param substring - The expression representing the substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  fieldName: string,\n  substring: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\".\n * stringContains(field(\"description\"), \"example\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param substring - The substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  stringExpression: Expression,\n  substring: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a substring specified by another expression.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains the value of the 'keyword' field.\n * stringContains(field(\"description\"), field(\"keyword\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param substring - The expression representing the substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  stringExpression: Expression,\n  substring: Expression\n): BooleanExpression;\nexport function stringContains(\n  left: Expression | string,\n  substring: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const substringExpr = valueToDefaultExpr(substring);\n  return leftExpr.stringContains(substringExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the 'name' field starts with \"Mr.\"\n * startsWith(\"name\", \"Mr.\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  fieldName: string,\n  prefix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the 'fullName' field starts with the value of the 'firstName' field\n * startsWith(\"fullName\", field(\"firstName\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param prefix - The expression representing the prefix.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  fieldName: string,\n  prefix: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields starts with \"Mr.\"\n * startsWith(field(\"fullName\"), \"Mr.\");\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  stringExpression: Expression,\n  prefix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields starts with \"Mr.\"\n * startsWith(field(\"fullName\"), field(\"prefix\"));\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  stringExpression: Expression,\n  prefix: Expression\n): BooleanExpression;\nexport function startsWith(\n  expr: Expression | string,\n  prefix: Expression | string\n): BooleanExpression {\n  return fieldOrExpression(expr).startsWith(valueToDefaultExpr(prefix));\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the 'filename' field ends with \".txt\"\n * endsWith(\"filename\", \".txt\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(fieldName: string, suffix: string): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the 'url' field ends with the value of the 'extension' field\n * endsWith(\"url\", field(\"extension\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param suffix - The expression representing the postfix.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  fieldName: string,\n  suffix: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields ends with \"Jr.\"\n * endsWith(field(\"fullName\"), \"Jr.\");\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  stringExpression: Expression,\n  suffix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields ends with \"Jr.\"\n * endsWith(field(\"fullName\"), constant(\"Jr.\"));\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  stringExpression: Expression,\n  suffix: Expression\n): BooleanExpression;\nexport function endsWith(\n  expr: Expression | string,\n  suffix: Expression | string\n): BooleanExpression {\n  return fieldOrExpression(expr).endsWith(valueToDefaultExpr(suffix));\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a string field to lowercase.\n *\n * @example\n * ```typescript\n * // Convert the 'name' field to lowercase\n * toLower(\"name\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the lowercase string.\n */\nexport function toLower(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a string expression to lowercase.\n *\n * @example\n * ```typescript\n * // Convert the 'name' field to lowercase\n * toLower(field(\"name\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to convert to lowercase.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the lowercase string.\n */\nexport function toLower(stringExpression: Expression): FunctionExpression;\nexport function toLower(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).toLower();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a string field to uppercase.\n *\n * @example\n * ```typescript\n * // Convert the 'title' field to uppercase\n * toUpper(\"title\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the uppercase string.\n */\nexport function toUpper(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a string expression to uppercase.\n *\n * @example\n * ```typescript\n * // Convert the 'title' field to uppercase\n * toUppercase(field(\"title\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to convert to uppercase.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the uppercase string.\n */\nexport function toUpper(stringExpression: Expression): FunctionExpression;\nexport function toUpper(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).toUpper();\n}\n\n/**\n * @beta\n *\n * Creates an expression that removes leading and trailing whitespace from a string or byte array.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the 'userInput' field\n * trim(\"userInput\");\n *\n * // Trim quotes from the 'userInput' field\n * trim(\"userInput\", '\"');\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n * trimmed from the input. If not specified, then whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string.\n */\nexport function trim(\n  fieldName: string,\n  valueToTrim?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that removes leading and trailing characters from a string or byte array expression.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the 'userInput' field\n * trim(field(\"userInput\"));\n *\n * // Trim quotes from the 'userInput' field\n * trim(field(\"userInput\"), '\"');\n * ```\n *\n * @param stringExpression - The expression representing the string or byte array to trim.\n * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n * trimmed from the input. If not specified, then whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string or byte array.\n */\nexport function trim(\n  stringExpression: Expression,\n  valueToTrim?: string | Expression\n): FunctionExpression;\nexport function trim(\n  expr: Expression | string,\n  valueToTrim?: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(expr).trim(valueToTrim);\n}\n\n/**\n * @beta\n *\n * Creates an expression that concatenates string functions, fields or constants together.\n *\n * @example\n * ```typescript\n * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n * stringConcat(\"firstName\", \" \", field(\"lastName\"));\n * ```\n *\n * @param fieldName - The field name containing the initial string value.\n * @param secondString - An expression or string literal to concatenate.\n * @param otherStrings - Optional additional expressions or literals (typically strings) to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated string.\n */\nexport function stringConcat(\n  fieldName: string,\n  secondString: Expression | string,\n  ...otherStrings: Array<Expression | string>\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that concatenates string expressions together.\n *\n * @example\n * ```typescript\n * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n * stringConcat(field(\"firstName\"), \" \", field(\"lastName\"));\n * ```\n *\n * @param firstString - The initial string expression to concatenate to.\n * @param secondString - An expression or string literal to concatenate.\n * @param otherStrings - Optional additional expressions or literals (typically strings) to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated string.\n */\nexport function stringConcat(\n  firstString: Expression,\n  secondString: Expression | string,\n  ...otherStrings: Array<Expression | string>\n): FunctionExpression;\nexport function stringConcat(\n  first: string | Expression,\n  second: string | Expression,\n  ...elements: Array<string | Expression>\n): FunctionExpression {\n  return fieldOrExpression(first).stringConcat(\n    valueToDefaultExpr(second),\n    ...elements.map(valueToDefaultExpr)\n  );\n}\n\n/**\n * @beta\n *\n * Accesses a value from a map (object) field using the provided key.\n *\n * @example\n * ```typescript\n * // Get the 'city' value from the 'address' map field\n * mapGet(\"address\", \"city\");\n * ```\n *\n * @param fieldName - The field name of the map field.\n * @param subField - The key to access in the map.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the value associated with the given key in the map.\n */\nexport function mapGet(fieldName: string, subField: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Accesses a value from a map (object) expression using the provided key.\n *\n * @example\n * ```typescript\n * // Get the 'city' value from the 'address' map field\n * mapGet(field(\"address\"), \"city\");\n * ```\n *\n * @param mapExpression - The expression representing the map.\n * @param subField - The key to access in the map.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the value associated with the given key in the map.\n */\nexport function mapGet(\n  mapExpression: Expression,\n  subField: string\n): FunctionExpression;\nexport function mapGet(\n  fieldOrExpr: string | Expression,\n  subField: string\n): FunctionExpression {\n  return fieldOrExpression(fieldOrExpr).mapGet(subField);\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that counts the total number of stage inputs.\n *\n * @example\n * ```typescript\n * // Count the total number of input documents\n * countAll().as(\"totalDocument\");\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'countAll' aggregation.\n */\nexport function countAll(): AggregateFunction {\n  return AggregateFunction._create('count', [], 'count');\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that counts the number of stage inputs with valid evaluations of the\n * provided expression.\n *\n * @example\n * ```typescript\n * // Count the number of items where the price is greater than 10\n * count(field(\"price\").greaterThan(10)).as(\"expensiveItemCount\");\n * ```\n *\n * @param expression - The expression to count.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'count' aggregation.\n */\nexport function count(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n * Creates an aggregation that counts the number of stage inputs where the input field exists.\n *\n * @example\n * ```typescript\n * // Count the total number of products\n * count(\"productId\").as(\"totalProducts\");\n * ```\n *\n * @param fieldName - The name of the field to count.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'count' aggregation.\n */\nexport function count(fieldName: string): AggregateFunction;\nexport function count(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).count();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the sum of values from an expression across multiple\n * stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the total revenue from a set of orders\n * sum(field(\"orderAmount\")).as(\"totalRevenue\");\n * ```\n *\n * @param expression - The expression to sum up.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'sum' aggregation.\n */\nexport function sum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the sum of a field's values across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Calculate the total revenue from a set of orders\n * sum(\"orderAmount\").as(\"totalRevenue\");\n * ```\n *\n * @param fieldName - The name of the field containing numeric values to sum up.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'sum' aggregation.\n */\nexport function sum(fieldName: string): AggregateFunction;\nexport function sum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).sum();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the average (mean) of values from an expression across\n * multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the average age of users\n * average(field(\"age\")).as(\"averageAge\");\n * ```\n *\n * @param expression - The expression representing the values to average.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'average' aggregation.\n */\nexport function average(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the average (mean) of a field's values across multiple\n * stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the average age of users\n * average(\"age\").as(\"averageAge\");\n * ```\n *\n * @param fieldName - The name of the field containing numeric values to average.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'average' aggregation.\n */\nexport function average(fieldName: string): AggregateFunction;\nexport function average(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).average();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the minimum value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the lowest price of all products\n * minimum(field(\"price\")).as(\"lowestPrice\");\n * ```\n *\n * @param expression - The expression to find the minimum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'minimum' aggregation.\n */\nexport function minimum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the minimum value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the lowest price of all products\n * minimum(\"price\").as(\"lowestPrice\");\n * ```\n *\n * @param fieldName - The name of the field to find the minimum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'minimum' aggregation.\n */\nexport function minimum(fieldName: string): AggregateFunction;\nexport function minimum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).minimum();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the maximum value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the highest score in a leaderboard\n * maximum(field(\"score\")).as(\"highestScore\");\n * ```\n *\n * @param expression - The expression to find the maximum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'maximum' aggregation.\n */\nexport function maximum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the maximum value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the highest score in a leaderboard\n * maximum(\"score\").as(\"highestScore\");\n * ```\n *\n * @param fieldName - The name of the field to find the maximum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'maximum' aggregation.\n */\nexport function maximum(fieldName: string): AggregateFunction;\nexport function maximum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).maximum();\n}\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a field's vector value and a literal vector value.\n *\n * @example\n * ```typescript\n * // Calculate the Cosine distance between the 'location' field and a target location\n * cosineDistance(\"location\", [37.7749, -122.4194]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles) or {@link VectorValue} to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n * cosineDistance(\"userVector\", field(\"itemVector\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a vector expression and a vector literal.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'location' field and a target location\n * cosineDistance(field(\"location\"), [37.7749, -122.4194]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n * cosineDistance(field(\"userVector\"), field(\"itemVector\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function cosineDistance(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.cosineDistance(expr2);\n}\n\n/**\n * @beta\n *\n * Calculates the dot product between a field's vector value and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the dot product distance between a feature vector and a target vector\n * dotProduct(\"features\", [0.5, 0.8, 0.2]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles or VectorValue) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the dot product distance between two document vectors: 'docVector1' and 'docVector2'\n * dotProduct(\"docVector1\", field(\"docVector2\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between a vector expression and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the dot product between a feature vector and a target vector\n * dotProduct(field(\"features\"), [0.5, 0.8, 0.2]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to calculate with.\n * @param vector - The other vector (as an array of doubles or VectorValue) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the dot product between two document vectors: 'docVector1' and 'docVector2'\n * dotProduct(field(\"docVector1\"), field(\"docVector2\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to calculate with.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function dotProduct(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.dotProduct(expr2);\n}\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a field's vector value and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between the 'location' field and a target location\n * euclideanDistance(\"location\", [37.7749, -122.4194]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between two vector fields: 'pointA' and 'pointB'\n * euclideanDistance(\"pointA\", field(\"pointB\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a vector expression and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between the 'location' field and a target location\n *\n * euclideanDistance(field(\"location\"), [37.7749, -122.4194]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between two vector fields: 'pointA' and 'pointB'\n * euclideanDistance(field(\"pointA\"), field(\"pointB\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function euclideanDistance(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.euclideanDistance(expr2);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a Firestore Vector.\n *\n * @example\n * ```typescript\n * // Get the vector length (dimension) of the field 'embedding'.\n * vectorLength(field(\"embedding\"));\n * ```\n *\n * @param vectorExpression - The expression representing the Firestore Vector.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function vectorLength(vectorExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a Firestore Vector represented by a field.\n *\n * @example\n * ```typescript\n * // Get the vector length (dimension) of the field 'embedding'.\n * vectorLength(\"embedding\");\n * ```\n *\n * @param fieldName - The name of the field representing the Firestore Vector.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function vectorLength(fieldName: string): FunctionExpression;\nexport function vectorLength(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).vectorLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'microseconds' field as microseconds since epoch.\n * unixMicrosToTimestamp(field(\"microseconds\"));\n * ```\n *\n * @param expr - The expression representing the number of microseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMicrosToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'microseconds' field as microseconds since epoch.\n * unixMicrosToTimestamp(\"microseconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of microseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMicrosToTimestamp(fieldName: string): FunctionExpression;\nexport function unixMicrosToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expr).unixMicrosToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to microseconds since epoch.\n * timestampToUnixMicros(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n */\nexport function timestampToUnixMicros(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to microseconds since epoch.\n * timestampToUnixMicros(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n */\nexport function timestampToUnixMicros(fieldName: string): FunctionExpression;\nexport function timestampToUnixMicros(\n  expr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expr).timestampToUnixMicros();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'milliseconds' field as milliseconds since epoch.\n * unixMillisToTimestamp(field(\"milliseconds\"));\n * ```\n *\n * @param expr - The expression representing the number of milliseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMillisToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'milliseconds' field as milliseconds since epoch.\n * unixMillisToTimestamp(\"milliseconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of milliseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMillisToTimestamp(fieldName: string): FunctionExpression;\nexport function unixMillisToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.unixMillisToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to milliseconds since epoch.\n * timestampToUnixMillis(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n */\nexport function timestampToUnixMillis(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to milliseconds since epoch.\n * timestampToUnixMillis(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n */\nexport function timestampToUnixMillis(fieldName: string): FunctionExpression;\nexport function timestampToUnixMillis(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.timestampToUnixMillis();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'seconds' field as seconds since epoch.\n * unixSecondsToTimestamp(field(\"seconds\"));\n * ```\n *\n * @param expr - The expression representing the number of seconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixSecondsToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'seconds' field as seconds since epoch.\n * unixSecondsToTimestamp(\"seconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of seconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixSecondsToTimestamp(fieldName: string): FunctionExpression;\nexport function unixSecondsToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.unixSecondsToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to seconds since epoch.\n * timestampToUnixSeconds(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n */\nexport function timestampToUnixSeconds(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to seconds since epoch.\n * timestampToUnixSeconds(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n */\nexport function timestampToUnixSeconds(fieldName: string): FunctionExpression;\nexport function timestampToUnixSeconds(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.timestampToUnixSeconds();\n}\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp.\n *\n * @example\n * ```typescript\n * // Add some duration determined by field 'unit' and 'amount' to the 'timestamp' field.\n * timestampAdd(field(\"timestamp\"), field(\"unit\"), field(\"amount\"));\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n * @param amount - The expression evaluates to amount of the unit.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  timestamp: Expression,\n  unit: Expression,\n  amount: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp.\n *\n * @example\n * ```typescript\n * // Add 1 day to the 'timestamp' field.\n * timestampAdd(field(\"timestamp\"), \"day\", 1);\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  timestamp: Expression,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp represented by a field.\n *\n * @example\n * ```typescript\n * // Add 1 day to the 'timestamp' field.\n * timestampAdd(\"timestamp\", \"day\", 1);\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  fieldName: string,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\nexport function timestampAdd(\n  timestamp: Expression | string,\n  unit:\n    | Expression\n    | 'microsecond'\n    | 'millisecond'\n    | 'second'\n    | 'minute'\n    | 'hour'\n    | 'day',\n  amount: Expression | number\n): FunctionExpression {\n  const normalizedTimestamp = fieldOrExpression(timestamp);\n  const normalizedUnit = valueToDefaultExpr(unit);\n  const normalizedAmount = valueToDefaultExpr(amount);\n  return normalizedTimestamp.timestampAdd(normalizedUnit, normalizedAmount);\n}\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp.\n *\n * @example\n * ```typescript\n * // Subtract some duration determined by field 'unit' and 'amount' from the 'timestamp' field.\n * timestampSubtract(field(\"timestamp\"), field(\"unit\"), field(\"amount\"));\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n * @param amount - The expression evaluates to amount of the unit.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  timestamp: Expression,\n  unit: Expression,\n  amount: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp.\n *\n * @example\n * ```typescript\n * // Subtract 1 day from the 'timestamp' field.\n * timestampSubtract(field(\"timestamp\"), \"day\", 1);\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  timestamp: Expression,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp represented by a field.\n *\n * @example\n * ```typescript\n * // Subtract 1 day from the 'timestamp' field.\n * timestampSubtract(\"timestamp\", \"day\", 1);\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  fieldName: string,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\nexport function timestampSubtract(\n  timestamp: Expression | string,\n  unit:\n    | Expression\n    | 'microsecond'\n    | 'millisecond'\n    | 'second'\n    | 'minute'\n    | 'hour'\n    | 'day',\n  amount: Expression | number\n): FunctionExpression {\n  const normalizedTimestamp = fieldOrExpression(timestamp);\n  const normalizedUnit = valueToDefaultExpr(unit);\n  const normalizedAmount = valueToDefaultExpr(amount);\n  return normalizedTimestamp.timestampSubtract(\n    normalizedUnit,\n    normalizedAmount\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that evaluates to the current server timestamp.\n *\n * @example\n * ```typescript\n * // Get the current server timestamp\n * currentTimestamp()\n * ```\n *\n * @returns A new Expression representing the current server timestamp.\n */\nexport function currentTimestamp(): FunctionExpression {\n  return new FunctionExpression('current_timestamp', [], 'currentTimestamp');\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'AND' operation on multiple filter conditions.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18 AND the 'city' field is \"London\" AND\n * // the 'status' field is \"active\"\n * const condition = and(greaterThan(\"age\", 18), equal(\"city\", \"London\"), equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first filter condition.\n * @param second - The second filter condition.\n * @param more - Additional filter conditions to 'AND' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'AND' operation.\n */\nexport function and(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...more: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'and',\n    [first, second, ...more],\n    'and'\n  ).asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'OR' operation on multiple filter conditions.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18 OR the 'city' field is \"London\" OR\n * // the 'status' field is \"active\"\n * const condition = or(greaterThan(\"age\", 18), equal(\"city\", \"London\"), equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first filter condition.\n * @param second - The second filter condition.\n * @param more - Additional filter conditions to 'OR' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'OR' operation.\n */\nexport function or(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...more: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'or',\n    [first, second, ...more],\n    'xor'\n  ).asBoolean();\n}\n\n/**\n * @beta\n * Creates an expression that returns the value of the base expression raised to the power of the exponent expression.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of the 'exponent' field.\n * pow(field(\"base\"), field(\"exponent\"));\n * ```\n *\n * @param base - The expression to raise to the power of the exponent.\n * @param exponent - The expression to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: Expression, exponent: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base expression raised to the power of the exponent.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of 2.\n * pow(field(\"base\"), 2);\n * ```\n *\n * @param base - The expression to raise to the power of the exponent.\n * @param exponent - The constant value to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: Expression, exponent: number): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base field raised to the power of the exponent expression.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of the 'exponent' field.\n * pow(\"base\", field(\"exponent\"));\n * ```\n *\n * @param base - The name of the field to raise to the power of the exponent.\n * @param exponent - The expression to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: string, exponent: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base field raised to the power of the exponent.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of 2.\n * pow(\"base\", 2);\n * ```\n *\n * @param base - The name of the field to raise to the power of the exponent.\n * @param exponent - The constant value to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: string, exponent: number): FunctionExpression;\nexport function pow(\n  base: Expression | string,\n  exponent: Expression | number\n): FunctionExpression {\n  return fieldOrExpression(base).pow(exponent as number);\n}\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the nearest whole number.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field.\n * round(\"price\");\n * ```\n *\n * @param fieldName - The name of the field to round.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the nearest whole number.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field.\n * round(field(\"price\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be rounded.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field to two decimal places.\n * round(\"price\", 2);\n * ```\n *\n * @param fieldName - The name of the field to round.\n * @param decimalPlaces - A constant or expression specifying the rounding precision in decimal places.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(\n  fieldName: string,\n  decimalPlaces: number | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field to two decimal places.\n * round(field(\"price\"), constant(2));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be rounded.\n * @param decimalPlaces - A constant or expression specifying the rounding precision in decimal places.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(\n  expression: Expression,\n  decimalPlaces: number | Expression\n): FunctionExpression;\nexport function round(\n  expr: Expression | string,\n  decimalPlaces?: number | Expression\n): FunctionExpression {\n  if (decimalPlaces === undefined) {\n    return fieldOrExpression(expr).round();\n  } else {\n    return fieldOrExpression(expr).round(valueToDefaultExpr(decimalPlaces));\n  }\n}\n\n/**\n * @beta\n * Creates an expression that returns the collection ID from a path.\n *\n * @example\n * ```typescript\n * // Get the collection ID from a path.\n * collectionId(\"__name__\");\n * ```\n *\n * @param fieldName - The name of the field to get the collection ID from.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n */\nexport function collectionId(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the collection ID from a path.\n *\n * @example\n * ```typescript\n * // Get the collection ID from a path.\n * collectionId(field(\"__name__\"));\n * ```\n *\n * @param expression - An expression evaluating to a path, which the collection ID will be extracted from.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n */\nexport function collectionId(expression: Expression): FunctionExpression;\nexport function collectionId(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).collectionId();\n}\n\n/**\n * @beta\n * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n *\n * @example\n * ```typescript\n * // Get the length of the 'name' field.\n * length(\"name\");\n *\n * // Get the number of items in the 'cart' array.\n * length(\"cart\");\n * ```\n *\n * @param fieldName - The name of the field to calculate the length of.\n * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n */\nexport function length(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n *\n * @example\n * ```typescript\n * // Get the length of the 'name' field.\n * length(field(\"name\"));\n *\n * // Get the number of items in the 'cart' array.\n * length(field(\"cart\"));\n * ```\n *\n * @param expression - An expression evaluating to a string, array, map, vector, or bytes, which the length will be calculated for.\n * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n */\nexport function length(expression: Expression): FunctionExpression;\nexport function length(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).length();\n}\n\n/**\n * @beta\n * Creates an expression that computes the natural logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the natural logarithm of the 'value' field.\n * ln(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the natural logarithm of.\n * @returns A new `Expression` representing the natural logarithm of the numeric value.\n */\nexport function ln(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the natural logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the natural logarithm of the 'value' field.\n * ln(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the natural logarithm will be computed for.\n * @returns A new `Expression` representing the natural logarithm of the numeric value.\n */\nexport function ln(expression: Expression): FunctionExpression;\nexport function ln(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).ln();\n}\n\n/**\n * @beta\n * Creates an expression that computes the logarithm of an expression to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with base 10.\n * log(field(\"value\"), 10);\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the logarithm will be computed for.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(expression: Expression, base: number): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of an expression to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with the base in the 'base' field.\n * log(field(\"value\"), field(\"base\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the logarithm will be computed for.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(\n  expression: Expression,\n  base: Expression\n): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of a field to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with base 10.\n * log(\"value\", 10);\n * ```\n *\n * @param fieldName - The name of the field to compute the logarithm of.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(fieldName: string, base: number): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of a field to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with the base in the 'base' field.\n * log(\"value\", field(\"base\"));\n * ```\n *\n * @param fieldName - The name of the field to compute the logarithm of.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(fieldName: string, base: Expression): FunctionExpression;\nexport function log(\n  expr: Expression | string,\n  base: number | Expression\n): FunctionExpression {\n  return new FunctionExpression('log', [\n    fieldOrExpression(expr),\n    valueToDefaultExpr(base)\n  ]);\n}\n\n/**\n * @beta\n * Creates an expression that computes the square root of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the square root of the 'value' field.\n * sqrt(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the square root will be computed for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n */\nexport function sqrt(expression: Expression): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the square root of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the square root of the 'value' field.\n * sqrt(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the square root of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n */\nexport function sqrt(fieldName: string): FunctionExpression;\nexport function sqrt(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).sqrt();\n}\n\n/**\n * @beta\n * Creates an expression that reverses a string.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * strReverse(field(\"myString\"));\n * ```\n *\n * @param stringExpression - An expression evaluating to a string value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function stringReverse(stringExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that reverses a string value in the specified field.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * strReverse(\"myString\");\n * ```\n *\n * @param field - The name of the field representing the string to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function stringReverse(field: string): FunctionExpression;\nexport function stringReverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).stringReverse();\n}\n\n/**\n * @beta\n * Creates an expression that concatenates strings, arrays, or blobs. Types cannot be mixed.\n *\n * @example\n * ```typescript\n * // Concatenate the 'firstName' and 'lastName' fields with a space in between.\n * concat(field(\"firstName\"), \" \", field(\"lastName\"))\n * ```\n *\n * @param first - The first expressions to concatenate.\n * @param second - The second literal or expression to concatenate.\n * @param others - Additional literals or expressions to concatenate.\n * @returns A new `Expression` representing the concatenation.\n */\nexport function concat(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that concatenates strings, arrays, or blobs. Types cannot be mixed.\n *\n * @example\n * ```typescript\n * // Concatenate a field with a literal string.\n * concat(field(\"firstName\"), \"Doe\")\n * ```\n *\n * @param fieldName - The name of a field to concatenate.\n * @param second - The second literal or expression to concatenate.\n * @param others - Additional literal or expressions to concatenate.\n * @returns A new `Expression` representing the concatenation.\n */\nexport function concat(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function concat(\n  fieldNameOrExpression: string | Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return new FunctionExpression('concat', [\n    fieldOrExpression(fieldNameOrExpression),\n    valueToDefaultExpr(second),\n    ...others.map(valueToDefaultExpr)\n  ]);\n}\n\n/**\n * @beta\n * Creates an expression that computes the absolute value of a numeric value.\n *\n * @param expr - The expression to compute the absolute value of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n */\nexport function abs(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the absolute value of a numeric value.\n *\n * @param fieldName - The field to compute the absolute value of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n */\nexport function abs(fieldName: string): FunctionExpression;\nexport function abs(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).abs();\n}\n\n/**\n * @beta\n * Creates an expression that returns the `elseExpr` argument if `ifExpr` is absent, else return\n * the result of the `ifExpr` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(field(\"optional_field\"), constant(\"default_value\"))\n * ```\n *\n * @param ifExpr - The expression to check for absence.\n * @param elseExpr - The expression that will be evaluated and returned if [ifExpr] is absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(ifExpr: Expression, elseExpr: Expression): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseValue` argument if `ifExpr` is absent, else\n * return the result of the `ifExpr` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(field(\"optional_field\"), \"default_value\")\n * ```\n *\n * @param ifExpr - The expression to check for absence.\n * @param elseValue - The value that will be returned if `ifExpr` evaluates to an absent value.\n * @returns A new [Expression] representing the ifAbsent operation.\n */\nexport function ifAbsent(ifExpr: Expression, elseValue: unknown): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseExpr` argument if `ifFieldName` is absent, else\n * return the value of the field.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns the value of\n * // 'default_field' if 'optional_field' is absent.\n * ifAbsent(\"optional_field\", field(\"default_field\"))\n * ```\n *\n * @param ifFieldName - The field to check for absence.\n * @param elseExpr - The expression that will be evaluated and returned if `ifFieldName` is\n * absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(ifFieldName: string, elseExpr: Expression): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseValue` argument if `ifFieldName` is absent, else\n * return the value of the field.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(\"optional_field\", \"default_value\")\n * ```\n *\n * @param ifFieldName - The field to check for absence.\n * @param elseValue - The value that will be returned if [ifFieldName] is absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(\n  ifFieldName: string | Expression,\n  elseValue: Expression | unknown\n): Expression;\nexport function ifAbsent(\n  fieldNameOrExpression: string | Expression,\n  elseValue: Expression | unknown\n): Expression {\n  return fieldOrExpression(fieldNameOrExpression).ifAbsent(\n    valueToDefaultExpr(elseValue)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with a comma and space.\n * join(\"tags\", \", \")\n * ```\n *\n * @param arrayFieldName - The name of the field containing the array.\n * @param delimiter - The string to use as a delimiter.\n * @returns A new Expression representing the join operation.\n */\nexport function join(arrayFieldName: string, delimiter: string): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join an array of string using the delimiter from the 'separator' field.\n * join(array(['foo', 'bar']), field(\"separator\"))\n * ```\n *\n * @param arrayExpression - An expression that evaluates to an array.\n * @param delimiterExpression - The expression that evaluates to the delimiter string.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayExpression: Expression,\n  delimiterExpression: Expression\n): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with a comma and space.\n * join(field(\"tags\"), \", \")\n * ```\n *\n * @param arrayExpression - An expression that evaluates to an array.\n * @param delimiter - The string to use as a delimiter.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayExpression: Expression,\n  delimiter: string\n): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with the delimiter from the 'separator' field.\n * join('tags', field(\"separator\"))\n * ```\n *\n * @param arrayFieldName - The name of the field containing the array.\n * @param delimiterExpression - The expression that evaluates to the delimiter string.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayFieldName: string,\n  delimiterExpression: Expression\n): Expression;\nexport function join(\n  fieldNameOrExpression: string | Expression,\n  delimiterValueOrExpression: Expression | string\n): Expression {\n  return fieldOrExpression(fieldNameOrExpression).join(\n    valueToDefaultExpr(delimiterValueOrExpression)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that computes the base-10 logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the base-10 logarithm of the 'value' field.\n * log10(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the base-10 logarithm of.\n * @returns A new `Expression` representing the base-10 logarithm of the numeric value.\n */\nexport function log10(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the base-10 logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the base-10 logarithm of the 'value' field.\n * log10(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the base-10 logarithm will be computed for.\n * @returns A new `Expression` representing the base-10 logarithm of the numeric value.\n */\nexport function log10(expression: Expression): FunctionExpression;\nexport function log10(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).log10();\n}\n\n/**\n * @beta\n * Creates an expression that computes the sum of the elements in an array.\n *\n * @example\n * ```typescript\n * // Compute the sum of the elements in the 'scores' field.\n * arraySum(\"scores\");\n * ```\n *\n * @param fieldName - The name of the field to compute the sum of.\n * @returns A new `Expression` representing the sum of the elements in the array.\n */\nexport function arraySum(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the sum of the elements in an array.\n *\n * @example\n * ```typescript\n * // Compute the sum of the elements in the 'scores' field.\n * arraySum(field(\"scores\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric array, which the sum will be computed for.\n * @returns A new `Expression` representing the sum of the elements in the array.\n */\nexport function arraySum(expression: Expression): FunctionExpression;\nexport function arraySum(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).arraySum();\n}\n\n/**\n * @beta\n * Creates an expression that splits the value of a field on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scoresCsv' field on delimiter ','\n * split('scoresCsv', ',')\n * ```\n *\n * @param fieldName - Split the value in this field.\n * @param delimiter - Split on this delimiter.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(fieldName: string, delimiter: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits the value of a field on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n * split('scores', conditional(field('format').equal('csv'), constant(','), constant(':'))\n * ```\n *\n * @param fieldName - Split the value in this field.\n * @param delimiter - Split on this delimiter returned by evaluating this expression.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  fieldName: string,\n  delimiter: Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits a string into an array of substrings based on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scoresCsv' field on delimiter ','\n * split(field('scoresCsv'), ',')\n * ```\n *\n * @param expression - Split the result of this expression.\n * @param delimiter - Split on this delimiter.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  expression: Expression,\n  delimiter: string\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits a string into an array of substrings based on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n * split(field('scores'), conditional(field('format').equal('csv'), constant(','), constant(':'))\n * ```\n *\n * @param expression - Split the result of this expression.\n * @param delimiter - Split on this delimiter returned by evaluating this expression.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  expression: Expression,\n  delimiter: Expression\n): FunctionExpression;\nexport function split(\n  fieldNameOrExpression: string | Expression,\n  delimiter: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldNameOrExpression).split(\n    valueToDefaultExpr(delimiter)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the beginning of the day.\n * field('createdAt').timestampTruncate('day')\n * ```\n *\n * @param fieldName - Truncate the timestamp value contained in this field.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  fieldName: string,\n  granularity: TimeGranularity,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n * field('createdAt').timestampTruncate(field('granularity'))\n * ```\n *\n * @param fieldName - Truncate the timestamp value contained in this field.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  fieldName: string,\n  granularity: Expression,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the beginning of the day.\n * field('createdAt').timestampTruncate('day')\n * ```\n *\n * @param timestampExpression - Truncate the timestamp value that is returned by this expression.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  timestampExpression: Expression,\n  granularity: TimeGranularity,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n * field('createdAt').timestampTruncate(field('granularity'))\n * ```\n *\n * @param timestampExpression - Truncate the timestamp value that is returned by this expression.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  timestampExpression: Expression,\n  granularity: Expression,\n  timezone?: string | Expression\n): FunctionExpression;\nexport function timestampTruncate(\n  fieldNameOrExpression: string | Expression,\n  granularity: TimeGranularity | Expression,\n  timezone?: string | Expression\n): FunctionExpression {\n  const internalGranularity = isString(granularity)\n    ? valueToDefaultExpr(granularity.toLowerCase())\n    : granularity;\n  return fieldOrExpression(fieldNameOrExpression).timestampTruncate(\n    internalGranularity,\n    timezone\n  );\n}\n\n/**\n * @beta\n * Creates an expression that returns the data type of the data in the specified field.\n *\n * @example\n * ```typescript\n * // Get the data type of the value in field 'title'\n * type('title')\n * ```\n *\n * @returns A new `Expression` representing the data type.\n */\nexport function type(fieldName: string): FunctionExpression;\n/**\n * @beta\n * Creates an expression that returns the data type of an expression's result.\n *\n * @example\n * ```typescript\n * // Get the data type of a conditional expression\n * type(conditional(exists('foo'), constant(1), constant(true)))\n * ```\n *\n * @returns A new `Expression` representing the data type.\n */\nexport function type(expression: Expression): FunctionExpression;\nexport function type(\n  fieldNameOrExpression: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldNameOrExpression).type();\n}\n\n// TODO(new-expression): Add new top-level expression function definitions above this line\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on an expression.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in lowercase in ascending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(ascending(field(\"name\").toLower()));\n * ```\n *\n * @param expr - The expression to create an ascending ordering for.\n * @returns A new `Ordering` for ascending sorting.\n */\nexport function ascending(expr: Expression): Ordering;\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on a field.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in ascending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(ascending(\"name\"));\n * ```\n *\n * @param fieldName - The field to create an ascending ordering for.\n * @returns A new `Ordering` for ascending sorting.\n */\nexport function ascending(fieldName: string): Ordering;\nexport function ascending(field: Expression | string): Ordering {\n  return new Ordering(fieldOrExpression(field), 'ascending', 'ascending');\n}\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on an expression.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in lowercase in descending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(descending(field(\"name\").toLower()));\n * ```\n *\n * @param expr - The expression to create a descending ordering for.\n * @returns A new `Ordering` for descending sorting.\n */\nexport function descending(expr: Expression): Ordering;\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on a field.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in descending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(descending(\"name\"));\n * ```\n *\n * @param fieldName - The field to create a descending ordering for.\n * @returns A new `Ordering` for descending sorting.\n */\nexport function descending(fieldName: string): Ordering;\nexport function descending(field: Expression | string): Ordering {\n  return new Ordering(fieldOrExpression(field), 'descending', 'descending');\n}\n\n/**\n * @beta\n *\n * Represents an ordering criterion for sorting documents in a Firestore pipeline.\n *\n * You create `Ordering` instances using the `ascending` and `descending` helper functions.\n */\nexport class Ordering implements ProtoValueSerializable, UserData {\n  constructor(\n    public readonly expr: Expression,\n    public readonly direction: 'ascending' | 'descending',\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      mapValue: {\n        fields: {\n          direction: toStringValue(this.direction),\n          expression: this.expr._toProto(serializer)\n        }\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.expr._readUserData(context);\n  }\n\n  _protoValueType: 'ProtoValue' = 'ProtoValue';\n}\n\nexport function isSelectable(val: unknown): val is Selectable {\n  const candidate = val as Selectable;\n  return (\n    candidate.selectable && isString(candidate.alias) && isExpr(candidate.expr)\n  );\n}\n\nexport function isOrdering(val: unknown): val is Ordering {\n  const candidate = val as Ordering;\n  return (\n    isExpr(candidate.expr) &&\n    (candidate.direction === 'ascending' ||\n      candidate.direction === 'descending')\n  );\n}\n\nexport function isAliasedAggregate(val: unknown): val is AliasedAggregate {\n  const candidate = val as AliasedAggregate;\n  return (\n    isString(candidate.alias) &&\n    candidate.aggregate instanceof AggregateFunction\n  );\n}\n\nexport function isExpr(val: unknown): val is Expression {\n  return val instanceof Expression;\n}\n\nexport function isBooleanExpr(val: unknown): val is BooleanExpression {\n  return val instanceof BooleanExpression;\n}\n\nexport function isField(val: unknown): val is Field {\n  return val instanceof Field;\n}\n\nexport function toField(value: string | Field): Field {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return value as Field;\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Firestore } from '../lite-api/database';\nimport {\n  Constant,\n  BooleanExpression,\n  and,\n  or,\n  Ordering,\n  lessThan,\n  greaterThan,\n  field\n} from '../lite-api/expressions';\nimport { Pipeline } from '../lite-api/pipeline';\nimport { doc } from '../lite-api/reference';\nimport { fail } from '../util/assert';\n\nimport { Bound } from './bound';\nimport {\n  CompositeFilter as CompositeFilterInternal,\n  CompositeOperator,\n  FieldFilter as FieldFilterInternal,\n  Filter as FilterInternal,\n  Operator\n} from './filter';\nimport { Direction } from './order_by';\nimport {\n  isCollectionGroupQuery,\n  isDocumentQuery,\n  LimitType,\n  Query,\n  queryNormalizedOrderBy\n} from './query';\n\n/* eslint @typescript-eslint/no-explicit-any: 0 */\n\nexport function toPipelineBooleanExpr(f: FilterInternal): BooleanExpression {\n  if (f instanceof FieldFilterInternal) {\n    const fieldValue = field(f.field.toString());\n    // Comparison filters\n    const value = f.value;\n    switch (f.op) {\n      case Operator.LESS_THAN:\n        return and(\n          fieldValue.exists(),\n          fieldValue.lessThan(Constant._fromProto(value))\n        );\n      case Operator.LESS_THAN_OR_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.lessThanOrEqual(Constant._fromProto(value))\n        );\n      case Operator.GREATER_THAN:\n        return and(\n          fieldValue.exists(),\n          fieldValue.greaterThan(Constant._fromProto(value))\n        );\n      case Operator.GREATER_THAN_OR_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.greaterThanOrEqual(Constant._fromProto(value))\n        );\n      case Operator.EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.equal(Constant._fromProto(value))\n        );\n      case Operator.NOT_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.notEqual(Constant._fromProto(value))\n        );\n      case Operator.ARRAY_CONTAINS:\n        return and(\n          fieldValue.exists(),\n          fieldValue.arrayContains(Constant._fromProto(value))\n        );\n      case Operator.IN: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        if (!values) {\n          return and(fieldValue.exists(), fieldValue.equalAny([]));\n        } else if (values.length === 1) {\n          return and(fieldValue.exists(), fieldValue.equal(values[0]));\n        } else {\n          return and(fieldValue.exists(), fieldValue.equalAny(values));\n        }\n      }\n      case Operator.ARRAY_CONTAINS_ANY: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        return and(fieldValue.exists(), fieldValue.arrayContainsAny(values!));\n      }\n      case Operator.NOT_IN: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        if (!values) {\n          return and(fieldValue.exists(), fieldValue.notEqualAny([]));\n        } else if (values.length === 1) {\n          return and(fieldValue.exists(), fieldValue.notEqual(values[0]));\n        } else {\n          return and(fieldValue.exists(), fieldValue.notEqualAny(values));\n        }\n      }\n      default:\n        fail(0x9047, 'Unexpected operator');\n    }\n  } else if (f instanceof CompositeFilterInternal) {\n    switch (f.op) {\n      case CompositeOperator.AND: {\n        const conditions = f.getFilters().map(f => toPipelineBooleanExpr(f));\n        return and(conditions[0], conditions[1], ...conditions.slice(2));\n      }\n      case CompositeOperator.OR: {\n        const conditions = f.getFilters().map(f => toPipelineBooleanExpr(f));\n        return or(conditions[0], conditions[1], ...conditions.slice(2));\n      }\n      default:\n        fail(0x89ea, 'Unexpected operator');\n    }\n  }\n\n  throw new Error(`Failed to convert filter to pipeline conditions: ${f}`);\n}\n\nfunction reverseOrderings(orderings: Ordering[]): Ordering[] {\n  return orderings.map(\n    o =>\n      new Ordering(\n        o.expr,\n        o.direction === 'ascending' ? 'descending' : 'ascending',\n        undefined\n      )\n  );\n}\n\nexport function toPipeline(query: Query, db: Firestore): Pipeline {\n  let pipeline: Pipeline;\n  if (isCollectionGroupQuery(query)) {\n    pipeline = db.pipeline().collectionGroup(query.collectionGroup!);\n  } else if (isDocumentQuery(query)) {\n    pipeline = db.pipeline().documents([doc(db, query.path.canonicalString())]);\n  } else {\n    pipeline = db.pipeline().collection(query.path.canonicalString());\n  }\n\n  // filters\n  for (const filter of query.filters) {\n    pipeline = pipeline.where(toPipelineBooleanExpr(filter));\n  }\n\n  // orders\n  const orders = queryNormalizedOrderBy(query);\n  const existsConditions = orders.map(order =>\n    field(order.field.canonicalString()).exists()\n  );\n  if (existsConditions.length > 1) {\n    pipeline = pipeline.where(\n      and(\n        existsConditions[0],\n        existsConditions[1],\n        ...existsConditions.slice(2)\n      )\n    );\n  } else {\n    pipeline = pipeline.where(existsConditions[0]);\n  }\n\n  const orderings = orders.map(order =>\n    order.dir === Direction.ASCENDING\n      ? field(order.field.canonicalString()).ascending()\n      : field(order.field.canonicalString()).descending()\n  );\n\n  if (orderings.length > 0) {\n    if (query.limitType === LimitType.Last) {\n      const actualOrderings = reverseOrderings(orderings);\n      pipeline = pipeline.sort(actualOrderings[0], ...actualOrderings.slice(1));\n      // cursors\n      if (query.startAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.startAt, orderings, 'after')\n        );\n      }\n\n      if (query.endAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.endAt, orderings, 'before')\n        );\n      }\n\n      pipeline = pipeline.limit(query.limit!);\n      pipeline = pipeline.sort(orderings[0], ...orderings.slice(1));\n    } else {\n      pipeline = pipeline.sort(orderings[0], ...orderings.slice(1));\n      if (query.startAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.startAt, orderings, 'after')\n        );\n      }\n      if (query.endAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.endAt, orderings, 'before')\n        );\n      }\n\n      if (query.limit !== null) {\n        pipeline = pipeline.limit(query.limit);\n      }\n    }\n  }\n\n  return pipeline;\n}\n\nfunction whereConditionsFromCursor(\n  bound: Bound,\n  orderings: Ordering[],\n  position: 'before' | 'after'\n): BooleanExpression {\n  // The filterFunc is either greater than or less than\n  const filterFunc = position === 'before' ? lessThan : greaterThan;\n  const cursors = bound.position.map(value => Constant._fromProto(value));\n  const size = cursors.length;\n\n  let field = orderings[size - 1].expr;\n  let value = cursors[size - 1];\n\n  // Add condition for last bound\n  let condition: BooleanExpression = filterFunc(field, value);\n  if (bound.inclusive) {\n    // When the cursor bound is inclusive, then the last bound\n    // can be equal to the value, otherwise it's not equal\n    condition = or(condition, field.equal(value));\n  }\n\n  // Iterate backwards over the remaining bounds, adding\n  // a condition for each one\n  for (let i = size - 2; i >= 0; i--) {\n    field = orderings[i].expr;\n    value = cursors[i];\n\n    // For each field in the orderings, the condition is either\n    // a) lt|gt the cursor value,\n    // b) or equal the cursor value and lt|gt the cursor values for other fields\n    condition = or(\n      filterFunc(field, value),\n      and(field.equal(value), condition)\n    );\n  }\n\n  return condition;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParseContext } from '../api/parse_context';\nimport { OptionsUtil } from '../core/options_util';\nimport {\n  ApiClientObjectMap,\n  firestoreV1ApiClientInterfaces,\n  Stage as ProtoStage\n} from '../protos/firestore_proto_api';\nimport { toNumber } from '../remote/number_serializer';\nimport {\n  JsonProtoSerializer,\n  ProtoSerializable,\n  toMapValue,\n  toPipelineValue,\n  toStringValue\n} from '../remote/serializer';\nimport { hardAssert } from '../util/assert';\n\nimport {\n  AggregateFunction,\n  BooleanExpression,\n  Expression,\n  Field,\n  field,\n  Ordering\n} from './expressions';\nimport { Pipeline } from './pipeline';\nimport { StageOptions } from './stage_options';\nimport { isUserData, UserData } from './user_data_reader';\n\n/**\n * @beta\n */\nexport abstract class Stage implements ProtoSerializable<ProtoStage>, UserData {\n  /**\n   * Store optionsProto parsed by _readUserData.\n   * @private\n   * @internal\n   * @protected\n   */\n  protected optionsProto:\n    | ApiClientObjectMap<firestoreV1ApiClientInterfaces.Value>\n    | undefined = undefined;\n  protected knownOptions: Record<string, unknown>;\n  protected rawOptions?: Record<string, unknown>;\n\n  constructor(options: StageOptions) {\n    ({ rawOptions: this.rawOptions, ...this.knownOptions } = options);\n  }\n\n  _readUserData(context: ParseContext): void {\n    this.optionsProto = this._optionsUtil.getOptionsProto(\n      context,\n      this.knownOptions,\n      this.rawOptions\n    );\n  }\n\n  _toProto(_: JsonProtoSerializer): ProtoStage {\n    return {\n      name: this._name,\n      options: this.optionsProto\n    };\n  }\n\n  abstract get _optionsUtil(): OptionsUtil;\n  abstract get _name(): string;\n}\n\n/**\n * @beta\n */\nexport class AddFields extends Stage {\n  get _name(): string {\n    return 'add_fields';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private fields: Map<string, Expression>, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.fields)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.fields, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class RemoveFields extends Stage {\n  get _name(): string {\n    return 'remove_fields';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private fields: Field[], options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.fields.map(f => f._toProto(serializer))\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.fields, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Aggregate extends Stage {\n  get _name(): string {\n    return 'aggregate';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private groups: Map<string, Expression>,\n    private accumulators: Map<string, AggregateFunction>,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        toMapValue(serializer, this.accumulators),\n        toMapValue(serializer, this.groups)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.groups, context);\n    readUserDataHelper(this.accumulators, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Distinct extends Stage {\n  get _name(): string {\n    return 'distinct';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private groups: Map<string, Expression>, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.groups)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.groups, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class CollectionSource extends Stage {\n  get _name(): string {\n    return 'collection';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      forceIndex: {\n        serverName: 'force_index'\n      }\n    });\n  }\n\n  private formattedCollectionPath: string;\n\n  constructor(collection: string, options: StageOptions) {\n    super(options);\n\n    // prepend slash to collection string\n    this.formattedCollectionPath = collection.startsWith('/')\n      ? collection\n      : '/' + collection;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [{ referenceValue: this.formattedCollectionPath }]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class CollectionGroupSource extends Stage {\n  get _name(): string {\n    return 'collection_group';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      forceIndex: {\n        serverName: 'force_index'\n      }\n    });\n  }\n\n  constructor(private collectionId: string, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [{ referenceValue: '' }, { stringValue: this.collectionId }]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class DatabaseSource extends Stage {\n  get _name(): string {\n    return 'database';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer)\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class DocumentsSource extends Stage {\n  get _name(): string {\n    return 'documents';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  private formattedPaths: string[];\n\n  constructor(docPaths: string[], options: StageOptions) {\n    super(options);\n    this.formattedPaths = docPaths.map(path =>\n      path.startsWith('/') ? path : '/' + path\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.formattedPaths.map(p => {\n        return { referenceValue: p };\n      })\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Where extends Stage {\n  get _name(): string {\n    return 'where';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private condition: BooleanExpression, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [this.condition._toProto(serializer)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.condition, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class FindNearest extends Stage {\n  get _name(): string {\n    return 'find_nearest';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      limit: {\n        serverName: 'limit'\n      },\n      distanceField: {\n        serverName: 'distance_field'\n      }\n    });\n  }\n\n  constructor(\n    private vectorValue: Expression,\n    private field: Field,\n    private distanceMeasure: 'euclidean' | 'cosine' | 'dot_product',\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        this.field._toProto(serializer),\n        this.vectorValue._toProto(serializer),\n        toStringValue(this.distanceMeasure)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.vectorValue, context);\n    readUserDataHelper(this.field, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Limit extends Stage {\n  get _name(): string {\n    return 'limit';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private limit: number, options: StageOptions) {\n    hardAssert(\n      !isNaN(limit) && limit !== Infinity && limit !== -Infinity,\n      0x882c,\n      'Invalid limit value'\n    );\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.limit)]\n    };\n  }\n}\n\n/**\n * @beta\n */\nexport class Offset extends Stage {\n  get _name(): string {\n    return 'offset';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private offset: number, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.offset)]\n    };\n  }\n}\n\n/**\n * @beta\n */\nexport class Select extends Stage {\n  get _name(): string {\n    return 'select';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private selections: Map<string, Expression>,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.selections)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.selections, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Sort extends Stage {\n  get _name(): string {\n    return 'sort';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private orderings: Ordering[], options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.orderings.map(o => o._toProto(serializer))\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.orderings, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Sample extends Stage {\n  get _name(): string {\n    return 'sample';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private rate: number,\n    private mode: 'percent' | 'documents',\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.rate)!, toStringValue(this.mode)!]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Union extends Stage {\n  get _name(): string {\n    return 'union';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private other: Pipeline, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toPipelineValue(this.other._toProto(serializer))]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Unnest extends Stage {\n  get _name(): string {\n    return 'unnest';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      indexField: {\n        serverName: 'index_field'\n      }\n    });\n  }\n\n  constructor(\n    private alias: string,\n    private expr: Expression,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        this.expr._toProto(serializer),\n        field(this.alias)._toProto(serializer)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.expr, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Replace extends Stage {\n  static readonly MODE = 'full_replace';\n\n  get _name(): string {\n    return 'replace_with';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private map: Expression, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [this.map._toProto(serializer), toStringValue(Replace.MODE)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.map, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class RawStage extends Stage {\n  /**\n   * @private\n   * @internal\n   */\n  constructor(\n    private name: string,\n    private params: Array<AggregateFunction | Expression>,\n    rawOptions: Record<string, unknown>\n  ) {\n    super({ rawOptions });\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      name: this.name,\n      args: this.params.map(o => o._toProto(serializer)),\n      options: this.optionsProto\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.params, context);\n  }\n\n  get _name(): string {\n    return this.name;\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n}\n\n/**\n * Helper to read user data across a number of different formats.\n * @param name - Name of the calling function. Used for error messages when invalid user data is encountered.\n * @param expressionMap\n * @returns the expressionMap argument.\n * @private\n */\nfunction readUserDataHelper<\n  T extends Map<string, UserData> | UserData[] | UserData\n>(expressionMap: T, context: ParseContext): T {\n  if (isUserData(expressionMap)) {\n    expressionMap._readUserData(context);\n  } else if (Array.isArray(expressionMap)) {\n    expressionMap.forEach(readableData => readableData._readUserData(context));\n  } else {\n    expressionMap.forEach(expr => expr._readUserData(context));\n  }\n  return expressionMap;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DatabaseId } from '../core/database_info';\nimport { toPipeline } from '../core/pipeline-util';\nimport { Code, FirestoreError } from '../util/error';\nimport { isString } from '../util/types';\n\nimport { Pipeline } from './pipeline';\nimport {\n  CollectionReference,\n  DocumentReference,\n  isCollectionReference,\n  Query\n} from './reference';\nimport {\n  CollectionGroupSource,\n  CollectionSource,\n  DatabaseSource,\n  DocumentsSource,\n  Stage\n} from './stage';\nimport {\n  CollectionGroupStageOptions,\n  CollectionStageOptions,\n  DatabaseStageOptions,\n  DocumentsStageOptions\n} from './stage_options';\nimport { UserDataReader, UserDataSource } from './user_data_reader';\n\n/**\n * @beta\n * Provides the entry point for defining the data source of a Firestore {@link @firebase/firestore/pipelines#Pipeline}.\n *\n * Use the methods of this class (e.g., {@link @firebase/firestore/pipelines#PipelineSource.(collection:1)}, {@link @firebase/firestore/pipelines#PipelineSource.(collectionGroup:1)},\n * {@link @firebase/firestore/pipelines#PipelineSource.(database:1)}, or {@link @firebase/firestore/pipelines#PipelineSource.(documents:1)}) to specify the initial data\n * for your pipeline, such as a collection, a collection group, the entire database, or a set of specific documents.\n */\nexport class PipelineSource<PipelineType> {\n  /**\n   * @internal\n   * @private\n   * @param databaseId\n   * @param userDataReader\n   * @param _createPipeline\n   */\n  constructor(\n    private databaseId: DatabaseId,\n    private userDataReader: UserDataReader,\n    /**\n     * @internal\n     * @private\n     */\n    public _createPipeline: (stages: Stage[]) => PipelineType\n  ) {}\n\n  /**\n   * @beta\n   * Returns all documents from the entire collection. The collection can be nested.\n   * @param collection - Name or reference to the collection that will be used as the Pipeline source.\n   */\n  collection(collection: string | CollectionReference): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from the entire collection. The collection can be nested.\n   * @param options - Options defining how this CollectionStage is evaluated.\n   */\n  collection(options: CollectionStageOptions): PipelineType;\n  collection(\n    collectionOrOptions: string | CollectionReference | CollectionStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(collectionOrOptions) ||\n      isCollectionReference(collectionOrOptions)\n        ? {}\n        : collectionOrOptions;\n    const collectionRefOrString =\n      isString(collectionOrOptions) ||\n      isCollectionReference(collectionOrOptions)\n        ? collectionOrOptions\n        : collectionOrOptions.collection;\n\n    // Validate that a user provided reference is for the same Firestore DB\n    if (isCollectionReference(collectionRefOrString)) {\n      this._validateReference(collectionRefOrString);\n    }\n\n    // Convert user land convenience types to internal types\n    const normalizedCollection = isString(collectionRefOrString)\n      ? (collectionRefOrString as string)\n      : collectionRefOrString.path;\n\n    // Create stage object\n    const stage = new CollectionSource(normalizedCollection, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'collection'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Returns all documents from a collection ID regardless of the parent.\n   * @param collectionId - ID of the collection group to use as the Pipeline source.\n   */\n  collectionGroup(collectionId: string): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from a collection ID regardless of the parent.\n   * @param options - Options defining how this CollectionGroupStage is evaluated.\n   */\n  collectionGroup(options: CollectionGroupStageOptions): PipelineType;\n  collectionGroup(\n    collectionIdOrOptions: string | CollectionGroupStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    let collectionId: string;\n    let options: {};\n    if (isString(collectionIdOrOptions)) {\n      collectionId = collectionIdOrOptions;\n      options = {};\n    } else {\n      ({ collectionId, ...options } = collectionIdOrOptions);\n    }\n\n    // Create stage object\n    const stage = new CollectionGroupSource(collectionId, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'collectionGroup'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Returns all documents from the entire database.\n   */\n  database(): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from the entire database.\n   * @param options - Options defining how a DatabaseStage is evaluated.\n   */\n  database(options: DatabaseStageOptions): PipelineType;\n  database(options?: DatabaseStageOptions): PipelineType {\n    // Process argument union(s) from method overloads\n    options = options ?? {};\n\n    // Create stage object\n    const stage = new DatabaseSource(options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'database'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Set the pipeline's source to the documents specified by the given paths and DocumentReferences.\n   *\n   * @param docs - An array of paths and DocumentReferences specifying the individual documents that will be the source of this pipeline.\n   * The converters for these DocumentReferences will be ignored and not have an effect on this pipeline.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  documents(docs: Array<string | DocumentReference>): PipelineType;\n\n  /**\n   * @beta\n   * Set the pipeline's source to the documents specified by the given paths and DocumentReferences.\n   *\n   * @param options - Options defining how this DocumentsStage is evaluated.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  documents(options: DocumentsStageOptions): PipelineType;\n  documents(\n    docsOrOptions: Array<string | DocumentReference> | DocumentsStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let docs: Array<string | DocumentReference>;\n    if (Array.isArray(docsOrOptions)) {\n      docs = docsOrOptions;\n      options = {};\n    } else {\n      ({ docs, ...options } = docsOrOptions);\n    }\n\n    // Validate that all user provided references are for the same Firestore DB\n    docs\n      .filter(v => v instanceof DocumentReference)\n      .forEach(dr => this._validateReference(dr as DocumentReference));\n\n    // Convert user land convenience types to internal types\n    const normalizedDocs: string[] = docs.map(doc =>\n      isString(doc) ? doc : doc.path\n    );\n\n    // Create stage object\n    const stage = new DocumentsSource(normalizedDocs, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'documents'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Convert the given Query into an equivalent Pipeline.\n   *\n   * @param query - A Query to be converted into a Pipeline.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  createFrom(query: Query): Pipeline {\n    return toPipeline(query._query, query.firestore);\n  }\n\n  _validateReference(reference: CollectionReference | DocumentReference): void {\n    const refDbId = reference.firestore._databaseId;\n    if (!refDbId.isEqual(this.databaseId)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid ${\n          reference instanceof CollectionReference\n            ? 'CollectionReference'\n            : 'DocumentReference'\n        }. ` +\n          `The project ID (\"${refDbId.projectId}\") or the database (\"${refDbId.database}\") does not match ` +\n          `the project ID (\"${this.databaseId.projectId}\") and database (\"${this.databaseId.database}\") of the target database of this Pipeline.`\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ObjectValue } from '../model/object_value';\nimport { firestoreV1ApiClientInterfaces } from '../protos/firestore_proto_api';\nimport { isOptionalEqual } from '../util/misc';\n\nimport { Field, isField } from './expressions';\nimport { FieldPath } from './field_path';\nimport { Pipeline } from './pipeline';\nimport { DocumentData, DocumentReference, refEqual } from './reference';\nimport { Timestamp } from './timestamp';\nimport { fieldPathFromArgument } from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * @beta\n * Represents the results of a Firestore pipeline execution.\n *\n * A `PipelineSnapshot` contains zero or more {@link @firebase/firestore/pipelines#PipelineResult} objects\n * representing the documents returned by a pipeline query. It provides methods\n * to iterate over the documents and access metadata about the query results.\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await firestore\n *   .pipeline()\n *   .collection('myCollection')\n *   .where(field('value').greaterThan(10))\n *   .execute();\n *\n * snapshot.results.forEach(doc => {\n *   console.log(doc.id, '=>', doc.data());\n * });\n * ```\n */\nexport class PipelineSnapshot {\n  private readonly _pipeline: Pipeline;\n  private readonly _executionTime: Timestamp | undefined;\n  private readonly _results: PipelineResult[];\n  constructor(\n    pipeline: Pipeline,\n    results: PipelineResult[],\n    executionTime?: Timestamp\n  ) {\n    this._pipeline = pipeline;\n    this._executionTime = executionTime;\n    this._results = results;\n  }\n\n  /**\n   * @beta An array of all the results in the `PipelineSnapshot`.\n   */\n  get results(): PipelineResult[] {\n    return this._results;\n  }\n\n  /**\n   * @beta\n   * The time at which the pipeline producing this result is executed.\n   *\n   * @readonly\n   *\n   */\n  get executionTime(): Timestamp {\n    if (this._executionTime === undefined) {\n      throw new Error(\n        \"'executionTime' is expected to exist, but it is undefined\"\n      );\n    }\n    return this._executionTime;\n  }\n}\n\n/**\n * @beta\n *\n * A PipelineResult contains data read from a Firestore Pipeline. The data can be extracted with the\n * {@link @firebase/firestore/pipelines#PipelineResult.data} or {@link @firebase/firestore/pipelines#PipelineResult.(get:1)} methods.\n *\n * <p>If the PipelineResult represents a non-document result, `ref` will return a undefined\n * value.\n */\nexport class PipelineResult<AppModelType = DocumentData> {\n  private readonly _userDataWriter: AbstractUserDataWriter;\n\n  private readonly _createTime: Timestamp | undefined;\n  private readonly _updateTime: Timestamp | undefined;\n\n  /**\n   * @internal\n   * @private\n   */\n  readonly _ref: DocumentReference | undefined;\n\n  /**\n   * @internal\n   * @private\n   */\n  readonly _fields: ObjectValue;\n\n  /**\n   * @private\n   * @internal\n   *\n   * @param userDataWriter - The serializer used to encode/decode protobuf.\n   * @param ref - The reference to the document.\n   * @param fields - The fields of the Firestore `Document` Protobuf backing\n   * this document.\n   * @param createTime - The time when the document was created if the result is a document, undefined otherwise.\n   * @param updateTime - The time when the document was last updated if the result is a document, undefined otherwise.\n   */\n  constructor(\n    userDataWriter: AbstractUserDataWriter,\n    fields: ObjectValue,\n    ref?: DocumentReference,\n    createTime?: Timestamp,\n    updateTime?: Timestamp\n  ) {\n    this._ref = ref;\n    this._userDataWriter = userDataWriter;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n    this._fields = fields;\n  }\n\n  /**\n   * @beta\n   * The reference of the document, if it is a document; otherwise `undefined`.\n   */\n  get ref(): DocumentReference | undefined {\n    return this._ref;\n  }\n\n  /**\n   * @beta\n   * The ID of the document for which this PipelineResult contains data, if it is a document; otherwise `undefined`.\n   *\n   * @readonly\n   *\n   */\n  get id(): string | undefined {\n    return this._ref?.id;\n  }\n\n  /**\n   * @beta\n   * The time the document was created. Undefined if this result is not a document.\n   *\n   * @readonly\n   */\n  get createTime(): Timestamp | undefined {\n    return this._createTime;\n  }\n\n  /**\n   * @beta\n   * The time the document was last updated (at the time the snapshot was\n   * generated). Undefined if this result is not a document.\n   *\n   * @readonly\n   */\n  get updateTime(): Timestamp | undefined {\n    return this._updateTime;\n  }\n\n  /**\n   * @beta\n   * Retrieves all fields in the result as an object.\n   *\n   * @returns An object containing all fields in the document or\n   * 'undefined' if the document doesn't exist.\n   *\n   * @example\n   * ```\n   * let p = firestore.pipeline().collection('col');\n   *\n   * p.execute().then(results => {\n   *   let data = results[0].data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   * ```\n   */\n  data(): AppModelType {\n    return this._userDataWriter.convertValue(\n      this._fields.value\n    ) as AppModelType;\n  }\n\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the result as a proto value.\n   *\n   * @returns An `Object` containing all fields in the result.\n   */\n  _fieldsProto(): { [key: string]: firestoreV1ApiClientInterfaces.Value } {\n    // Return a cloned value to prevent manipulation of the Snapshot's data\n    return this._fields.clone().value.mapValue.fields!;\n  }\n\n  /**\n   * @beta\n   * Retrieves the field specified by `field`.\n   *\n   * @param field - The field path\n   * (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns The data at the specified field location or `undefined` if no\n   * such field exists.\n   *\n   * @example\n   * ```\n   * let p = firestore.pipeline().collection('col');\n   *\n   * p.execute().then(results => {\n   *   let field = results[0].get('a.b');\n   *   console.log(`Retrieved field value: ${field}`);\n   * });\n   * ```\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(fieldPath: string | FieldPath | Field): any {\n    if (this._fields === undefined) {\n      return undefined;\n    }\n    if (isField(fieldPath)) {\n      fieldPath = fieldPath.fieldName;\n    }\n\n    const value = this._fields.field(\n      fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n    );\n    if (value !== null) {\n      return this._userDataWriter.convertValue(value);\n    }\n  }\n}\n\n/**\n * @beta\n * Test equality of two PipelineResults.\n * @param left - First PipelineResult to compare.\n * @param right - Second PipelineResult to compare.\n */\nexport function pipelineResultEqual(\n  left: PipelineResult,\n  right: PipelineResult\n): boolean {\n  if (left === right) {\n    return true;\n  }\n\n  return (\n    isOptionalEqual(left._ref, right._ref, refEqual) &&\n    isOptionalEqual(left._fields, right._fields, (l, r) => l.isEqual(r))\n  );\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirestoreError, vector } from '../api';\nimport {\n  _constant,\n  AggregateFunction,\n  AliasedAggregate,\n  array,\n  constant,\n  Expression,\n  AliasedExpression,\n  field,\n  Field,\n  map,\n  Selectable\n} from '../lite-api/expressions';\nimport { VectorValue } from '../lite-api/vector_value';\n\nimport { fail } from './assert';\nimport { isPlainObject } from './input_validation';\nimport { isFirestoreValue } from './proto';\nimport { isString } from './types';\n\nexport function selectablesToMap(\n  selectables: Array<Selectable | string>\n): Map<string, Expression> {\n  const result = new Map<string, Expression>();\n  for (const selectable of selectables) {\n    let alias: string;\n    let expression: Expression;\n    if (typeof selectable === 'string') {\n      alias = selectable as string;\n      expression = field(selectable);\n    } else if (selectable instanceof Field) {\n      alias = selectable.alias;\n      expression = selectable.expr;\n    } else if (selectable instanceof AliasedExpression) {\n      alias = selectable.alias;\n      expression = selectable.expr;\n    } else {\n      fail(0x5319, '`selectable` has an unsupported type', { selectable });\n    }\n\n    if (result.get(alias) !== undefined) {\n      throw new FirestoreError(\n        'invalid-argument',\n        `Duplicate alias or field '${alias}'`\n      );\n    }\n\n    result.set(alias, expression);\n  }\n  return result;\n}\n\nexport function aliasedAggregateToMap(\n  aliasedAggregatees: AliasedAggregate[]\n): Map<string, AggregateFunction> {\n  return aliasedAggregatees.reduce(\n    (map: Map<string, AggregateFunction>, selectable: AliasedAggregate) => {\n      if (map.get(selectable.alias) !== undefined) {\n        throw new FirestoreError(\n          'invalid-argument',\n          `Duplicate alias or field '${selectable.alias}'`\n        );\n      }\n\n      map.set(selectable.alias, selectable.aggregate as AggregateFunction);\n      return map;\n    },\n    new Map() as Map<string, AggregateFunction>\n  );\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nexport function vectorToExpr(\n  value: VectorValue | number[] | Expression\n): Expression {\n  if (value instanceof Expression) {\n    return value;\n  } else if (value instanceof VectorValue) {\n    const result = constant(value);\n    return result;\n  } else if (Array.isArray(value)) {\n    const result = constant(vector(value));\n    return result;\n  } else {\n    throw new Error('Unsupported value: ' + typeof value);\n  }\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n * If the input is a string, it is assumed to be a field name, and a\n * field(value) is returned.\n *\n * @private\n * @internal\n * @param value\n */\nexport function fieldOrExpression(value: unknown): Expression {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return valueToDefaultExpr(value);\n  }\n}\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nexport function valueToDefaultExpr(value: unknown): Expression {\n  let result: Expression | undefined;\n  if (isFirestoreValue(value)) {\n    return constant(value);\n  }\n  if (value instanceof Expression) {\n    return value;\n  } else if (isPlainObject(value)) {\n    result = map(value as Record<string, unknown>);\n  } else if (value instanceof Array) {\n    result = array(value);\n  } else {\n    result = _constant(value, undefined);\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Pipeline as ProtoPipeline,\n  Stage as ProtoStage\n} from '../protos/firestore_proto_api';\nimport { JsonProtoSerializer, ProtoSerializable } from '../remote/serializer';\nimport { isPlainObject } from '../util/input_validation';\nimport {\n  aliasedAggregateToMap,\n  fieldOrExpression,\n  selectablesToMap,\n  vectorToExpr\n} from '../util/pipeline_util';\nimport { isNumber, isString } from '../util/types';\n\nimport { Firestore } from './database';\nimport {\n  _mapValue,\n  AggregateFunction,\n  AliasedAggregate,\n  BooleanExpression,\n  _constant,\n  Expression,\n  Field,\n  field,\n  Ordering,\n  Selectable,\n  _field,\n  isSelectable,\n  isField,\n  isBooleanExpr,\n  isAliasedAggregate,\n  toField,\n  isOrdering,\n  isExpr\n} from './expressions';\nimport {\n  AddFields,\n  Aggregate,\n  Distinct,\n  FindNearest,\n  RawStage,\n  Limit,\n  Offset,\n  RemoveFields,\n  Replace,\n  Sample,\n  Select,\n  Sort,\n  Stage,\n  Union,\n  Unnest,\n  Where\n} from './stage';\nimport {\n  AddFieldsStageOptions,\n  AggregateStageOptions,\n  DistinctStageOptions,\n  FindNearestStageOptions,\n  LimitStageOptions,\n  OffsetStageOptions,\n  RemoveFieldsStageOptions,\n  ReplaceWithStageOptions,\n  SampleStageOptions,\n  SelectStageOptions,\n  SortStageOptions,\n  StageOptions,\n  UnionStageOptions,\n  UnnestStageOptions,\n  WhereStageOptions\n} from './stage_options';\nimport { UserDataReader, UserDataSource } from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * @beta\n *\n * The Pipeline class provides a flexible and expressive framework for building complex data\n * transformation and query pipelines for Firestore.\n *\n * A pipeline takes data sources, such as Firestore collections or collection groups, and applies\n * a series of stages that are chained together. Each stage takes the output from the previous stage\n * (or the data source) and produces an output for the next stage (or as the final output of the\n * pipeline).\n *\n * Expressions can be used within each stage to filter and transform data through the stage.\n *\n * NOTE: The chained stages do not prescribe exactly how Firestore will execute the pipeline.\n * Instead, Firestore only guarantees that the result is the same as if the chained stages were\n * executed in order.\n *\n * Usage Examples:\n *\n * @example\n * ```typescript\n * const db: Firestore; // Assumes a valid firestore instance.\n *\n * // Example 1: Select specific fields and rename 'rating' to 'bookRating'\n * const results1 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .select(\"title\", \"author\", field(\"rating\").as(\"bookRating\")));\n *\n * // Example 2: Filter documents where 'genre' is \"Science Fiction\" and 'published' is after 1950\n * const results2 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .where(and(field(\"genre\").eq(\"Science Fiction\"), field(\"published\").gt(1950))));\n *\n * // Example 3: Calculate the average rating of books published after 1980\n * const results3 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .where(field(\"published\").gt(1980))\n *     .aggregate(avg(field(\"rating\")).as(\"averageRating\")));\n * ```\n */\nexport class Pipeline implements ProtoSerializable<ProtoPipeline> {\n  /**\n   * @internal\n   * @private\n   * @param _db\n   * @param userDataReader\n   * @param _userDataWriter\n   * @param stages\n   */\n  constructor(\n    /**\n     * @internal\n     * @private\n     */\n    public _db: Firestore,\n    /**\n     * @internal\n     * @private\n     */\n    private userDataReader: UserDataReader,\n    /**\n     * @internal\n     * @private\n     */\n    public _userDataWriter: AbstractUserDataWriter,\n    /**\n     * @internal\n     * @private\n     */\n    private stages: Stage[]\n  ) {}\n\n  /**\n   * @beta\n   * Adds new fields to outputs from previous stages.\n   *\n   * This stage allows you to compute values on-the-fly based on existing data from previous\n   * stages or constants. You can use this to create new fields or overwrite existing ones (if there\n   * is name overlaps).\n   *\n   * The added fields are defined using {@link @firebase/firestore/pipelines#Selectable}s, which can be:\n   *\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#Expression}: Either a literal value (see {@link @firebase/firestore/pipelines#(constant:1)}) or a computed value\n   *   with an assigned alias using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .addFields(\n   *     field(\"rating\").as(\"bookRating\"), // Rename 'rating' to 'bookRating'\n   *     add(5, field(\"quantity\")).as(\"totalCost\")  // Calculate 'totalCost'\n   *   );\n   * ```\n   *\n   * @param field - The first field to add to the documents, specified as a {@link @firebase/firestore/pipelines#Selectable}.\n   * @param additionalFields - Optional additional fields to add to the documents, specified as {@link @firebase/firestore/pipelines#Selectable}s.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  addFields(field: Selectable, ...additionalFields: Selectable[]): Pipeline;\n  /**\n   * @beta\n   * Adds new fields to outputs from previous stages.\n   *\n   * This stage allows you to compute values on-the-fly based on existing data from previous\n   * stages or constants. You can use this to create new fields or overwrite existing ones (if there\n   * is name overlaps).\n   *\n   * The added fields are defined using {@link @firebase/firestore/pipelines#Selectable}s, which can be:\n   *\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#Expression}: Either a literal value (see {@link @firebase/firestore/pipelines#(constant:1)}) or a computed value\n   *   with an assigned alias using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .addFields(\n   *     field(\"rating\").as(\"bookRating\"), // Rename 'rating' to 'bookRating'\n   *     add(5, field(\"quantity\")).as(\"totalCost\")  // Calculate 'totalCost'\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  addFields(options: AddFieldsStageOptions): Pipeline;\n  addFields(\n    fieldOrOptions: Selectable | AddFieldsStageOptions,\n    ...additionalFields: Selectable[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    let fields: Selectable[];\n    let options: {};\n    if (isSelectable(fieldOrOptions)) {\n      fields = [fieldOrOptions, ...additionalFields];\n      options = {};\n    } else {\n      ({ fields, ...options } = fieldOrOptions);\n    }\n\n    // Convert user land convenience types to internal types\n    const normalizedFields: Map<string, Expression> = selectablesToMap(fields);\n\n    // Create stage object\n    const stage = new AddFields(normalizedFields, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'addFields'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Remove fields from outputs of previous stages.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection('books')\n   *   // removes field 'rating' and 'cost' from the previous stage outputs.\n   *   .removeFields(\n   *     field('rating'),\n   *     'cost'\n   *   );\n   * ```\n   *\n   * @param fieldValue - The first field to remove.\n   * @param additionalFields - Optional additional fields to remove.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  removeFields(\n    fieldValue: Field | string,\n    ...additionalFields: Array<Field | string>\n  ): Pipeline;\n  /**\n   * @beta\n   * Remove fields from outputs of previous stages.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection('books')\n   *   // removes field 'rating' and 'cost' from the previous stage outputs.\n   *   .removeFields(\n   *     field('rating'),\n   *     'cost'\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  removeFields(options: RemoveFieldsStageOptions): Pipeline;\n  removeFields(\n    fieldValueOrOptions: Field | string | RemoveFieldsStageOptions,\n    ...additionalFields: Array<Field | string>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isField(fieldValueOrOptions) || isString(fieldValueOrOptions)\n        ? {}\n        : fieldValueOrOptions;\n    const fields: Array<Field | string> =\n      isField(fieldValueOrOptions) || isString(fieldValueOrOptions)\n        ? [fieldValueOrOptions, ...additionalFields]\n        : fieldValueOrOptions.fields;\n\n    // Convert user land convenience types to internal types\n    const convertedFields: Field[] = fields.map(f =>\n      isString(f) ? field(f) : (f as Field)\n    );\n\n    // Create stage object\n    const stage = new RemoveFields(convertedFields, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    stage._readUserData(\n      this.userDataReader.createContext(UserDataSource.Argument, 'removeFields')\n    );\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Selects or creates a set of fields from the outputs of previous stages.\n   *\n   * <p>The selected fields are defined using {@link @firebase/firestore/pipelines#Selectable} expressions, which can be:\n   *\n   * <ul>\n   *   <li>`string` : Name of an existing field</li>\n   *   <li>{@link @firebase/firestore/pipelines#Field}: References an existing field.</li>\n   *   <li>{@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name using\n   *       {@link @firebase/firestore/pipelines#Expression.(as:1)}</li>\n   * </ul>\n   *\n   * <p>If no selections are provided, the output of this stage is empty. Use {@link\n   * @firebase/firestore/pipelines#Pipeline.(addFields:1)} instead if only additions are\n   * desired.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * db.pipeline().collection(\"books\")\n   *   .select(\n   *     \"firstName\",\n   *     field(\"lastName\"),\n   *     field(\"address\").toUppercase().as(\"upperAddress\"),\n   *   );\n   * ```\n   *\n   * @param selection - The first field to include in the output documents, specified as {@link\n   *     @firebase/firestore/pipelines#Selectable} expression or string value representing the field name.\n   * @param additionalSelections - Optional additional fields to include in the output documents, specified as {@link\n   *     @firebase/firestore/pipelines#Selectable} expressions or `string` values representing field names.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  select(\n    selection: Selectable | string,\n    ...additionalSelections: Array<Selectable | string>\n  ): Pipeline;\n  /**\n   * @beta\n   * Selects or creates a set of fields from the outputs of previous stages.\n   *\n   * <p>The selected fields are defined using {@link @firebase/firestore/pipelines#Selectable} expressions, which can be:\n   *\n   * <ul>\n   *   <li>`string`: Name of an existing field</li>\n   *   <li>{@link @firebase/firestore/pipelines#Field}: References an existing field.</li>\n   *   <li>{@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name using\n   *       {@link @firebase/firestore/pipelines#Expression.(as:1)}</li>\n   * </ul>\n   *\n   * <p>If no selections are provided, the output of this stage is empty. Use {@link\n   * @firebase/firestore/pipelines#Pipeline.(addFields:1)} instead if only additions are\n   * desired.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * db.pipeline().collection(\"books\")\n   *   .select(\n   *     \"firstName\",\n   *     field(\"lastName\"),\n   *     field(\"address\").toUppercase().as(\"upperAddress\"),\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  select(options: SelectStageOptions): Pipeline;\n  select(\n    selectionOrOptions: Selectable | string | SelectStageOptions,\n    ...additionalSelections: Array<Selectable | string>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isSelectable(selectionOrOptions) || isString(selectionOrOptions)\n        ? {}\n        : selectionOrOptions;\n\n    const selections: Array<Selectable | string> =\n      isSelectable(selectionOrOptions) || isString(selectionOrOptions)\n        ? [selectionOrOptions, ...additionalSelections]\n        : selectionOrOptions.selections;\n\n    // Convert user land convenience types to internal types\n    const normalizedSelections: Map<string, Expression> =\n      selectablesToMap(selections);\n\n    // Create stage object\n    const stage = new Select(normalizedSelections, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'select'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Filters the documents from previous stages to only include those matching the specified {@link\n   * @firebase/firestore/pipelines#BooleanExpression}.\n   *\n   * <p>This stage allows you to apply conditions to the data, similar to a \"WHERE\" clause in SQL.\n   * You can filter documents based on their field values, using implementations of {@link\n   * @firebase/firestore/pipelines#BooleanExpression}, typically including but not limited to:\n   *\n   * <ul>\n   *   <li>field comparators: {@link @firebase/firestore/pipelines#Expression.(equal:1)}, {@link @firebase/firestore/pipelines#Expression.(lessThan:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(greaterThan:1)}, etc.</li>\n   *   <li>logical operators: {@link @firebase/firestore/pipelines#Expression.(and:1)}, {@link @firebase/firestore/pipelines#Expression.(or:1)}, {@link @firebase/firestore/pipelines#Expression.(not:1)}, etc.</li>\n   *   <li>advanced functions: {@link @firebase/firestore/pipelines#Expression.(regexMatch:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(arrayContains:1)}, etc.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .where(\n   *     and(\n   *         gt(field(\"rating\"), 4.0),   // Filter for ratings greater than 4.0\n   *         field(\"genre\").eq(\"Science Fiction\") // Equivalent to gt(\"genre\", \"Science Fiction\")\n   *     )\n   *   );\n   * ```\n   *\n   * @param condition - The {@link @firebase/firestore/pipelines#BooleanExpression} to apply.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  where(condition: BooleanExpression): Pipeline;\n  /**\n   * @beta\n   * Filters the documents from previous stages to only include those matching the specified {@link\n   * @firebase/firestore/pipelines#BooleanExpression}.\n   *\n   * <p>This stage allows you to apply conditions to the data, similar to a \"WHERE\" clause in SQL.\n   * You can filter documents based on their field values, using implementations of {@link\n   * @firebase/firestore/pipelines#BooleanExpression}, typically including but not limited to:\n   *\n   * <ul>\n   *   <li>field comparators: {@link @firebase/firestore/pipelines#Expression.(eq:1)}, {@link @firebase/firestore/pipelines#Expression.(lt:1)} (less than), {@link\n   *       @firebase/firestore/pipelines#Expression.(greaterThan:1)}, etc.</li>\n   *   <li>logical operators: {@link @firebase/firestore/pipelines#Expression.(and:1)}, {@link @firebase/firestore/pipelines#Expression.(or:1)}, {@link @firebase/firestore/pipelines#Expression.(not:1)}, etc.</li>\n   *   <li>advanced functions: {@link @firebase/firestore/pipelines#Expression.(regexMatch:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(arrayContains:1)}, etc.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .where(\n   *     and(\n   *         gt(field(\"rating\"), 4.0),   // Filter for ratings greater than 4.0\n   *         field(\"genre\").eq(\"Science Fiction\") // Equivalent to gt(\"genre\", \"Science Fiction\")\n   *     )\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  where(options: WhereStageOptions): Pipeline;\n  where(conditionOrOptions: BooleanExpression | WhereStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isBooleanExpr(conditionOrOptions) ? {} : conditionOrOptions;\n    const condition: BooleanExpression = isBooleanExpr(conditionOrOptions)\n      ? conditionOrOptions\n      : conditionOrOptions.condition;\n\n    // Create stage object\n    const stage = new Where(condition, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'where'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Skips the first `offset` number of documents from the results of previous stages.\n   *\n   * <p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve\n   * results in chunks. It is typically used in conjunction with {@link @firebase/firestore/pipelines#Pipeline.limit} to control the\n   * size of each page.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page of 20 results\n   * firestore.pipeline().collection('books')\n   *     .sort(field('published').descending())\n   *     .offset(20)  // Skip the first 20 results\n   *     .limit(20);   // Take the next 20 results\n   * ```\n   *\n   * @param offset - The number of documents to skip.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  offset(offset: number): Pipeline;\n  /**\n   * @beta\n   * Skips the first `offset` number of documents from the results of previous stages.\n   *\n   * <p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve\n   * results in chunks. It is typically used in conjunction with {@link @firebase/firestore/pipelines#Pipeline.limit} to control the\n   * size of each page.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page of 20 results\n   * firestore.pipeline().collection('books')\n   *     .sort(field('published').descending())\n   *     .offset(20)  // Skip the first 20 results\n   *     .limit(20);   // Take the next 20 results\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  offset(options: OffsetStageOptions): Pipeline;\n  offset(offsetOrOptions: number | OffsetStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let offset: number;\n    if (isNumber(offsetOrOptions)) {\n      options = {};\n      offset = offsetOrOptions;\n    } else {\n      options = offsetOrOptions;\n      offset = offsetOrOptions.offset;\n    }\n\n    // Create stage object\n    const stage = new Offset(offset, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'offset'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Limits the maximum number of documents returned by previous stages to `limit`.\n   *\n   * <p>This stage is particularly useful when you want to retrieve a controlled subset of data from\n   * a potentially large result set. It's often used for:\n   *\n   * <ul>\n   *   <li>**Pagination:** In combination with {@link @firebase/firestore/pipelines#Pipeline.offset} to retrieve specific pages of\n   *       results.</li>\n   *   <li>**Limiting Data Retrieval:** To prevent excessive data transfer and improve performance,\n   *       especially when dealing with large collections.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Limit the results to the top 10 highest-rated books\n   * firestore.pipeline().collection('books')\n   *     .sort(field('rating').descending())\n   *     .limit(10);\n   * ```\n   *\n   * @param limit - The maximum number of documents to return.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  limit(limit: number): Pipeline;\n  /**\n   * @beta\n   * Limits the maximum number of documents returned by previous stages to `limit`.\n   *\n   * <p>This stage is particularly useful when you want to retrieve a controlled subset of data from\n   * a potentially large result set. It's often used for:\n   *\n   * <ul>\n   *   <li>**Pagination:** In combination with {@link @firebase/firestore/pipelines#Pipeline.offset} to retrieve specific pages of\n   *       results.</li>\n   *   <li>**Limiting Data Retrieval:** To prevent excessive data transfer and improve performance,\n   *       especially when dealing with large collections.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Limit the results to the top 10 highest-rated books\n   * firestore.pipeline().collection('books')\n   *     .sort(field('rating').descending())\n   *     .limit(10);\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  limit(options: LimitStageOptions): Pipeline;\n  limit(limitOrOptions: number | LimitStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isNumber(limitOrOptions) ? {} : limitOrOptions;\n    const limit: number = isNumber(limitOrOptions)\n      ? limitOrOptions\n      : limitOrOptions.limit;\n\n    // Create stage object\n    const stage = new Limit(limit, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'limit'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Returns a set of distinct values from the inputs to this stage.\n   *\n   * This stage runs through the results from previous stages to include only results with\n   * unique combinations of {@link @firebase/firestore/pipelines#Expression} values ({@link @firebase/firestore/pipelines#Field}, {@link @firebase/firestore/pipelines#AliasedExpression}, etc).\n   *\n   * The parameters to this stage are defined using {@link @firebase/firestore/pipelines#Selectable} expressions or strings:\n   *\n   * - `string`: Name of an existing field\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name\n   *   using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Get a list of unique author names in uppercase and genre combinations.\n   * firestore.pipeline().collection(\"books\")\n   *     .distinct(toUppercase(field(\"author\")).as(\"authorName\"), field(\"genre\"), \"publishedAt\")\n   *     .select(\"authorName\");\n   * ```\n   *\n   * @param group - The {@link @firebase/firestore/pipelines#Selectable} expression or field name to consider when determining\n   *     distinct value combinations.\n   * @param additionalGroups - Optional additional {@link @firebase/firestore/pipelines#Selectable} expressions to consider when determining distinct\n   *     value combinations or strings representing field names.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  distinct(\n    group: string | Selectable,\n    ...additionalGroups: Array<string | Selectable>\n  ): Pipeline;\n  /**\n   * @beta\n   * Returns a set of distinct values from the inputs to this stage.\n   *\n   * This stage runs through the results from previous stages to include only results with\n   * unique combinations of {@link @firebase/firestore/pipelines#Expression} values ({@link @firebase/firestore/pipelines#Field}, {@link @firebase/firestore/pipelines#AliasedExpression}, etc).\n   *\n   * The parameters to this stage are defined using {@link @firebase/firestore/pipelines#Selectable} expressions or strings:\n   *\n   * - `string`: Name of an existing field\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name\n   *   using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Get a list of unique author names in uppercase and genre combinations.\n   * firestore.pipeline().collection(\"books\")\n   *     .distinct(toUppercase(field(\"author\")).as(\"authorName\"), field(\"genre\"), \"publishedAt\")\n   *     .select(\"authorName\");\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  distinct(options: DistinctStageOptions): Pipeline;\n  distinct(\n    groupOrOptions: string | Selectable | DistinctStageOptions,\n    ...additionalGroups: Array<string | Selectable>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(groupOrOptions) || isSelectable(groupOrOptions)\n        ? {}\n        : groupOrOptions;\n    const groups: Array<string | Selectable> =\n      isString(groupOrOptions) || isSelectable(groupOrOptions)\n        ? [groupOrOptions, ...additionalGroups]\n        : groupOrOptions.groups;\n\n    // Convert user land convenience types to internal types\n    const convertedGroups: Map<string, Expression> = selectablesToMap(groups);\n\n    // Create stage object\n    const stage = new Distinct(convertedGroups, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'distinct'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs aggregation operations on the documents from previous stages.\n   *\n   * <p>This stage allows you to calculate aggregate values over a set of documents. You define the\n   * aggregations to perform using {@link @firebase/firestore/pipelines#AliasedAggregate} expressions which are typically results of\n   * calling {@link @firebase/firestore/pipelines#Expression.(as:1)} on {@link @firebase/firestore/pipelines#AggregateFunction} instances.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average rating and the total number of books\n   * firestore.pipeline().collection(\"books\")\n   *     .aggregate(\n   *         field(\"rating\").avg().as(\"averageRating\"),\n   *         countAll().as(\"totalBooks\")\n   *     );\n   * ```\n   *\n   * @param accumulator - The first {@link @firebase/firestore/pipelines#AliasedAggregate}, wrapping an {@link @firebase/firestore/pipelines#AggregateFunction}\n   *     and providing a name for the accumulated results.\n   * @param additionalAccumulators - Optional additional {@link @firebase/firestore/pipelines#AliasedAggregate}, each wrapping an {@link @firebase/firestore/pipelines#AggregateFunction}\n   *     and providing a name for the accumulated results.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  aggregate(\n    accumulator: AliasedAggregate,\n    ...additionalAccumulators: AliasedAggregate[]\n  ): Pipeline;\n  /**\n   * @beta\n   * Performs optionally grouped aggregation operations on the documents from previous stages.\n   *\n   * <p>This stage allows you to calculate aggregate values over a set of documents, optionally\n   * grouped by one or more fields or functions. You can specify:\n   *\n   * <ul>\n   *   <li>**Grouping Fields or Functions:** One or more fields or functions to group the documents\n   *       by. For each distinct combination of values in these fields, a separate group is created.\n   *       If no grouping fields are provided, a single group containing all documents is used. Not\n   *       specifying groups is the same as putting the entire inputs into one group.</li>\n   *   <li>**Accumulators:** One or more accumulation operations to perform within each group. These\n   *       are defined using {@link @firebase/firestore/pipelines#AliasedAggregate} expressions, which are typically created by\n   *       calling {@link @firebase/firestore/pipelines#Expression.(as:1)} on {@link @firebase/firestore/pipelines#AggregateFunction} instances. Each aggregation\n   *       calculates a value (e.g., sum, average, count) based on the documents within its group.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average rating for each genre.\n   * firestore.pipeline().collection(\"books\")\n   *   .aggregate({\n   *       accumulators: [avg(field(\"rating\")).as(\"avg_rating\")]\n   *       groups: [\"genre\"]\n   *       });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage\n   * list.\n   */\n  aggregate(options: AggregateStageOptions): Pipeline;\n  aggregate(\n    targetOrOptions: AliasedAggregate | AggregateStageOptions,\n    ...rest: AliasedAggregate[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isAliasedAggregate(targetOrOptions) ? {} : targetOrOptions;\n    const accumulators: AliasedAggregate[] = isAliasedAggregate(targetOrOptions)\n      ? [targetOrOptions, ...rest]\n      : targetOrOptions.accumulators;\n    const groups: Array<Selectable | string> = isAliasedAggregate(\n      targetOrOptions\n    )\n      ? []\n      : targetOrOptions.groups ?? [];\n\n    // Convert user land convenience types to internal types\n    const convertedAccumulators: Map<string, AggregateFunction> =\n      aliasedAggregateToMap(accumulators);\n    const convertedGroups: Map<string, Expression> = selectablesToMap(groups);\n\n    // Create stage object\n    const stage = new Aggregate(\n      convertedGroups,\n      convertedAccumulators,\n      options\n    );\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'aggregate'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs a vector proximity search on the documents from the previous stage, returning the\n   * K-nearest documents based on the specified query `vectorValue` and `distanceMeasure`. The\n   * returned documents will be sorted in order from nearest to furthest from the query `vectorValue`.\n   *\n   * <p>Example:\n   *\n   * ```typescript\n   * // Find the 10 most similar books based on the book description.\n   * const bookDescription = \"Lorem ipsum...\";\n   * const queryVector: number[] = ...; // compute embedding of `bookDescription`\n   *\n   * firestore.pipeline().collection(\"books\")\n   *     .findNearest({\n   *       field: 'embedding',\n   *       vectorValue: queryVector,\n   *       distanceMeasure: 'euclidean',\n   *       limit: 10,                        // optional\n   *       distanceField: 'computedDistance' // optional\n   *     });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  findNearest(options: FindNearestStageOptions): Pipeline {\n    // Convert user land convenience types to internal types\n    const field = toField(options.field);\n    const vectorValue = vectorToExpr(options.vectorValue);\n    const distanceField = options.distanceField\n      ? toField(options.distanceField)\n      : undefined;\n    const internalOptions = {\n      distanceField,\n      limit: options.limit,\n      rawOptions: options.rawOptions\n    };\n\n    // Create stage object\n    const stage = new FindNearest(\n      vectorValue,\n      field,\n      options.distanceMeasure,\n      internalOptions\n    );\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'addFields'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Sorts the documents from previous stages based on one or more {@link @firebase/firestore/pipelines#Ordering} criteria.\n   *\n   * <p>This stage allows you to order the results of your pipeline. You can specify multiple {@link\n   * @firebase/firestore/pipelines#Ordering} instances to sort by multiple fields in ascending or descending order. If documents\n   * have the same value for a field used for sorting, the next specified ordering will be used. If\n   * all orderings result in equal comparison, the documents are considered equal and the order is\n   * unspecified.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Sort books by rating in descending order, and then by title in ascending order for books\n   * // with the same rating\n   * firestore.pipeline().collection(\"books\")\n   *     .sort(\n   *         Ordering.of(field(\"rating\")).descending(),\n   *         Ordering.of(field(\"title\"))  // Ascending order is the default\n   *     );\n   * ```\n   *\n   * @param ordering - The first {@link @firebase/firestore/pipelines#Ordering} instance specifying the sorting criteria.\n   * @param additionalOrderings - Optional additional {@link @firebase/firestore/pipelines#Ordering} instances specifying the additional sorting criteria.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sort(ordering: Ordering, ...additionalOrderings: Ordering[]): Pipeline;\n  /**\n   * @beta\n   * Sorts the documents from previous stages based on one or more {@link @firebase/firestore/pipelines#Ordering} criteria.\n   *\n   * <p>This stage allows you to order the results of your pipeline. You can specify multiple {@link\n   * @firebase/firestore/pipelines#Ordering} instances to sort by multiple fields in ascending or descending order. If documents\n   * have the same value for a field used for sorting, the next specified ordering will be used. If\n   * all orderings result in equal comparison, the documents are considered equal and the order is\n   * unspecified.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Sort books by rating in descending order, and then by title in ascending order for books\n   * // with the same rating\n   * firestore.pipeline().collection(\"books\")\n   *     .sort(\n   *         Ordering.of(field(\"rating\")).descending(),\n   *         Ordering.of(field(\"title\"))  // Ascending order is the default\n   *     );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sort(options: SortStageOptions): Pipeline;\n  sort(\n    orderingOrOptions: Ordering | SortStageOptions,\n    ...additionalOrderings: Ordering[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isOrdering(orderingOrOptions) ? {} : orderingOrOptions;\n    const orderings: Ordering[] = isOrdering(orderingOrOptions)\n      ? [orderingOrOptions, ...additionalOrderings]\n      : orderingOrOptions.orderings;\n\n    // Create stage object\n    const stage = new Sort(orderings, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'sort'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a nested map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith('parents');\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param fieldName - The {@link @firebase/firestore/pipelines#Field} field containing the nested map.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(fieldName: string): Pipeline;\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith(map({\n   *   foo: 'bar',\n   *   info: {\n   *     name: field('name')\n   *   }\n   * }));\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param expr - An {@link @firebase/firestore/pipelines#Expression} that when returned evaluates to a map.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(expr: Expression): Pipeline;\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith(map({\n   *   foo: 'bar',\n   *   info: {\n   *     name: field('name')\n   *   }\n   * }));\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(options: ReplaceWithStageOptions): Pipeline;\n  replaceWith(\n    valueOrOptions: Expression | string | ReplaceWithStageOptions\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(valueOrOptions) || isExpr(valueOrOptions) ? {} : valueOrOptions;\n    const fieldNameOrExpr: string | Expression =\n      isString(valueOrOptions) || isExpr(valueOrOptions)\n        ? valueOrOptions\n        : valueOrOptions.map;\n\n    // Convert user land convenience types to internal types\n    const mapExpr = fieldOrExpression(fieldNameOrExpr);\n\n    // Create stage object\n    const stage = new Replace(mapExpr, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'replaceWith'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs a pseudo-random sampling of the documents from the previous stage.\n   *\n   * <p>This stage will filter documents pseudo-randomly. The parameter specifies how number of\n   * documents to be returned.\n   *\n   * <p>Examples:\n   *\n   * @example\n   * ```typescript\n   * // Sample 25 books, if available.\n   * firestore.pipeline().collection('books')\n   *     .sample(25);\n   * ```\n   *\n   * @param documents - The number of documents to sample.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sample(documents: number): Pipeline;\n\n  /**\n   * @beta\n   * Performs a pseudo-random sampling of the documents from the previous stage.\n   *\n   * <p>This stage will filter documents pseudo-randomly. The 'options' parameter specifies how\n   * sampling will be performed. See {@link @firebase/firestore/pipelines#SampleStageOptions} for more information.\n   *\n   * @example\n   * ```typescript\n   * // Sample 10 books, if available.\n   * firestore.pipeline().collection(\"books\")\n   *     .sample({ documents: 10 });\n   *\n   * // Sample 50% of books.\n   * firestore.pipeline().collection(\"books\")\n   *     .sample({ percentage: 0.5 });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sample(options: SampleStageOptions): Pipeline;\n  sample(documentsOrOptions: number | SampleStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isNumber(documentsOrOptions) ? {} : documentsOrOptions;\n    let rate: number;\n    let mode: 'documents' | 'percent';\n    if (isNumber(documentsOrOptions)) {\n      rate = documentsOrOptions;\n      mode = 'documents';\n    } else if (isNumber(documentsOrOptions.documents)) {\n      rate = documentsOrOptions.documents;\n      mode = 'documents';\n    } else {\n      rate = documentsOrOptions.percentage!;\n      mode = 'percent';\n    }\n\n    // Create stage object\n    const stage = new Sample(rate, mode, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'sample'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs union of all documents from two pipelines, including duplicates.\n   *\n   * <p>This stage will pass through documents from previous stage, and also pass through documents\n   * from previous stage of the `other` {@link @firebase/firestore/pipelines#Pipeline} given in parameter. The order of documents\n   * emitted from this stage is undefined.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Emit documents from books collection and magazines collection.\n   * firestore.pipeline().collection('books')\n   *     .union(firestore.pipeline().collection('magazines'));\n   * ```\n   *\n   * @param other - The other {@link @firebase/firestore/pipelines#Pipeline} that is part of union.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  union(other: Pipeline): Pipeline;\n  /**\n   * @beta\n   * Performs union of all documents from two pipelines, including duplicates.\n   *\n   * <p>This stage will pass through documents from previous stage, and also pass through documents\n   * from previous stage of the `other` {@link @firebase/firestore/pipelines#Pipeline} given in parameter. The order of documents\n   * emitted from this stage is undefined.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Emit documents from books collection and magazines collection.\n   * firestore.pipeline().collection('books')\n   *     .union(firestore.pipeline().collection('magazines'));\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  union(options: UnionStageOptions): Pipeline;\n  union(otherOrOptions: Pipeline | UnionStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let otherPipeline: Pipeline;\n    if (isPipeline(otherOrOptions)) {\n      options = {};\n      otherPipeline = otherOrOptions;\n    } else {\n      ({ other: otherPipeline, ...options } = otherOrOptions);\n    }\n\n    // Create stage object\n    const stage = new Union(otherPipeline, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'union'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Produces a document for each element in an input array.\n   *\n   * For each previous stage document, this stage will emit zero or more augmented documents. The\n   * input array specified by the `selectable` parameter, will emit an augmented document for each input array element. The input array element will\n   * augment the previous stage document by setting the `alias` field  with the array element value.\n   *\n   * When `selectable` evaluates to a non-array value (ex: number, null, absent), then the stage becomes a no-op for\n   * the current input document, returning it as is with the `alias` field absent.\n   *\n   * No documents are emitted when `selectable` evaluates to an empty array.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Input:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tags\": [ \"comedy\", \"space\", \"adventure\" ], ... }\n   *\n   * // Emit a book document for each tag of the book.\n   * firestore.pipeline().collection(\"books\")\n   *     .unnest(field(\"tags\").as('tag'), 'tagIndex');\n   *\n   * // Output:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"comedy\", \"tagIndex\": 0, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"space\", \"tagIndex\": 1, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"adventure\", \"tagIndex\": 2, ... }\n   * ```\n   *\n   * @param selectable - A selectable expression defining the field to unnest and the alias to use for each un-nested element in the output documents.\n   * @param indexField - An optional string value specifying the field path to write the offset (starting at zero) into the array the un-nested element is from\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  unnest(selectable: Selectable, indexField?: string): Pipeline;\n  /**\n   * @beta\n   * Produces a document for each element in an input array.\n   *\n   * For each previous stage document, this stage will emit zero or more augmented documents. The\n   * input array specified by the `selectable` parameter, will emit an augmented document for each input array element. The input array element will\n   * augment the previous stage document by setting the `alias` field  with the array element value.\n   *\n   * When `selectable` evaluates to a non-array value (ex: number, null, absent), then the stage becomes a no-op for\n   * the current input document, returning it as is with the `alias` field absent.\n   *\n   * No documents are emitted when `selectable` evaluates to an empty array.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Input:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tags\": [ \"comedy\", \"space\", \"adventure\" ], ... }\n   *\n   * // Emit a book document for each tag of the book.\n   * firestore.pipeline().collection(\"books\")\n   *     .unnest(field(\"tags\").as('tag'), 'tagIndex');\n   *\n   * // Output:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"comedy\", \"tagIndex\": 0, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"space\", \"tagIndex\": 1, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"adventure\", \"tagIndex\": 2, ... }\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  unnest(options: UnnestStageOptions): Pipeline;\n  unnest(\n    selectableOrOptions: Selectable | UnnestStageOptions,\n    indexField?: string\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: { indexField?: Field } & StageOptions;\n    let selectable: Selectable;\n    let indexFieldName: string | undefined;\n    if (isSelectable(selectableOrOptions)) {\n      options = {};\n      selectable = selectableOrOptions;\n      indexFieldName = indexField;\n    } else {\n      ({\n        selectable,\n        indexField: indexFieldName,\n        ...options\n      } = selectableOrOptions);\n    }\n\n    // Convert user land convenience types to internal types\n    const alias = selectable.alias;\n    const expr = selectable.expr as Expression;\n    if (isString(indexFieldName)) {\n      options.indexField = _field(indexFieldName, 'unnest');\n    }\n\n    // Create stage object\n    const stage = new Unnest(alias, expr, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'unnest'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Adds a raw stage to the pipeline.\n   *\n   * <p>This method provides a flexible way to extend the pipeline's functionality by adding custom\n   * stages. Each raw stage is defined by a unique `name` and a set of `params` that control its\n   * behavior.\n   *\n   * <p>Example (Assuming there is no 'where' stage available in SDK):\n   *\n   * @example\n   * ```typescript\n   * // Assume we don't have a built-in 'where' stage\n   * firestore.pipeline().collection('books')\n   *     .rawStage('where', [field('published').lt(1900)]) // Custom 'where' stage\n   *     .select('title', 'author');\n   * ```\n   *\n   * @param name - The unique name of the raw stage to add.\n   * @param params - A list of parameters to configure the raw stage's behavior.\n   * @param options - An object of key value pairs that specifies optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  rawStage(\n    name: string,\n    params: unknown[],\n    options?: { [key: string]: Expression | unknown }\n  ): Pipeline {\n    // Convert user land convenience types to internal types\n    const expressionParams = params.map((value: unknown) => {\n      if (value instanceof Expression) {\n        return value;\n      } else if (value instanceof AggregateFunction) {\n        return value;\n      } else if (isPlainObject(value)) {\n        return _mapValue(value as Record<string, unknown>);\n      } else {\n        return _constant(value, 'rawStage');\n      }\n    });\n\n    // Create stage object\n    const stage = new RawStage(name, expressionParams, options ?? {});\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'rawStage'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(jsonProtoSerializer: JsonProtoSerializer): ProtoPipeline {\n    const stages: ProtoStage[] = this.stages.map(stage =>\n      stage._toProto(jsonProtoSerializer)\n    );\n    return { stages };\n  }\n\n  private _addStage(stage: Stage): Pipeline {\n    const copy = this.stages.map(s => s);\n    copy.push(stage);\n    return this.newPipeline(\n      this._db,\n      this.userDataReader,\n      this._userDataWriter,\n      copy\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   * @param db\n   * @param userDataReader\n   * @param userDataWriter\n   * @param stages\n   * @protected\n   */\n  protected newPipeline(\n    db: Firestore,\n    userDataReader: UserDataReader,\n    userDataWriter: AbstractUserDataWriter,\n    stages: Stage[]\n  ): Pipeline {\n    return new Pipeline(db, userDataReader, userDataWriter, stages);\n  }\n}\n\nexport function isPipeline(val: unknown): val is Pipeline {\n  return val instanceof Pipeline;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  StructuredPipeline,\n  StructuredPipelineOptions\n} from '../core/structured_pipeline';\nimport { invokeExecutePipeline } from '../remote/datastore';\n\nimport { getDatastore } from './components';\nimport { Firestore } from './database';\nimport { Pipeline } from './pipeline';\nimport { PipelineResult, PipelineSnapshot } from './pipeline-result';\nimport { PipelineSource } from './pipeline-source';\nimport { DocumentReference } from './reference';\nimport { LiteUserDataWriter } from './reference_impl';\nimport { Stage } from './stage';\nimport {\n  newUserDataReader,\n  UserDataReader,\n  UserDataSource\n} from './user_data_reader';\n\ndeclare module './database' {\n  interface Firestore {\n    /**\n     * @beta\n     * Creates and returns a new PipelineSource, which allows specifying the source stage of a {@link @firebase/firestore/pipelines#Pipeline}.\n     *\n     * @example\n     * ```\n     * let myPipeline: Pipeline = firestore.pipeline().collection('books');\n     * ```\n     */\n    pipeline(): PipelineSource<Pipeline>;\n  }\n}\n\n/**\n * @beta\n * Executes this pipeline and returns a Promise to represent the asynchronous operation.\n *\n * The returned Promise can be used to track the progress of the pipeline execution\n * and retrieve the results (or handle any errors) asynchronously.\n *\n * The pipeline results are returned as a {@link @firebase/firestore/pipelines#PipelineSnapshot} that contains\n * a list of {@link @firebase/firestore/pipelines#PipelineResult} objects. Each {@link @firebase/firestore/pipelines#PipelineResult} typically\n * represents a single key/value map that has passed through all the\n * stages of the pipeline, however this might differ depending on the stages involved in the\n * pipeline. For example:\n *\n * <ul>\n *   <li>If there are no stages or only transformation stages, each {@link @firebase/firestore/pipelines#PipelineResult}\n *       represents a single document.</li>\n *   <li>If there is an aggregation, only a single {@link @firebase/firestore/pipelines#PipelineResult} is returned,\n *       representing the aggregated results over the entire dataset .</li>\n *   <li>If there is an aggregation stage with grouping, each {@link @firebase/firestore/pipelines#PipelineResult} represents a\n *       distinct group and its associated aggregated values.</li>\n * </ul>\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await execute(firestore.pipeline().collection(\"books\")\n *     .where(gt(field(\"rating\"), 4.5))\n *     .select(\"title\", \"author\", \"rating\"));\n *\n * const results: PipelineResults = snapshot.results;\n * ```\n *\n * @param pipeline - The pipeline to execute.\n * @returns A Promise representing the asynchronous pipeline execution.\n */\nexport function execute(pipeline: Pipeline): Promise<PipelineSnapshot> {\n  const datastore = getDatastore(pipeline._db);\n\n  const udr = new UserDataReader(\n    pipeline._db._databaseId,\n    /* ignoreUndefinedProperties */ true\n  );\n  const context = udr.createContext(UserDataSource.Argument, 'execute');\n\n  const structuredPipelineOptions = new StructuredPipelineOptions({}, {});\n  structuredPipelineOptions._readUserData(context);\n\n  const structuredPipeline: StructuredPipeline = new StructuredPipeline(\n    pipeline,\n    structuredPipelineOptions\n  );\n\n  return invokeExecutePipeline(datastore, structuredPipeline).then(result => {\n    // Get the execution time from the first result.\n    // firestoreClientExecutePipeline returns at least one PipelineStreamElement\n    // even if the returned document set is empty.\n    const executionTime =\n      result.length > 0 ? result[0].executionTime?.toTimestamp() : undefined;\n\n    const docs = result\n      // Currently ignore any response from ExecutePipeline that does\n      // not contain any document data in the `fields` property.\n      .filter(element => !!element.fields)\n      .map(\n        element =>\n          new PipelineResult(\n            pipeline._userDataWriter,\n            element.fields!,\n            element.key?.path\n              ? new DocumentReference(pipeline._db, null, element.key)\n              : undefined,\n            element.createTime?.toTimestamp(),\n            element.updateTime?.toTimestamp()\n          )\n      );\n\n    return new PipelineSnapshot(pipeline, docs, executionTime);\n  });\n}\n\n/**\n * @beta\n * Creates and returns a new PipelineSource, which allows specifying the source stage of a {@link @firebase/firestore/pipelines#Pipeline}.\n *\n * @example\n * ```\n * let myPipeline: Pipeline = firestore.pipeline().collection('books');\n * ```\n */\nFirestore.prototype.pipeline = function (): PipelineSource<Pipeline> {\n  const userDataWriter = new LiteUserDataWriter(this);\n  const userDataReader = newUserDataReader(this);\n  return new PipelineSource<Pipeline>(\n    this._databaseId,\n    userDataReader,\n    (stages: Stage[]) => {\n      return new Pipeline(this, userDataReader, userDataWriter, stages);\n    }\n  );\n};\n"],"names":["OptionsUtil","constructor","optionDefinitions","this","_getKnownOptions","options","context","knownOptions","ObjectValue","empty","__PRIVATE_knownOptionKey","hasOwnProperty","__PRIVATE_optionDefinition","__PRIVATE_optionValue","__PRIVATE_protoValue","nestedOptions","__PRIVATE_isPlainObject","mapValue","fields","getOptionsProto","__PRIVATE_parseData","undefined","set","FieldPath","fromServerFormat","serverName","optionsOverride","result","__PRIVATE_optionsMap","Map","__PRIVATE_mapToArray","value","key","setAll","__PRIVATE_StructuredPipelineOptions","__PRIVATE__userOptions","__PRIVATE__optionsOverride","__PRIVATE_optionsUtil","indexMode","_readUserData","proto","StructuredPipeline","pipeline","_toProto","serializer","__PRIVATE_isFirestoreValue","obj","nullValue","booleanValue","integerValue","doubleValue","timestampValue","__PRIVATE_isITimestamp","seconds","nanos","stringValue","bytesValue","Uint8Array","referenceValue","geoPointValue","__PRIVATE_isILatLng","latitude","longitude","arrayValue","__PRIVATE_isIArrayValue","values","Array","isArray","__PRIVATE_isIMapValue","fieldReferenceValue","functionValue","__PRIVATE_isIFunction","name","args","pipelineValue","__PRIVATE_isIPipeline","stages","__PRIVATE_valueToDefaultExpr","Expression","__PRIVATE__map","array","__PRIVATE__constant","__PRIVATE_vectorToExpr","VectorValue","constant","vector","Error","__PRIVATE_fieldOrExpression","__PRIVATE_isString","field","_protoValueType","add","second","FunctionExpression","asBoolean","BooleanExpression","Constant","__PRIVATE_BooleanConstant","Field","__PRIVATE_BooleanField","__PRIVATE_BooleanFunctionExpression","FirestoreError","subtract","subtrahend","multiply","divide","divisor","mod","other","equal","notEqual","lessThan","lessThanOrEqual","greaterThan","greaterThanOrEqual","arrayConcat","secondArray","otherArrays","__PRIVATE_exprValues","map","arrayContains","element","arrayContainsAll","__PRIVATE_normalizedExpr","__PRIVATE_ListOfExprs","arrayContainsAny","arrayReverse","arrayLength","equalAny","others","__PRIVATE_exprOthers","notEqualAny","exists","charLength","like","__PRIVATE_stringOrExpr","regexContains","regexMatch","stringContains","startsWith","endsWith","toLower","toUpper","trim","valueToTrim","push","stringConcat","secondString","otherStrings","__PRIVATE_exprs","concat","reverse","byteLength","ceil","floor","abs","exp","mapGet","subfield","count","AggregateFunction","_create","sum","average","minimum","maximum","countDistinct","logicalMaximum","logicalMinimum","vectorLength","cosineDistance","dotProduct","euclideanDistance","unixMicrosToTimestamp","timestampToUnixMicros","unixMillisToTimestamp","timestampToUnixMillis","unixSecondsToTimestamp","timestampToUnixSeconds","timestampAdd","unit","amount","timestampSubtract","documentId","substring","position","length","__PRIVATE_positionExpr","arrayGet","offset","isError","ifError","catchValue","isAbsent","mapRemove","__PRIVATE_stringExpr","mapMerge","secondMap","otherMaps","__PRIVATE_secondMapExpr","__PRIVATE_otherMapExprs","pow","exponent","round","decimalPlaces","collectionId","ln","sqrt","stringReverse","ifAbsent","__PRIVATE_elseValueOrExpression","join","__PRIVATE_delimeterValueOrExpression","log10","arraySum","split","delimiter","timestampTruncate","granularity","timezone","toLowerCase","type","ascending","descending","as","AliasedExpression","params","exprType","methodName","__PRIVATE_af","_methodName","AliasedAggregate","p","contextWith","forEach","expr","aggregate","alias","selectable","super","expressionType","fieldPath","fieldName","canonicalString","nameOrPath","_field","__PRIVATE_DOCUMENT_KEY_NAME","__PRIVATE_documentIdFieldPath","_internalPath","__PRIVATE_fieldPathFromArgument","_fromProto","_protoValue","_","__PRIVATE_hardAssert","c","MapValue","__PRIVATE_plainObject","__PRIVATE_toMapValue","_expr","countIf","not","conditional","thenExpr","elseExpr","__PRIVATE_normalizedCatchValue","booleanExpr","tryExpr","mapExpr","firstMap","documentPath","__PRIVATE_fieldExpr","__PRIVATE_lengthExpr","first","left","right","__PRIVATE_normalizedLeft","__PRIVATE_normalizedRight","elements","Object","prototype","call","__PRIVATE__array","__PRIVATE_leftExpr","__PRIVATE_rightExpr","firstArray","__PRIVATE_arrayExpr","__PRIVATE_elementExpr","xor","additionalConditions","condition","__PRIVATE_valueOrField","__PRIVATE_expressionOrFieldName","pattern","__PRIVATE_patternExpr","__PRIVATE_substringExpr","prefix","suffix","__PRIVATE_fieldOrExpr","subField","countAll","__PRIVATE_expr1","__PRIVATE_expr2","timestamp","__PRIVATE_normalizedTimestamp","__PRIVATE_normalizedUnit","__PRIVATE_normalizedAmount","currentTimestamp","and","more","or","base","log","__PRIVATE_fieldNameOrExpression","elseValue","__PRIVATE_delimiterValueOrExpression","__PRIVATE_internalGranularity","Ordering","direction","__PRIVATE_toStringValue","expression","__PRIVATE_isSelectable","val","candidate","__PRIVATE_isExpr","__PRIVATE_isOrdering","__PRIVATE_isAliasedAggregate","__PRIVATE_isBooleanExpr","__PRIVATE_isField","__PRIVATE_toField","__PRIVATE_toPipelineBooleanExpr","f","__PRIVATE_FieldFilterInternal","fieldValue","toString","op","fail","__PRIVATE_CompositeFilterInternal","__PRIVATE_conditions","getFilters","slice","__PRIVATE_toPipeline","query","db","__PRIVATE_isCollectionGroupQuery","collectionGroup","__PRIVATE_isDocumentQuery","documents","doc","path","collection","filter","filters","where","__PRIVATE_orders","__PRIVATE_queryNormalizedOrderBy","__PRIVATE_existsConditions","order","orderings","dir","limitType","__PRIVATE_actualOrderings","__PRIVATE_reverseOrderings","o","sort","startAt","__PRIVATE_whereConditionsFromCursor","endAt","limit","bound","__PRIVATE_filterFunc","__PRIVATE_cursors","size","inclusive","__PRIVATE_i","Stage","optionsProto","rawOptions","_optionsUtil","_name","__PRIVATE_AddFields","__PRIVATE_readUserDataHelper","__PRIVATE_RemoveFields","__PRIVATE_Aggregate","groups","accumulators","__PRIVATE_Distinct","__PRIVATE_CollectionSource","forceIndex","__PRIVATE_formattedCollectionPath","__PRIVATE_CollectionGroupSource","__PRIVATE_DatabaseSource","__PRIVATE_DocumentsSource","__PRIVATE_docPaths","__PRIVATE_formattedPaths","__PRIVATE_Where","__PRIVATE_FindNearest","distanceField","vectorValue","distanceMeasure","__PRIVATE_Limit","isNaN","Infinity","toNumber","__PRIVATE_Offset","__PRIVATE_Select","selections","__PRIVATE_Sort","__PRIVATE_Sample","rate","mode","__PRIVATE_Union","__PRIVATE_toPipelineValue","__PRIVATE_Unnest","indexField","__PRIVATE_Replace","__PRIVATE_MODE","__PRIVATE_RawStage","__PRIVATE_expressionMap","__PRIVATE_isUserData","__PRIVATE_readableData","PipelineSource","databaseId","userDataReader","_createPipeline","__PRIVATE_collectionOrOptions","__PRIVATE_isCollectionReference","__PRIVATE_collectionRefOrString","_validateReference","__PRIVATE_normalizedCollection","__PRIVATE_stage","__PRIVATE_parseContext","createContext","__PRIVATE_collectionIdOrOptions","database","__PRIVATE_docsOrOptions","docs","v","DocumentReference","__PRIVATE_dr","__PRIVATE_normalizedDocs","createFrom","_query","firestore","reference","__PRIVATE_refDbId","_databaseId","isEqual","Code","INVALID_ARGUMENT","CollectionReference","projectId","PipelineSnapshot","results","executionTime","_pipeline","_executionTime","_results","PipelineResult","userDataWriter","ref","createTime","updateTime","_ref","_userDataWriter","_createTime","_updateTime","_fields","id","data","convertValue","_fieldsProto","clone","get","__PRIVATE_selectablesToMap","__PRIVATE_selectables","Pipeline","_db","addFields","__PRIVATE_fieldOrOptions","additionalFields","__PRIVATE_normalizedFields","_addStage","removeFields","__PRIVATE_fieldValueOrOptions","__PRIVATE_convertedFields","select","__PRIVATE_selectionOrOptions","additionalSelections","__PRIVATE_normalizedSelections","__PRIVATE_conditionOrOptions","__PRIVATE_offsetOrOptions","__PRIVATE_isNumber","__PRIVATE_limitOrOptions","distinct","__PRIVATE_groupOrOptions","additionalGroups","__PRIVATE_convertedGroups","__PRIVATE_targetOrOptions","__PRIVATE_rest","__PRIVATE_convertedAccumulators","__PRIVATE_aliasedAggregateToMap","__PRIVATE_aliasedAggregatees","reduce","findNearest","__PRIVATE_internalOptions","__PRIVATE_orderingOrOptions","additionalOrderings","replaceWith","__PRIVATE_valueOrOptions","sample","__PRIVATE_documentsOrOptions","percentage","union","__PRIVATE_otherOrOptions","__PRIVATE_otherPipeline","__PRIVATE_isPipeline","unnest","__PRIVATE_selectableOrOptions","__PRIVATE_indexFieldName","rawStage","__PRIVATE_expressionParams","__PRIVATE__mapValue","jsonProtoSerializer","copy","s","newPipeline","execute","datastore","__PRIVATE_getDatastore","UserDataReader","__PRIVATE_structuredPipelineOptions","structuredPipeline","__PRIVATE_invokeExecutePipeline","then","toTimestamp","Firestore","__PRIVATE_LiteUserDataWriter","__PRIVATE_newUserDataReader"],"mappings":"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"}